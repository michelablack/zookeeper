<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuorumPeer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server.quorum</a> &gt; <span class="el_source">QuorumPeer.java</span></div><h1>QuorumPeer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server.quorum;

import static org.apache.zookeeper.common.NetUtils.formatInetAddr;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import javax.security.sasl.SaslException;
import org.apache.yetus.audience.InterfaceAudience;
import org.apache.zookeeper.KeeperException.BadArgumentsException;
import org.apache.zookeeper.common.AtomicFileOutputStream;
import org.apache.zookeeper.common.AtomicFileWritingIdiom;
import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;
import org.apache.zookeeper.common.QuorumX509Util;
import org.apache.zookeeper.common.Time;
import org.apache.zookeeper.common.X509Exception;
import org.apache.zookeeper.jmx.MBeanRegistry;
import org.apache.zookeeper.jmx.ZKMBeanInfo;
import org.apache.zookeeper.server.ServerCnxn;
import org.apache.zookeeper.server.ServerCnxnFactory;
import org.apache.zookeeper.server.ServerMetrics;
import org.apache.zookeeper.server.ZKDatabase;
import org.apache.zookeeper.server.ZooKeeperServer;
import org.apache.zookeeper.server.ZooKeeperThread;
import org.apache.zookeeper.server.admin.AdminServer;
import org.apache.zookeeper.server.admin.AdminServer.AdminServerException;
import org.apache.zookeeper.server.admin.AdminServerFactory;
import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthLearner;
import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthServer;
import org.apache.zookeeper.server.quorum.auth.QuorumAuth;
import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;
import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;
import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthLearner;
import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthServer;
import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
import org.apache.zookeeper.server.quorum.flexible.QuorumOracleMaj;
import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
import org.apache.zookeeper.server.util.ConfigUtils;
import org.apache.zookeeper.server.util.JvmPauseMonitor;
import org.apache.zookeeper.server.util.ZxidUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class manages the quorum protocol. There are three states this server
 * can be in:
 * &lt;ol&gt;
 * &lt;li&gt;Leader election - each server will elect a leader (proposing itself as a
 * leader initially).&lt;/li&gt;
 * &lt;li&gt;Follower - the server will synchronize with the leader and replicate any
 * transactions.&lt;/li&gt;
 * &lt;li&gt;Leader - the server will process requests and forward them to followers.
 * A majority of followers must log the request before it can be accepted.
 * &lt;/ol&gt;
 *
 * This class will setup a datagram socket that will always respond with its
 * view of the current leader. The response will take the form of:
 *
 * &lt;pre&gt;
 * int xid;
 *
 * long myid;
 *
 * long leader_id;
 *
 * long leader_zxid;
 * &lt;/pre&gt;
 *
 * The request for the current leader will consist solely of an xid: int xid;
 */
<span class="nc bnc" id="L117" title="All 2 branches missed.">public class QuorumPeer extends ZooKeeperThread implements QuorumStats.Provider {</span>

<span class="nc" id="L119">    private static final Logger LOG = LoggerFactory.getLogger(QuorumPeer.class);</span>

    public static final String CONFIG_KEY_KERBEROS_CANONICALIZE_HOST_NAMES = &quot;zookeeper.kerberos.canonicalizeHostNames&quot;;
    public static final String CONFIG_DEFAULT_KERBEROS_CANONICALIZE_HOST_NAMES = &quot;false&quot;;

    private QuorumBean jmxQuorumBean;
    LocalPeerBean jmxLocalPeerBean;
    private Map&lt;Long, RemotePeerBean&gt; jmxRemotePeerBean;
    LeaderElectionBean jmxLeaderElectionBean;

    // The QuorumCnxManager is held through an AtomicReference to ensure cross-thread visibility
    // of updates; see the implementation comment at setLastSeenQuorumVerifier().
<span class="nc" id="L131">    private AtomicReference&lt;QuorumCnxManager&gt; qcmRef = new AtomicReference&lt;&gt;();</span>

    QuorumAuthServer authServer;
    QuorumAuthLearner authLearner;

    /**
     * ZKDatabase is a top level member of quorumpeer
     * which will be used in all the zookeeperservers
     * instantiated later. Also, it is created once on
     * bootup and only thrown away in case of a truncate
     * message from the leader
     */
    private ZKDatabase zkDb;

    private JvmPauseMonitor jvmPauseMonitor;

    public static final class AddressTuple {

        public final MultipleAddresses quorumAddr;
        public final MultipleAddresses electionAddr;
        public final InetSocketAddress clientAddr;

<span class="nc" id="L153">        public AddressTuple(MultipleAddresses quorumAddr, MultipleAddresses electionAddr, InetSocketAddress clientAddr) {</span>
<span class="nc" id="L154">            this.quorumAddr = quorumAddr;</span>
<span class="nc" id="L155">            this.electionAddr = electionAddr;</span>
<span class="nc" id="L156">            this.clientAddr = clientAddr;</span>
<span class="nc" id="L157">        }</span>

    }

    private int observerMasterPort;

    public int getObserverMasterPort() {
<span class="nc" id="L164">        return observerMasterPort;</span>
    }

    public void setObserverMasterPort(int observerMasterPort) {
<span class="nc" id="L168">        this.observerMasterPort = observerMasterPort;</span>
<span class="nc" id="L169">    }</span>

    public static final String CONFIG_KEY_MULTI_ADDRESS_ENABLED = &quot;zookeeper.multiAddress.enabled&quot;;
    public static final String CONFIG_DEFAULT_MULTI_ADDRESS_ENABLED = &quot;false&quot;;

<span class="nc" id="L174">    private boolean multiAddressEnabled = true;</span>
    public boolean isMultiAddressEnabled() {
<span class="nc" id="L176">        return multiAddressEnabled;</span>
    }

    public void setMultiAddressEnabled(boolean multiAddressEnabled) {
<span class="nc" id="L180">        this.multiAddressEnabled = multiAddressEnabled;</span>
<span class="nc" id="L181">        LOG.info(&quot;multiAddress.enabled set to {}&quot;, multiAddressEnabled);</span>
<span class="nc" id="L182">    }</span>

    public static final String CONFIG_KEY_MULTI_ADDRESS_REACHABILITY_CHECK_TIMEOUT_MS = &quot;zookeeper.multiAddress.reachabilityCheckTimeoutMs&quot;;

<span class="nc" id="L186">    private int multiAddressReachabilityCheckTimeoutMs = (int) MultipleAddresses.DEFAULT_TIMEOUT.toMillis();</span>
    public int getMultiAddressReachabilityCheckTimeoutMs() {
<span class="nc" id="L188">        return multiAddressReachabilityCheckTimeoutMs;</span>
    }

    public void setMultiAddressReachabilityCheckTimeoutMs(int multiAddressReachabilityCheckTimeoutMs) {
<span class="nc" id="L192">        this.multiAddressReachabilityCheckTimeoutMs = multiAddressReachabilityCheckTimeoutMs;</span>
<span class="nc" id="L193">        LOG.info(&quot;multiAddress.reachabilityCheckTimeoutMs set to {}&quot;, multiAddressReachabilityCheckTimeoutMs);</span>
<span class="nc" id="L194">    }</span>

    public static final String CONFIG_KEY_MULTI_ADDRESS_REACHABILITY_CHECK_ENABLED = &quot;zookeeper.multiAddress.reachabilityCheckEnabled&quot;;

<span class="nc" id="L198">    private boolean multiAddressReachabilityCheckEnabled = true;</span>

    public boolean isMultiAddressReachabilityCheckEnabled() {
<span class="nc" id="L201">        return multiAddressReachabilityCheckEnabled;</span>
    }

    public void setMultiAddressReachabilityCheckEnabled(boolean multiAddressReachabilityCheckEnabled) {
<span class="nc" id="L205">        this.multiAddressReachabilityCheckEnabled = multiAddressReachabilityCheckEnabled;</span>
<span class="nc" id="L206">        LOG.info(&quot;multiAddress.reachabilityCheckEnabled set to {}&quot;, multiAddressReachabilityCheckEnabled);</span>
<span class="nc" id="L207">    }</span>

<span class="nc bnc" id="L209" title="All 2 branches missed.">    public static class QuorumServer {</span>

<span class="nc" id="L211">        public MultipleAddresses addr = new MultipleAddresses();</span>

<span class="nc" id="L213">        public MultipleAddresses electionAddr = new MultipleAddresses();</span>

<span class="nc" id="L215">        public InetSocketAddress clientAddr = null;</span>

        public long id;

        public String hostname;

<span class="nc" id="L221">        public LearnerType type = LearnerType.PARTICIPANT;</span>

<span class="nc" id="L223">        public boolean isClientAddrFromStatic = false;</span>

        private List&lt;InetSocketAddress&gt; myAddrs;

        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
<span class="nc" id="L228">            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);</span>
<span class="nc" id="L229">        }</span>

        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr) {
<span class="nc" id="L232">            this(id, addr, electionAddr, null, LearnerType.PARTICIPANT);</span>
<span class="nc" id="L233">        }</span>

        // VisibleForTesting
        public QuorumServer(long id, InetSocketAddress addr) {
<span class="nc" id="L237">            this(id, addr, null, null, LearnerType.PARTICIPANT);</span>
<span class="nc" id="L238">        }</span>

        public long getId() {
<span class="nc" id="L241">            return id;</span>
        }

        /**
         * Performs a DNS lookup for server address and election address.
         *
         * If the DNS lookup fails, this.addr and electionAddr remain
         * unmodified.
         */
        public void recreateSocketAddresses() {
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if (this.addr.isEmpty()) {</span>
<span class="nc" id="L252">                LOG.warn(&quot;Server address has not been initialized&quot;);</span>
<span class="nc" id="L253">                return;</span>
            }
<span class="nc bnc" id="L255" title="All 2 branches missed.">            if (this.electionAddr.isEmpty()) {</span>
<span class="nc" id="L256">                LOG.warn(&quot;Election address has not been initialized&quot;);</span>
<span class="nc" id="L257">                return;</span>
            }
<span class="nc" id="L259">            this.addr.recreateSocketAddresses();</span>
<span class="nc" id="L260">            this.electionAddr.recreateSocketAddresses();</span>
<span class="nc" id="L261">        }</span>

        private LearnerType getType(String s) throws ConfigException {
<span class="nc bnc" id="L264" title="All 3 branches missed.">            switch (s.trim().toLowerCase()) {</span>
                case &quot;observer&quot;:
<span class="nc" id="L266">                    return LearnerType.OBSERVER;</span>
                case &quot;participant&quot;:
<span class="nc" id="L268">                    return LearnerType.PARTICIPANT;</span>
                default:
<span class="nc" id="L270">                    throw new ConfigException(&quot;Unrecognised peertype: &quot; + s);</span>
            }
        }

        public QuorumServer(long sid, String addressStr) throws ConfigException {
<span class="nc" id="L275">            this(sid, addressStr, QuorumServer::getInetAddress);</span>
<span class="nc" id="L276">        }</span>

<span class="nc" id="L278">        QuorumServer(long sid, String addressStr, Function&lt;InetSocketAddress, InetAddress&gt; getInetAddress) throws ConfigException {</span>
<span class="nc" id="L279">            this.id = sid;</span>
<span class="nc" id="L280">            initializeWithAddressString(addressStr, getInetAddress);</span>
<span class="nc" id="L281">        }</span>

        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, LearnerType type) {
<span class="nc" id="L284">            this(id, addr, electionAddr, null, type);</span>
<span class="nc" id="L285">        }</span>

<span class="nc" id="L287">        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, InetSocketAddress clientAddr, LearnerType type) {</span>
<span class="nc" id="L288">            this.id = id;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (addr != null) {</span>
<span class="nc" id="L290">                this.addr.addAddress(addr);</span>
            }
<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (electionAddr != null) {</span>
<span class="nc" id="L293">                this.electionAddr.addAddress(electionAddr);</span>
            }
<span class="nc" id="L295">            this.type = type;</span>
<span class="nc" id="L296">            this.clientAddr = clientAddr;</span>

<span class="nc" id="L298">            setMyAddrs();</span>
<span class="nc" id="L299">        }</span>

        private static final String wrongFormat =
            &quot; does not have the form server_config or server_config;client_config&quot;
            + &quot; where server_config is the pipe separated list of host:port:port or host:port:port:type&quot;
            + &quot; and client_config is port or host:port&quot;;

        private void initializeWithAddressString(String addressStr, Function&lt;InetSocketAddress, InetAddress&gt; getInetAddress) throws ConfigException {
<span class="nc" id="L307">            LearnerType newType = null;</span>
<span class="nc" id="L308">            String[] serverClientParts = addressStr.split(&quot;;&quot;);</span>
<span class="nc" id="L309">            String[] serverAddresses = serverClientParts[0].split(&quot;\\|&quot;);</span>

<span class="nc bnc" id="L311" title="All 2 branches missed.">            if (serverClientParts.length == 2) {</span>
<span class="nc" id="L312">                String[] clientParts = ConfigUtils.getHostAndPort(serverClientParts[1]);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">                if (clientParts.length &gt; 2) {</span>
<span class="nc" id="L314">                    throw new ConfigException(addressStr + wrongFormat);</span>
                }

                // is client_config a host:port or just a port
<span class="nc bnc" id="L318" title="All 2 branches missed.">                String clientHostName = (clientParts.length == 2) ? clientParts[0] : &quot;0.0.0.0&quot;;</span>
                try {
<span class="nc" id="L320">                    clientAddr = new InetSocketAddress(clientHostName, Integer.parseInt(clientParts[clientParts.length - 1]));</span>
<span class="nc" id="L321">                } catch (NumberFormatException e) {</span>
<span class="nc" id="L322">                    throw new ConfigException(&quot;Address unresolved: &quot; + hostname + &quot;:&quot; + clientParts[clientParts.length - 1]);</span>
<span class="nc" id="L323">                }</span>
            }

<span class="nc" id="L326">            boolean multiAddressEnabled = Boolean.parseBoolean(</span>
<span class="nc" id="L327">                System.getProperty(QuorumPeer.CONFIG_KEY_MULTI_ADDRESS_ENABLED, QuorumPeer.CONFIG_DEFAULT_MULTI_ADDRESS_ENABLED));</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">            if (!multiAddressEnabled &amp;&amp; serverAddresses.length &gt; 1) {</span>
<span class="nc" id="L329">                throw new ConfigException(&quot;Multiple address feature is disabled, but multiple addresses were specified for sid &quot; + this.id);</span>
            }

<span class="nc" id="L332">            boolean canonicalize = Boolean.parseBoolean(</span>
<span class="nc" id="L333">                System.getProperty(</span>
                    CONFIG_KEY_KERBEROS_CANONICALIZE_HOST_NAMES,
                    CONFIG_DEFAULT_KERBEROS_CANONICALIZE_HOST_NAMES));

<span class="nc bnc" id="L337" title="All 2 branches missed.">            for (String serverAddress : serverAddresses) {</span>
<span class="nc" id="L338">                String serverParts[] = ConfigUtils.getHostAndPort(serverAddress);</span>
<span class="nc bnc" id="L339" title="All 6 branches missed.">                if ((serverClientParts.length &gt; 2) || (serverParts.length &lt; 3)</span>
                        || (serverParts.length &gt; 4)) {
<span class="nc" id="L341">                    throw new ConfigException(addressStr + wrongFormat);</span>
                }

<span class="nc" id="L344">                String serverHostName = serverParts[0];</span>

                // server_config should be either host:port:port or host:port:port:type
                InetSocketAddress tempAddress;
                InetSocketAddress tempElectionAddress;
                try {
<span class="nc" id="L350">                    tempAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[1]));</span>
<span class="nc" id="L351">                    addr.addAddress(tempAddress);</span>
<span class="nc" id="L352">                } catch (NumberFormatException e) {</span>
<span class="nc" id="L353">                    throw new ConfigException(&quot;Address unresolved: &quot; + serverHostName + &quot;:&quot; + serverParts[1]);</span>
<span class="nc" id="L354">                }</span>
                try {
<span class="nc" id="L356">                    tempElectionAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[2]));</span>
<span class="nc" id="L357">                    electionAddr.addAddress(tempElectionAddress);</span>
<span class="nc" id="L358">                } catch (NumberFormatException e) {</span>
<span class="nc" id="L359">                    throw new ConfigException(&quot;Address unresolved: &quot; + serverHostName + &quot;:&quot; + serverParts[2]);</span>
<span class="nc" id="L360">                }</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">                if (tempAddress.getPort() == tempElectionAddress.getPort()) {</span>
<span class="nc" id="L363">                    throw new ConfigException(&quot;Client and election port must be different! Please update the &quot;</span>
                            + &quot;configuration file on server.&quot; + this.id);
                }

<span class="nc bnc" id="L367" title="All 2 branches missed.">                if (canonicalize) {</span>
<span class="nc" id="L368">                    InetAddress ia = getInetAddress.apply(tempAddress);</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                    if (ia == null) {</span>
<span class="nc" id="L370">                        throw new ConfigException(&quot;Unable to canonicalize address &quot; + serverHostName + &quot; because it's not resolvable&quot;);</span>
                    }

<span class="nc" id="L373">                    String canonicalHostName = ia.getCanonicalHostName();</span>

<span class="nc bnc" id="L375" title="All 2 branches missed.">                    if (!canonicalHostName.equals(serverHostName)</span>
                        // Avoid using literal IP address when
                        // security check fails
<span class="nc bnc" id="L378" title="All 2 branches missed.">                        &amp;&amp; !canonicalHostName.equals(ia.getHostAddress())) {</span>
<span class="nc" id="L379">                        LOG.info(&quot;Host name for quorum server {} &quot;</span>
                            + &quot;canonicalized from {} to {}&quot;,
<span class="nc" id="L381">                            this.id, serverHostName, canonicalHostName);</span>
<span class="nc" id="L382">                        serverHostName = canonicalHostName;</span>
                    }
                }

<span class="nc bnc" id="L386" title="All 2 branches missed.">                if (serverParts.length == 4) {</span>
<span class="nc" id="L387">                    LearnerType tempType = getType(serverParts[3]);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">                    if (newType == null) {</span>
<span class="nc" id="L389">                        newType = tempType;</span>
                    }

<span class="nc bnc" id="L392" title="All 2 branches missed.">                    if (newType != tempType) {</span>
<span class="nc" id="L393">                        throw new ConfigException(&quot;Multiple addresses should have similar roles: &quot; + type + &quot; vs &quot; + tempType);</span>
                    }
                }

<span class="nc" id="L397">                this.hostname = serverHostName;</span>
            }

<span class="nc bnc" id="L400" title="All 2 branches missed.">            if (newType != null) {</span>
<span class="nc" id="L401">                type = newType;</span>
            }

<span class="nc" id="L404">            setMyAddrs();</span>
<span class="nc" id="L405">        }</span>

        private static InetAddress getInetAddress(InetSocketAddress addr) {
<span class="nc" id="L408">            return addr.getAddress();</span>
        }

        private void setMyAddrs() {
<span class="nc" id="L412">            this.myAddrs = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L413">            this.myAddrs.addAll(this.addr.getAllAddresses());</span>
<span class="nc" id="L414">            this.myAddrs.add(this.clientAddr);</span>
<span class="nc" id="L415">            this.myAddrs.addAll(this.electionAddr.getAllAddresses());</span>
<span class="nc" id="L416">            this.myAddrs = excludedSpecialAddresses(this.myAddrs);</span>
<span class="nc" id="L417">        }</span>

        public static String delimitedHostString(InetSocketAddress addr) {
<span class="nc" id="L420">            String host = addr.getHostString();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (host.contains(&quot;:&quot;)) {</span>
<span class="nc" id="L422">                return &quot;[&quot; + host + &quot;]&quot;;</span>
            } else {
<span class="nc" id="L424">                return host;</span>
            }
        }

        public String toString() {
<span class="nc" id="L429">            StringWriter sw = new StringWriter();</span>

<span class="nc" id="L431">            List&lt;InetSocketAddress&gt; addrList = new LinkedList&lt;&gt;(addr.getAllAddresses());</span>
<span class="nc" id="L432">            List&lt;InetSocketAddress&gt; electionAddrList = new LinkedList&lt;&gt;(electionAddr.getAllAddresses());</span>

<span class="nc bnc" id="L434" title="All 4 branches missed.">            if (addrList.size() &gt; 0 &amp;&amp; electionAddrList.size() &gt; 0) {</span>
<span class="nc" id="L435">                addrList.sort(Comparator.comparing(InetSocketAddress::getHostString));</span>
<span class="nc" id="L436">                electionAddrList.sort(Comparator.comparing(InetSocketAddress::getHostString));</span>
<span class="nc" id="L437">                sw.append(IntStream.range(0, addrList.size()).mapToObj(i -&gt; String.format(&quot;%s:%d:%d&quot;,</span>
<span class="nc" id="L438">                        delimitedHostString(addrList.get(i)), addrList.get(i).getPort(), electionAddrList.get(i).getPort()))</span>
<span class="nc" id="L439">                        .collect(Collectors.joining(&quot;|&quot;)));</span>
            }

<span class="nc bnc" id="L442" title="All 2 branches missed.">            if (type == LearnerType.OBSERVER) {</span>
<span class="nc" id="L443">                sw.append(&quot;:observer&quot;);</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">            } else if (type == LearnerType.PARTICIPANT) {</span>
<span class="nc" id="L445">                sw.append(&quot;:participant&quot;);</span>
            }

<span class="nc bnc" id="L448" title="All 4 branches missed.">            if (clientAddr != null &amp;&amp; !isClientAddrFromStatic) {</span>
<span class="nc" id="L449">                sw.append(&quot;;&quot;);</span>
<span class="nc" id="L450">                sw.append(delimitedHostString(clientAddr));</span>
<span class="nc" id="L451">                sw.append(&quot;:&quot;);</span>
<span class="nc" id="L452">                sw.append(String.valueOf(clientAddr.getPort()));</span>
            }

<span class="nc" id="L455">            return sw.toString();</span>
        }

        public int hashCode() {
<span class="nc bnc" id="L459" title="All 2 branches missed.">            assert false : &quot;hashCode not designed&quot;;</span>
<span class="nc" id="L460">            return 42; // any arbitrary constant will do</span>
        }

        private boolean checkAddressesEqual(InetSocketAddress addr1, InetSocketAddress addr2) {
<span class="nc bnc" id="L464" title="All 12 branches missed.">            return (addr1 != null || addr2 == null)</span>
                   &amp;&amp; (addr1 == null || addr2 != null)
<span class="nc bnc" id="L466" title="All 2 branches missed.">                   &amp;&amp; (addr1 == null || addr2 == null || addr1.equals(addr2));</span>
        }

        public boolean equals(Object o) {
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (!(o instanceof QuorumServer)) {</span>
<span class="nc" id="L471">                return false;</span>
            }
<span class="nc" id="L473">            QuorumServer qs = (QuorumServer) o;</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">            if ((qs.id != id) || (qs.type != type)) {</span>
<span class="nc" id="L475">                return false;</span>
            }
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (!addr.equals(qs.addr)) {</span>
<span class="nc" id="L478">                return false;</span>
            }
<span class="nc bnc" id="L480" title="All 2 branches missed.">            if (!electionAddr.equals(qs.electionAddr)) {</span>
<span class="nc" id="L481">                return false;</span>
            }
<span class="nc" id="L483">            return checkAddressesEqual(clientAddr, qs.clientAddr);</span>
        }

        public void checkAddressDuplicate(QuorumServer s) throws BadArgumentsException {
<span class="nc" id="L487">            List&lt;InetSocketAddress&gt; otherAddrs = new ArrayList&lt;&gt;(s.addr.getAllAddresses());</span>
<span class="nc" id="L488">            otherAddrs.add(s.clientAddr);</span>
<span class="nc" id="L489">            otherAddrs.addAll(s.electionAddr.getAllAddresses());</span>
<span class="nc" id="L490">            otherAddrs = excludedSpecialAddresses(otherAddrs);</span>

<span class="nc bnc" id="L492" title="All 2 branches missed.">            for (InetSocketAddress my : this.myAddrs) {</span>

<span class="nc bnc" id="L494" title="All 2 branches missed.">                for (InetSocketAddress other : otherAddrs) {</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">                    if (my.equals(other)) {</span>
<span class="nc" id="L496">                        String error = String.format(&quot;%s of server.%d conflicts %s of server.%d&quot;, my, this.id, other, s.id);</span>
<span class="nc" id="L497">                        throw new BadArgumentsException(error);</span>
                    }
<span class="nc" id="L499">                }</span>
<span class="nc" id="L500">            }</span>
<span class="nc" id="L501">        }</span>

        private List&lt;InetSocketAddress&gt; excludedSpecialAddresses(List&lt;InetSocketAddress&gt; addrs) {
<span class="nc" id="L504">            List&lt;InetSocketAddress&gt; included = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L506" title="All 2 branches missed.">            for (InetSocketAddress addr : addrs) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                if (addr == null) {</span>
<span class="nc" id="L508">                    continue;</span>
                }
<span class="nc" id="L510">                InetAddress inetaddr = addr.getAddress();</span>

<span class="nc bnc" id="L512" title="All 4 branches missed.">                if (inetaddr == null || inetaddr.isAnyLocalAddress() // wildCard addresses (0.0.0.0 or [::])</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                    || inetaddr.isLoopbackAddress()) { // loopback address(localhost/127.0.0.1)</span>
<span class="nc" id="L514">                    continue;</span>
                }
<span class="nc" id="L516">                included.add(addr);</span>
<span class="nc" id="L517">            }</span>
<span class="nc" id="L518">            return included;</span>
        }

    }

<span class="nc" id="L523">    public enum ServerState {</span>
<span class="nc" id="L524">        LOOKING,</span>
<span class="nc" id="L525">        FOLLOWING,</span>
<span class="nc" id="L526">        LEADING,</span>
<span class="nc" id="L527">        OBSERVING</span>
    }

    /**
     * (Used for monitoring) shows the current phase of
     * Zab protocol that peer is running.
     */
<span class="nc" id="L534">    public enum ZabState {</span>
<span class="nc" id="L535">        ELECTION,</span>
<span class="nc" id="L536">        DISCOVERY,</span>
<span class="nc" id="L537">        SYNCHRONIZATION,</span>
<span class="nc" id="L538">        BROADCAST</span>
    }

    /**
     * (Used for monitoring) When peer is in synchronization phase, this shows
     * which synchronization mechanism is being used
     */
<span class="nc" id="L545">    public enum SyncMode {</span>
<span class="nc" id="L546">        NONE,</span>
<span class="nc" id="L547">        DIFF,</span>
<span class="nc" id="L548">        SNAP,</span>
<span class="nc" id="L549">        TRUNC</span>
    }

    /*
     * A peer can either be participating, which implies that it is willing to
     * both vote in instances of consensus and to elect or become a Leader, or
     * it may be observing in which case it isn't.
     *
     * We need this distinction to decide which ServerState to move to when
     * conditions change (e.g. which state to become after LOOKING).
     */
<span class="nc" id="L560">    public enum LearnerType {</span>
<span class="nc" id="L561">        PARTICIPANT,</span>
<span class="nc" id="L562">        OBSERVER</span>
    }

    /*
     * To enable observers to have no identifier, we need a generic identifier
     * at least for QuorumCnxManager. We use the following constant to as the
     * value of such a generic identifier.
     */

    static final long OBSERVER_ID = Long.MAX_VALUE;

    /*
     * Record leader election time
     */
    public long start_fle, end_fle; // fle = fast leader election
    public static final String FLE_TIME_UNIT = &quot;MS&quot;;
    private long unavailableStartTime;

    /*
     * Default value of peer is participant
     */
<span class="nc" id="L583">    private LearnerType learnerType = LearnerType.PARTICIPANT;</span>

    public LearnerType getLearnerType() {
<span class="nc" id="L586">        return learnerType;</span>
    }

    /**
     * Sets the LearnerType
     */
    public void setLearnerType(LearnerType p) {
<span class="nc" id="L593">        learnerType = p;</span>
<span class="nc" id="L594">    }</span>

    protected synchronized void setConfigFileName(String s) {
<span class="nc" id="L597">        configFilename = s;</span>
<span class="nc" id="L598">    }</span>

<span class="nc" id="L600">    private String configFilename = null;</span>

    public int getQuorumSize() {
<span class="nc" id="L603">        return getVotingView().size();</span>
    }

    public void setJvmPauseMonitor(JvmPauseMonitor jvmPauseMonitor) {
<span class="nc" id="L607">        this.jvmPauseMonitor = jvmPauseMonitor;</span>
<span class="nc" id="L608">    }</span>

    /**
     * QuorumVerifier implementation; default (majority).
     */

    //last committed quorum verifier
    private QuorumVerifier quorumVerifier;

    //last proposed quorum verifier
<span class="nc" id="L618">    private QuorumVerifier lastSeenQuorumVerifier = null;</span>

    // Lock object that guard access to quorumVerifier and lastSeenQuorumVerifier.
<span class="nc" id="L621">    final Object QV_LOCK = new Object();</span>

    /**
     * My id
     */
    private long myid;

    /**
     * get the id of this quorum peer.
     */
    public long getId() {
<span class="nc" id="L632">        return myid;</span>
    }

    // VisibleForTesting
    void setId(long id) {
<span class="nc" id="L637">        this.myid = id;</span>
<span class="nc" id="L638">    }</span>

    private boolean sslQuorum;
    private boolean shouldUsePortUnification;

    public boolean isSslQuorum() {
<span class="nc" id="L644">        return sslQuorum;</span>
    }

    public boolean shouldUsePortUnification() {
<span class="nc" id="L648">        return shouldUsePortUnification;</span>
    }

    private final QuorumX509Util x509Util;

    QuorumX509Util getX509Util() {
<span class="nc" id="L654">        return x509Util;</span>
    }

    /**
     * This is who I think the leader currently is.
     */
    private volatile Vote currentVote;

    public synchronized Vote getCurrentVote() {
<span class="nc" id="L663">        return currentVote;</span>
    }

    public synchronized void setCurrentVote(Vote v) {
<span class="nc" id="L667">        currentVote = v;</span>
<span class="nc" id="L668">    }</span>

<span class="nc" id="L670">    private volatile boolean running = true;</span>

    private String initialConfig;

    /**
     * The number of milliseconds of each tick
     */
    protected int tickTime;

    /**
     * Whether learners in this quorum should create new sessions as local.
     * False by default to preserve existing behavior.
     */
<span class="nc" id="L683">    protected boolean localSessionsEnabled = false;</span>

    /**
     * Whether learners in this quorum should upgrade local sessions to
     * global. Only matters if local sessions are enabled.
     */
<span class="nc" id="L689">    protected boolean localSessionsUpgradingEnabled = true;</span>

    /**
     * Minimum number of milliseconds to allow for session timeout.
     * A value of -1 indicates unset, use default.
     */
<span class="nc" id="L695">    protected int minSessionTimeout = -1;</span>

    /**
     * Maximum number of milliseconds to allow for session timeout.
     * A value of -1 indicates unset, use default.
     */
<span class="nc" id="L701">    protected int maxSessionTimeout = -1;</span>

    /**
     * The ZooKeeper server's socket backlog length. The number of connections
     * that will be queued to be read before new connections are dropped. A
     * value of one indicates the default backlog will be used.
     */
<span class="nc" id="L708">    protected int clientPortListenBacklog = -1;</span>

    /**
     * The number of ticks that the initial synchronization phase can take
     */
    protected volatile int initLimit;

    /**
     * The number of ticks that can pass between sending a request and getting
     * an acknowledgment
     */
    protected volatile int syncLimit;

    /**
     * The number of ticks that can pass before retrying to connect to learner master
     */
    protected volatile int connectToLearnerMasterLimit;

    /**
     * Enables/Disables sync request processor. This option is enabled
     * by default and is to be used with observers.
     */
<span class="nc" id="L730">    protected boolean syncEnabled = true;</span>

    /**
     * The current tick
     */
<span class="nc" id="L735">    protected AtomicInteger tick = new AtomicInteger();</span>

    /**
     * Whether or not to listen on all IPs for the two quorum ports
     * (broadcast and fast leader election).
     */
<span class="nc" id="L741">    protected boolean quorumListenOnAllIPs = false;</span>

    /**
     * Keeps time taken for leader election in milliseconds. Sets the value to
     * this variable only after the completion of leader election.
     */
<span class="nc" id="L747">    private long electionTimeTaken = -1;</span>

    /**
     * Enable/Disables quorum authentication using sasl. Defaulting to false.
     */
    protected boolean quorumSaslEnableAuth;

    /**
     * If this is false, quorum peer server will accept another quorum peer client
     * connection even if the authentication did not succeed. This can be used while
     * upgrading ZooKeeper server. Defaulting to false (required).
     */
    protected boolean quorumServerSaslAuthRequired;

    /**
     * If this is false, quorum peer learner will talk to quorum peer server
     * without authentication. This can be used while upgrading ZooKeeper
     * server. Defaulting to false (required).
     */
    protected boolean quorumLearnerSaslAuthRequired;

    /**
     * Kerberos quorum service principal. Defaulting to 'zkquorum/localhost'.
     */
    protected String quorumServicePrincipal;

    /**
     * Quorum learner login context name in jaas-conf file to read the kerberos
     * security details. Defaulting to 'QuorumLearner'.
     */
    protected String quorumLearnerLoginContext;

    /**
     * Quorum server login context name in jaas-conf file to read the kerberos
     * security details. Defaulting to 'QuorumServer'.
     */
    protected String quorumServerLoginContext;

    // TODO: need to tune the default value of thread size
    private static final int QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE = 20;
    /**
     * The maximum number of threads to allow in the connectionExecutors thread
     * pool which will be used to initiate quorum server connections.
     */
<span class="nc" id="L791">    protected int quorumCnxnThreadsSize = QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE;</span>

    public static final String QUORUM_CNXN_TIMEOUT_MS = &quot;zookeeper.quorumCnxnTimeoutMs&quot;;
    private static int quorumCnxnTimeoutMs;

    static {
<span class="nc" id="L797">        quorumCnxnTimeoutMs = Integer.getInteger(QUORUM_CNXN_TIMEOUT_MS, -1);</span>
<span class="nc" id="L798">        LOG.info(&quot;{}={}&quot;, QUORUM_CNXN_TIMEOUT_MS, quorumCnxnTimeoutMs);</span>
<span class="nc" id="L799">    }</span>

    /**
     * @deprecated As of release 3.4.0, this class has been deprecated, since
     * it is used with one of the udp-based versions of leader election, which
     * we are also deprecating.
     *
     * This class simply responds to requests for the current leader of this
     * node.
     * &lt;p&gt;
     * The request contains just an xid generated by the requestor.
     * &lt;p&gt;
     * The response has the xid, the id of this server, the id of the leader,
     * and the zxid of the leader.
     *
     *
     */
    @Deprecated
    class ResponderThread extends ZooKeeperThread {

<span class="nc" id="L819">        ResponderThread() {</span>
<span class="nc" id="L820">            super(&quot;ResponderThread&quot;);</span>
<span class="nc" id="L821">        }</span>

<span class="nc" id="L823">        volatile boolean running = true;</span>

        @Override
        public void run() {
            try {
<span class="nc" id="L828">                byte[] b = new byte[36];</span>
<span class="nc" id="L829">                ByteBuffer responseBuffer = ByteBuffer.wrap(b);</span>
<span class="nc" id="L830">                DatagramPacket packet = new DatagramPacket(b, b.length);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">                while (running) {</span>
<span class="nc" id="L832">                    udpSocket.receive(packet);</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">                    if (packet.getLength() != 4) {</span>
<span class="nc" id="L834">                        LOG.warn(&quot;Got more than just an xid! Len = {}&quot;, packet.getLength());</span>
                    } else {
<span class="nc" id="L836">                        responseBuffer.clear();</span>
<span class="nc" id="L837">                        responseBuffer.getInt(); // Skip the xid</span>
<span class="nc" id="L838">                        responseBuffer.putLong(myid);</span>
<span class="nc" id="L839">                        Vote current = getCurrentVote();</span>
<span class="nc bnc" id="L840" title="All 4 branches missed.">                        switch (getPeerState()) {</span>
                        case LOOKING:
<span class="nc" id="L842">                            responseBuffer.putLong(current.getId());</span>
<span class="nc" id="L843">                            responseBuffer.putLong(current.getZxid());</span>
<span class="nc" id="L844">                            break;</span>
                        case LEADING:
<span class="nc" id="L846">                            responseBuffer.putLong(myid);</span>
                            try {
                                long proposed;
<span class="nc" id="L849">                                synchronized (leader) {</span>
<span class="nc" id="L850">                                    proposed = leader.lastProposed;</span>
<span class="nc" id="L851">                                }</span>
<span class="nc" id="L852">                                responseBuffer.putLong(proposed);</span>
<span class="nc" id="L853">                            } catch (NullPointerException npe) {</span>
                                // This can happen in state transitions,
                                // just ignore the request
<span class="nc" id="L856">                            }</span>
<span class="nc" id="L857">                            break;</span>
                        case FOLLOWING:
<span class="nc" id="L859">                            responseBuffer.putLong(current.getId());</span>
                            try {
<span class="nc" id="L861">                                responseBuffer.putLong(follower.getZxid());</span>
<span class="nc" id="L862">                            } catch (NullPointerException npe) {</span>
                                // This can happen in state transitions,
                                // just ignore the request
<span class="nc" id="L865">                            }</span>
<span class="nc" id="L866">                            break;</span>
                        case OBSERVING:
                            // Do nothing, Observers keep themselves to
                            // themselves.
                            break;
                        }
<span class="nc" id="L872">                        packet.setData(b);</span>
<span class="nc" id="L873">                        udpSocket.send(packet);</span>
                    }
<span class="nc" id="L875">                    packet.setLength(b.length);</span>
                }
<span class="nc" id="L877">            } catch (RuntimeException e) {</span>
<span class="nc" id="L878">                LOG.warn(&quot;Unexpected runtime exception in ResponderThread&quot;, e);</span>
<span class="nc" id="L879">            } catch (IOException e) {</span>
<span class="nc" id="L880">                LOG.warn(&quot;Unexpected IO exception in ResponderThread&quot;, e);</span>
            } finally {
<span class="nc" id="L882">                LOG.warn(&quot;QuorumPeer responder thread exited&quot;);</span>
            }
<span class="nc" id="L884">        }</span>

    }

<span class="nc" id="L888">    private ServerState state = ServerState.LOOKING;</span>

<span class="nc" id="L890">    private AtomicReference&lt;ZabState&gt; zabState = new AtomicReference&lt;&gt;(ZabState.ELECTION);</span>
<span class="nc" id="L891">    private AtomicReference&lt;SyncMode&gt; syncMode = new AtomicReference&lt;&gt;(SyncMode.NONE);</span>
<span class="nc" id="L892">    private AtomicReference&lt;String&gt; leaderAddress = new AtomicReference&lt;String&gt;(&quot;&quot;);</span>
<span class="nc" id="L893">    private AtomicLong leaderId = new AtomicLong(-1);</span>

<span class="nc" id="L895">    private boolean reconfigFlag = false; // indicates that a reconfig just committed</span>

    public synchronized void setPeerState(ServerState newState) {
<span class="nc" id="L898">        state = newState;</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (newState == ServerState.LOOKING) {</span>
<span class="nc" id="L900">            setLeaderAddressAndId(null, -1);</span>
<span class="nc" id="L901">            setZabState(ZabState.ELECTION);</span>
        } else {
<span class="nc" id="L903">            LOG.info(&quot;Peer state changed: {}&quot;, getDetailedPeerState());</span>
        }
<span class="nc" id="L905">    }</span>

    public void setZabState(ZabState zabState) {
<span class="nc bnc" id="L908" title="All 4 branches missed.">        if ((zabState == ZabState.BROADCAST) &amp;&amp; (unavailableStartTime != 0)) {</span>
<span class="nc" id="L909">            long unavailableTime = Time.currentElapsedTime() - unavailableStartTime;</span>
<span class="nc" id="L910">            ServerMetrics.getMetrics().UNAVAILABLE_TIME.add(unavailableTime);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">            if (getPeerState() == ServerState.LEADING) {</span>
<span class="nc" id="L912">                ServerMetrics.getMetrics().LEADER_UNAVAILABLE_TIME.add(unavailableTime);</span>
            }
<span class="nc" id="L914">            unavailableStartTime = 0;</span>
        }
<span class="nc" id="L916">        this.zabState.set(zabState);</span>
<span class="nc" id="L917">        LOG.info(&quot;Peer state changed: {}&quot;, getDetailedPeerState());</span>
<span class="nc" id="L918">    }</span>

    public void setSyncMode(SyncMode syncMode) {
<span class="nc" id="L921">        this.syncMode.set(syncMode);</span>
<span class="nc" id="L922">        LOG.info(&quot;Peer state changed: {}&quot;, getDetailedPeerState());</span>
<span class="nc" id="L923">    }</span>

    public ZabState getZabState() {
<span class="nc" id="L926">        return zabState.get();</span>
    }

    public SyncMode getSyncMode() {
<span class="nc" id="L930">        return syncMode.get();</span>
    }

    public void setLeaderAddressAndId(MultipleAddresses addr, long newId) {
<span class="nc bnc" id="L934" title="All 2 branches missed.">        if (addr != null) {</span>
<span class="nc" id="L935">            leaderAddress.set(String.join(&quot;|&quot;, addr.getAllHostStrings()));</span>
        } else {
<span class="nc" id="L937">            leaderAddress.set(null);</span>
        }
<span class="nc" id="L939">        leaderId.set(newId);</span>
<span class="nc" id="L940">    }</span>

    public String getLeaderAddress() {
<span class="nc" id="L943">        return leaderAddress.get();</span>
    }

    public long getLeaderId() {
<span class="nc" id="L947">        return leaderId.get();</span>
    }

    public String getDetailedPeerState() {
<span class="nc" id="L951">        final StringBuilder sb = new StringBuilder(getPeerState().toString().toLowerCase());</span>
<span class="nc" id="L952">        final ZabState zabState = getZabState();</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (!ZabState.ELECTION.equals(zabState)) {</span>
<span class="nc" id="L954">            sb.append(&quot; - &quot;).append(zabState.toString().toLowerCase());</span>
        }
<span class="nc" id="L956">        final SyncMode syncMode = getSyncMode();</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">        if (!SyncMode.NONE.equals(syncMode)) {</span>
<span class="nc" id="L958">            sb.append(&quot; - &quot;).append(syncMode.toString().toLowerCase());</span>
        }
<span class="nc" id="L960">        return sb.toString();</span>
    }

    public synchronized void reconfigFlagSet() {
<span class="nc" id="L964">        reconfigFlag = true;</span>
<span class="nc" id="L965">    }</span>
    public synchronized void reconfigFlagClear() {
<span class="nc" id="L967">        reconfigFlag = false;</span>
<span class="nc" id="L968">    }</span>
    public synchronized boolean isReconfigStateChange() {
<span class="nc" id="L970">        return reconfigFlag;</span>
    }
    public synchronized ServerState getPeerState() {
<span class="nc" id="L973">        return state;</span>
    }

    DatagramSocket udpSocket;

<span class="nc" id="L978">    private final AtomicReference&lt;AddressTuple&gt; myAddrs = new AtomicReference&lt;&gt;();</span>

    /**
     * Resolves hostname for a given server ID.
     *
     * This method resolves hostname for a given server ID in both quorumVerifer
     * and lastSeenQuorumVerifier. If the server ID matches the local server ID,
     * it also updates myAddrs.
     */
    public void recreateSocketAddresses(long id) {
<span class="nc" id="L988">        QuorumVerifier qv = getQuorumVerifier();</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">        if (qv != null) {</span>
<span class="nc" id="L990">            QuorumServer qs = qv.getAllMembers().get(id);</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">            if (qs != null) {</span>
<span class="nc" id="L992">                qs.recreateSocketAddresses();</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">                if (id == getId()) {</span>
<span class="nc" id="L994">                    setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);</span>
                }
            }
        }
<span class="nc" id="L998">        qv = getLastSeenQuorumVerifier();</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">        if (qv != null) {</span>
<span class="nc" id="L1000">            QuorumServer qs = qv.getAllMembers().get(id);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            if (qs != null) {</span>
<span class="nc" id="L1002">                qs.recreateSocketAddresses();</span>
            }
        }
<span class="nc" id="L1005">    }</span>

    private AddressTuple getAddrs() {
<span class="nc" id="L1008">        AddressTuple addrs = myAddrs.get();</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        if (addrs != null) {</span>
<span class="nc" id="L1010">            return addrs;</span>
        }
        try {
<span class="nc" id="L1013">            synchronized (QV_LOCK) {</span>
<span class="nc" id="L1014">                addrs = myAddrs.get();</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">                while (addrs == null) {</span>
<span class="nc" id="L1016">                    QV_LOCK.wait();</span>
<span class="nc" id="L1017">                    addrs = myAddrs.get();</span>
                }
<span class="nc" id="L1019">                return addrs;</span>
            }
<span class="nc" id="L1021">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1022">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L1023">            throw new RuntimeException(e);</span>
        }
    }

    public MultipleAddresses getQuorumAddress() {
<span class="nc" id="L1028">        return getAddrs().quorumAddr;</span>
    }

    public MultipleAddresses getElectionAddress() {
<span class="nc" id="L1032">        return getAddrs().electionAddr;</span>
    }

    public InetSocketAddress getClientAddress() {
<span class="nc" id="L1036">        final AddressTuple addrs = myAddrs.get();</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        return (addrs == null) ? null : addrs.clientAddr;</span>
    }

    private void setAddrs(MultipleAddresses quorumAddr, MultipleAddresses electionAddr, InetSocketAddress clientAddr) {
<span class="nc" id="L1041">        synchronized (QV_LOCK) {</span>
<span class="nc" id="L1042">            myAddrs.set(new AddressTuple(quorumAddr, electionAddr, clientAddr));</span>
<span class="nc" id="L1043">            QV_LOCK.notifyAll();</span>
<span class="nc" id="L1044">        }</span>
<span class="nc" id="L1045">    }</span>

    private int electionType;

    Election electionAlg;

    ServerCnxnFactory cnxnFactory;
    ServerCnxnFactory secureCnxnFactory;

<span class="nc" id="L1054">    private FileTxnSnapLog logFactory = null;</span>

    private final QuorumStats quorumStats;

    AdminServer adminServer;

    private final boolean reconfigEnabled;

    public static QuorumPeer testingQuorumPeer() throws SaslException {
<span class="nc" id="L1063">        return new QuorumPeer();</span>
    }

    public QuorumPeer() throws SaslException {
<span class="nc" id="L1067">        super(&quot;QuorumPeer&quot;);</span>
<span class="nc" id="L1068">        quorumStats = new QuorumStats(this);</span>
<span class="nc" id="L1069">        jmxRemotePeerBean = new HashMap&lt;Long, RemotePeerBean&gt;();</span>
<span class="nc" id="L1070">        adminServer = AdminServerFactory.createAdminServer();</span>
<span class="nc" id="L1071">        x509Util = createX509Util();</span>
<span class="nc" id="L1072">        initialize();</span>
<span class="nc" id="L1073">        reconfigEnabled = QuorumPeerConfig.isReconfigEnabled();</span>
<span class="nc" id="L1074">    }</span>

    // VisibleForTesting
    QuorumX509Util createX509Util() {
<span class="nc" id="L1078">        return new QuorumX509Util();</span>
    }

    /**
     * For backward compatibility purposes, we instantiate QuorumMaj by default.
     */

    public QuorumPeer(Map&lt;Long, QuorumServer&gt; quorumPeers, File dataDir, File dataLogDir, int electionType, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, ServerCnxnFactory cnxnFactory) throws IOException {
<span class="nc" id="L1086">        this(quorumPeers, dataDir, dataLogDir, electionType, myid, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, false, cnxnFactory, new QuorumMaj(quorumPeers));</span>
<span class="nc" id="L1087">    }</span>

    public QuorumPeer(Map&lt;Long, QuorumServer&gt; quorumPeers, File dataDir, File dataLogDir, int electionType, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, boolean quorumListenOnAllIPs, ServerCnxnFactory cnxnFactory, QuorumVerifier quorumConfig) throws IOException {
<span class="nc" id="L1090">        this();</span>
<span class="nc" id="L1091">        this.cnxnFactory = cnxnFactory;</span>
<span class="nc" id="L1092">        this.electionType = electionType;</span>
<span class="nc" id="L1093">        this.myid = myid;</span>
<span class="nc" id="L1094">        this.tickTime = tickTime;</span>
<span class="nc" id="L1095">        this.initLimit = initLimit;</span>
<span class="nc" id="L1096">        this.syncLimit = syncLimit;</span>
<span class="nc" id="L1097">        this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;</span>
<span class="nc" id="L1098">        this.quorumListenOnAllIPs = quorumListenOnAllIPs;</span>
<span class="nc" id="L1099">        this.logFactory = new FileTxnSnapLog(dataLogDir, dataDir);</span>
<span class="nc" id="L1100">        this.zkDb = new ZKDatabase(this.logFactory);</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (quorumConfig == null) {</span>
<span class="nc" id="L1102">            quorumConfig = new QuorumMaj(quorumPeers);</span>
        }
<span class="nc" id="L1104">        setQuorumVerifier(quorumConfig, false);</span>
<span class="nc" id="L1105">        adminServer = AdminServerFactory.createAdminServer();</span>
<span class="nc" id="L1106">    }</span>

    public void initialize() throws SaslException {
        // init quorum auth server &amp; learner
<span class="nc bnc" id="L1110" title="All 2 branches missed.">        if (isQuorumSaslAuthEnabled()) {</span>
<span class="nc" id="L1111">            Set&lt;String&gt; authzHosts = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">            for (QuorumServer qs : getView().values()) {</span>
<span class="nc" id="L1113">                authzHosts.add(qs.hostname);</span>
<span class="nc" id="L1114">            }</span>
<span class="nc" id="L1115">            authServer = new SaslQuorumAuthServer(isQuorumServerSaslAuthRequired(), quorumServerLoginContext, authzHosts);</span>
<span class="nc" id="L1116">            authLearner = new SaslQuorumAuthLearner(isQuorumLearnerSaslAuthRequired(), quorumServicePrincipal, quorumLearnerLoginContext);</span>
<span class="nc" id="L1117">        } else {</span>
<span class="nc" id="L1118">            authServer = new NullQuorumAuthServer();</span>
<span class="nc" id="L1119">            authLearner = new NullQuorumAuthLearner();</span>
        }
<span class="nc" id="L1121">    }</span>

    QuorumStats quorumStats() {
<span class="nc" id="L1124">        return quorumStats;</span>
    }

    @Override
    public synchronized void start() {
<span class="nc bnc" id="L1129" title="All 2 branches missed.">        if (!getView().containsKey(myid)) {</span>
<span class="nc" id="L1130">            throw new RuntimeException(&quot;My id &quot; + myid + &quot; not in the peer list&quot;);</span>
        }
<span class="nc" id="L1132">        loadDataBase();</span>
<span class="nc" id="L1133">        startServerCnxnFactory();</span>
        try {
<span class="nc" id="L1135">            adminServer.start();</span>
<span class="nc" id="L1136">        } catch (AdminServerException e) {</span>
<span class="nc" id="L1137">            LOG.warn(&quot;Problem starting AdminServer&quot;, e);</span>
<span class="nc" id="L1138">        }</span>
<span class="nc" id="L1139">        startLeaderElection();</span>
<span class="nc" id="L1140">        startJvmPauseMonitor();</span>
<span class="nc" id="L1141">        super.start();</span>
<span class="nc" id="L1142">    }</span>

    private void loadDataBase() {
        try {
<span class="nc" id="L1146">            zkDb.loadDataBase();</span>

            // load the epochs
<span class="nc" id="L1149">            long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;</span>
<span class="nc" id="L1150">            long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);</span>
            try {
<span class="nc" id="L1152">                currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);</span>
<span class="nc" id="L1153">            } catch (FileNotFoundException e) {</span>
                // pick a reasonable epoch number
                // this should only happen once when moving to a
                // new code version
<span class="nc" id="L1157">                currentEpoch = epochOfZxid;</span>
<span class="nc" id="L1158">                LOG.info(</span>
                    &quot;{} not found! Creating with a reasonable default of {}. &quot;
                        + &quot;This should only happen when you are upgrading your installation&quot;,
                    CURRENT_EPOCH_FILENAME,
<span class="nc" id="L1162">                    currentEpoch);</span>
<span class="nc" id="L1163">                writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);</span>
<span class="nc" id="L1164">            }</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">            if (epochOfZxid &gt; currentEpoch) {</span>
                // acceptedEpoch.tmp file in snapshot directory
<span class="nc" id="L1167">                File currentTmp = new File(getTxnFactory().getSnapDir(),</span>
                    CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);
<span class="nc bnc" id="L1169" title="All 2 branches missed.">                if (currentTmp.exists()) {</span>
<span class="nc" id="L1170">                    long epochOfTmp = readLongFromFile(currentTmp.getName());</span>
<span class="nc" id="L1171">                    LOG.info(&quot;{} found. Setting current epoch to {}.&quot;, currentTmp, epochOfTmp);</span>
<span class="nc" id="L1172">                    setCurrentEpoch(epochOfTmp);</span>
<span class="nc" id="L1173">                } else {</span>
<span class="nc" id="L1174">                    throw new IOException(</span>
<span class="nc" id="L1175">                        &quot;The current epoch, &quot; + ZxidUtils.zxidToString(currentEpoch)</span>
                            + &quot;, is older than the last zxid, &quot; + lastProcessedZxid);
                }
            }
            try {
<span class="nc" id="L1180">                acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);</span>
<span class="nc" id="L1181">            } catch (FileNotFoundException e) {</span>
                // pick a reasonable epoch number
                // this should only happen once when moving to a
                // new code version
<span class="nc" id="L1185">                acceptedEpoch = epochOfZxid;</span>
<span class="nc" id="L1186">                LOG.info(</span>
                    &quot;{} not found! Creating with a reasonable default of {}. &quot;
                        + &quot;This should only happen when you are upgrading your installation&quot;,
                    ACCEPTED_EPOCH_FILENAME,
<span class="nc" id="L1190">                    acceptedEpoch);</span>
<span class="nc" id="L1191">                writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);</span>
<span class="nc" id="L1192">            }</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            if (acceptedEpoch &lt; currentEpoch) {</span>
<span class="nc" id="L1194">                throw new IOException(&quot;The accepted epoch, &quot;</span>
<span class="nc" id="L1195">                                      + ZxidUtils.zxidToString(acceptedEpoch)</span>
                                      + &quot; is less than the current epoch, &quot;
<span class="nc" id="L1197">                                      + ZxidUtils.zxidToString(currentEpoch));</span>
            }
<span class="nc" id="L1199">        } catch (IOException ie) {</span>
<span class="nc" id="L1200">            LOG.error(&quot;Unable to load database on disk&quot;, ie);</span>
<span class="nc" id="L1201">            throw new RuntimeException(&quot;Unable to run quorum server &quot;, ie);</span>
<span class="nc" id="L1202">        }</span>
<span class="nc" id="L1203">    }</span>

    ResponderThread responder;

    public synchronized void stopLeaderElection() {
<span class="nc" id="L1208">        responder.running = false;</span>
<span class="nc" id="L1209">        responder.interrupt();</span>
<span class="nc" id="L1210">    }</span>
    public synchronized void startLeaderElection() {
        try {
<span class="nc bnc" id="L1213" title="All 2 branches missed.">            if (getPeerState() == ServerState.LOOKING) {</span>
<span class="nc" id="L1214">                currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span>
            }
<span class="nc" id="L1216">        } catch (IOException e) {</span>
<span class="nc" id="L1217">            RuntimeException re = new RuntimeException(e.getMessage());</span>
<span class="nc" id="L1218">            re.setStackTrace(e.getStackTrace());</span>
<span class="nc" id="L1219">            throw re;</span>
<span class="nc" id="L1220">        }</span>

<span class="nc" id="L1222">        this.electionAlg = createElectionAlgorithm(electionType);</span>
<span class="nc" id="L1223">    }</span>

    private void startJvmPauseMonitor() {
<span class="nc bnc" id="L1226" title="All 2 branches missed.">        if (this.jvmPauseMonitor != null) {</span>
<span class="nc" id="L1227">            this.jvmPauseMonitor.serviceStart();</span>
        }
<span class="nc" id="L1229">    }</span>

    /**
     * Count the number of nodes in the map that could be followers.
     * @param peers
     * @return The number of followers in the map
     */
    protected static int countParticipants(Map&lt;Long, QuorumServer&gt; peers) {
<span class="nc" id="L1237">        int count = 0;</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">        for (QuorumServer q : peers.values()) {</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">            if (q.type == LearnerType.PARTICIPANT) {</span>
<span class="nc" id="L1240">                count++;</span>
            }
<span class="nc" id="L1242">        }</span>
<span class="nc" id="L1243">        return count;</span>
    }

    /**
     * This constructor is only used by the existing unit test code.
     * It defaults to FileLogProvider persistence provider.
     */
    public QuorumPeer(Map&lt;Long, QuorumServer&gt; quorumPeers, File snapDir, File logDir, int clientPort, int electionAlg, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit) throws IOException {
<span class="nc" id="L1251">        this(</span>
            quorumPeers,
            snapDir,
            logDir,
            electionAlg,
            myid,
            tickTime,
            initLimit,
            syncLimit,
            connectToLearnerMasterLimit,
            false,
<span class="nc" id="L1262">            ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),</span>
            new QuorumMaj(quorumPeers));
<span class="nc" id="L1264">    }</span>

    public QuorumPeer(Map&lt;Long, QuorumServer&gt; quorumPeers, File snapDir, File logDir, int clientPort, int electionAlg, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, String oraclePath) throws IOException {
<span class="nc" id="L1267">        this(</span>
                quorumPeers,
                snapDir,
                logDir,
                electionAlg,
                myid,
                tickTime,
                initLimit,
                syncLimit,
                connectToLearnerMasterLimit,
                false,
<span class="nc" id="L1278">                ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),</span>
                new QuorumOracleMaj(quorumPeers, oraclePath));
<span class="nc" id="L1280">    }</span>

    /**
     * This constructor is only used by the existing unit test code.
     * It defaults to FileLogProvider persistence provider.
     */
    public QuorumPeer(Map&lt;Long, QuorumServer&gt; quorumPeers, File snapDir, File logDir, int clientPort, int electionAlg, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, QuorumVerifier quorumConfig) throws IOException {
<span class="nc" id="L1287">        this(</span>
            quorumPeers,
            snapDir,
            logDir,
            electionAlg,
            myid,
            tickTime,
            initLimit,
            syncLimit,
            connectToLearnerMasterLimit,
            false,
<span class="nc" id="L1298">            ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),</span>
            quorumConfig);
<span class="nc" id="L1300">    }</span>

    private static InetSocketAddress getClientAddress(Map&lt;Long, QuorumServer&gt; quorumPeers, long myid, int clientPort) throws IOException {
<span class="nc" id="L1303">        QuorumServer quorumServer = quorumPeers.get(myid);</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        if (null == quorumServer) {</span>
<span class="nc" id="L1305">            throw new IOException(&quot;No QuorumServer correspoding to myid &quot; + myid);</span>
        }
<span class="nc bnc" id="L1307" title="All 2 branches missed.">        if (null == quorumServer.clientAddr) {</span>
<span class="nc" id="L1308">            return new InetSocketAddress(clientPort);</span>
        }
<span class="nc bnc" id="L1310" title="All 2 branches missed.">        if (quorumServer.clientAddr.getPort() != clientPort) {</span>
<span class="nc" id="L1311">            throw new IOException(&quot;QuorumServer port &quot;</span>
<span class="nc" id="L1312">                                  + quorumServer.clientAddr.getPort()</span>
                                  + &quot; does not match with given port &quot;
                                  + clientPort);
        }
<span class="nc" id="L1316">        return quorumServer.clientAddr;</span>
    }

    /**
     * returns the highest zxid that this host has seen
     *
     * @return the highest zxid for this host
     */
    public long getLastLoggedZxid() {
<span class="nc bnc" id="L1325" title="All 2 branches missed.">        if (!zkDb.isInitialized()) {</span>
<span class="nc" id="L1326">            loadDataBase();</span>
        }
<span class="nc" id="L1328">        return zkDb.getDataTreeLastProcessedZxid();</span>
    }

    public Follower follower;
    public Leader leader;
    public Observer observer;

    protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {
<span class="nc" id="L1336">        return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.zkDb));</span>
    }

    protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception {
<span class="nc" id="L1340">        return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.zkDb));</span>
    }

    protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException {
<span class="nc" id="L1344">        return new Observer(this, new ObserverZooKeeperServer(logFactory, this, this.zkDb));</span>
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    protected Election createElectionAlgorithm(int electionAlgorithm) {
<span class="nc" id="L1349">        Election le = null;</span>

        //TODO: use a factory rather than a switch
<span class="nc bnc" id="L1352" title="All 4 branches missed.">        switch (electionAlgorithm) {</span>
        case 1:
<span class="nc" id="L1354">            throw new UnsupportedOperationException(&quot;Election Algorithm 1 is not supported.&quot;);</span>
        case 2:
<span class="nc" id="L1356">            throw new UnsupportedOperationException(&quot;Election Algorithm 2 is not supported.&quot;);</span>
        case 3:
<span class="nc" id="L1358">            QuorumCnxManager qcm = createCnxnManager();</span>
<span class="nc" id="L1359">            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">            if (oldQcm != null) {</span>
<span class="nc" id="L1361">                LOG.warn(&quot;Clobbering already-set QuorumCnxManager (restarting leader election?)&quot;);</span>
<span class="nc" id="L1362">                oldQcm.halt();</span>
            }
<span class="nc" id="L1364">            QuorumCnxManager.Listener listener = qcm.listener;</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">            if (listener != null) {</span>
<span class="nc" id="L1366">                listener.start();</span>
<span class="nc" id="L1367">                FastLeaderElection fle = new FastLeaderElection(this, qcm);</span>
<span class="nc" id="L1368">                fle.start();</span>
<span class="nc" id="L1369">                le = fle;</span>
<span class="nc" id="L1370">            } else {</span>
<span class="nc" id="L1371">                LOG.error(&quot;Null listener when initializing cnx manager&quot;);</span>
            }
<span class="nc" id="L1373">            break;</span>
        default:
<span class="nc bnc" id="L1375" title="All 2 branches missed.">            assert false;</span>
        }
<span class="nc" id="L1377">        return le;</span>
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    protected Election makeLEStrategy() {
<span class="nc" id="L1382">        LOG.debug(&quot;Initializing leader election protocol...&quot;);</span>
<span class="nc" id="L1383">        return electionAlg;</span>
    }

    protected synchronized void setLeader(Leader newLeader) {
<span class="nc" id="L1387">        leader = newLeader;</span>
<span class="nc" id="L1388">    }</span>

    protected synchronized void setFollower(Follower newFollower) {
<span class="nc" id="L1391">        follower = newFollower;</span>
<span class="nc" id="L1392">    }</span>

    protected synchronized void setObserver(Observer newObserver) {
<span class="nc" id="L1395">        observer = newObserver;</span>
<span class="nc" id="L1396">    }</span>

    public synchronized ZooKeeperServer getActiveServer() {
<span class="nc bnc" id="L1399" title="All 2 branches missed.">        if (leader != null) {</span>
<span class="nc" id="L1400">            return leader.zk;</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">        } else if (follower != null) {</span>
<span class="nc" id="L1402">            return follower.zk;</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">        } else if (observer != null) {</span>
<span class="nc" id="L1404">            return observer.zk;</span>
        }
<span class="nc" id="L1406">        return null;</span>
    }

<span class="nc" id="L1409">    boolean shuttingDownLE = false;</span>

    @Override
    public void run() {
<span class="nc" id="L1413">        updateThreadName();</span>

<span class="nc" id="L1415">        LOG.debug(&quot;Starting quorum peer&quot;);</span>
        try {
<span class="nc" id="L1417">            jmxQuorumBean = new QuorumBean(this);</span>
<span class="nc" id="L1418">            MBeanRegistry.getInstance().register(jmxQuorumBean, null);</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">            for (QuorumServer s : getView().values()) {</span>
                ZKMBeanInfo p;
<span class="nc bnc" id="L1421" title="All 2 branches missed.">                if (getId() == s.id) {</span>
<span class="nc" id="L1422">                    p = jmxLocalPeerBean = new LocalPeerBean(this);</span>
                    try {
<span class="nc" id="L1424">                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);</span>
<span class="nc" id="L1425">                    } catch (Exception e) {</span>
<span class="nc" id="L1426">                        LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="nc" id="L1427">                        jmxLocalPeerBean = null;</span>
<span class="nc" id="L1428">                    }</span>
                } else {
<span class="nc" id="L1430">                    RemotePeerBean rBean = new RemotePeerBean(this, s);</span>
                    try {
<span class="nc" id="L1432">                        MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);</span>
<span class="nc" id="L1433">                        jmxRemotePeerBean.put(s.id, rBean);</span>
<span class="nc" id="L1434">                    } catch (Exception e) {</span>
<span class="nc" id="L1435">                        LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="nc" id="L1436">                    }</span>
                }
<span class="nc" id="L1438">            }</span>
<span class="nc" id="L1439">        } catch (Exception e) {</span>
<span class="nc" id="L1440">            LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="nc" id="L1441">            jmxQuorumBean = null;</span>
<span class="nc" id="L1442">        }</span>

        try {
            /*
             * Main loop
             */
<span class="nc bnc" id="L1448" title="All 2 branches missed.">            while (running) {</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">                if (unavailableStartTime == 0) {</span>
<span class="nc" id="L1450">                    unavailableStartTime = Time.currentElapsedTime();</span>
                }

<span class="nc bnc" id="L1453" title="All 5 branches missed.">                switch (getPeerState()) {</span>
                case LOOKING:
<span class="nc" id="L1455">                    LOG.info(&quot;LOOKING&quot;);</span>
<span class="nc" id="L1456">                    ServerMetrics.getMetrics().LOOKING_COUNT.add(1);</span>

<span class="nc bnc" id="L1458" title="All 2 branches missed.">                    if (Boolean.getBoolean(&quot;readonlymode.enabled&quot;)) {</span>
<span class="nc" id="L1459">                        LOG.info(&quot;Attempting to start ReadOnlyZooKeeperServer&quot;);</span>

                        // Create read-only server but don't start it immediately
<span class="nc" id="L1462">                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);</span>

                        // Instead of starting roZk immediately, wait some grace
                        // period before we decide we're partitioned.
                        //
                        // Thread is used here because otherwise it would require
                        // changes in each of election strategy classes which is
                        // unnecessary code coupling.
<span class="nc" id="L1470">                        Thread roZkMgr = new Thread() {</span>
                            public void run() {
                                try {
                                    // lower-bound grace period to 2 secs
<span class="nc" id="L1474">                                    sleep(Math.max(2000, tickTime));</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">                                    if (ServerState.LOOKING.equals(getPeerState())) {</span>
<span class="nc" id="L1476">                                        roZk.startup();</span>
                                    }
<span class="nc" id="L1478">                                } catch (InterruptedException e) {</span>
<span class="nc" id="L1479">                                    LOG.info(&quot;Interrupted while attempting to start ReadOnlyZooKeeperServer, not started&quot;);</span>
<span class="nc" id="L1480">                                } catch (Exception e) {</span>
<span class="nc" id="L1481">                                    LOG.error(&quot;FAILED to start ReadOnlyZooKeeperServer&quot;, e);</span>
<span class="nc" id="L1482">                                }</span>
<span class="nc" id="L1483">                            }</span>
                        };
                        try {
<span class="nc" id="L1486">                            roZkMgr.start();</span>
<span class="nc" id="L1487">                            reconfigFlagClear();</span>
<span class="nc bnc" id="L1488" title="All 2 branches missed.">                            if (shuttingDownLE) {</span>
<span class="nc" id="L1489">                                shuttingDownLE = false;</span>
<span class="nc" id="L1490">                                startLeaderElection();</span>
                            }
<span class="nc" id="L1492">                            setCurrentVote(makeLEStrategy().lookForLeader());</span>
<span class="nc" id="L1493">                        } catch (Exception e) {</span>
<span class="nc" id="L1494">                            LOG.warn(&quot;Unexpected exception&quot;, e);</span>
<span class="nc" id="L1495">                            setPeerState(ServerState.LOOKING);</span>
                        } finally {
                            // If the thread is in the the grace period, interrupt
                            // to come out of waiting.
<span class="nc" id="L1499">                            roZkMgr.interrupt();</span>
<span class="nc" id="L1500">                            roZk.shutdown();</span>
                        }
<span class="nc" id="L1502">                    } else {</span>
                        try {
<span class="nc" id="L1504">                            reconfigFlagClear();</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">                            if (shuttingDownLE) {</span>
<span class="nc" id="L1506">                                shuttingDownLE = false;</span>
<span class="nc" id="L1507">                                startLeaderElection();</span>
                            }
<span class="nc" id="L1509">                            setCurrentVote(makeLEStrategy().lookForLeader());</span>
<span class="nc" id="L1510">                        } catch (Exception e) {</span>
<span class="nc" id="L1511">                            LOG.warn(&quot;Unexpected exception&quot;, e);</span>
<span class="nc" id="L1512">                            setPeerState(ServerState.LOOKING);</span>
<span class="nc" id="L1513">                        }</span>
                    }
<span class="nc" id="L1515">                    break;</span>
                case OBSERVING:
                    try {
<span class="nc" id="L1518">                        LOG.info(&quot;OBSERVING&quot;);</span>
<span class="nc" id="L1519">                        setObserver(makeObserver(logFactory));</span>
<span class="nc" id="L1520">                        observer.observeLeader();</span>
<span class="nc" id="L1521">                    } catch (Exception e) {</span>
<span class="nc" id="L1522">                        LOG.warn(&quot;Unexpected exception&quot;, e);</span>
                    } finally {
<span class="nc" id="L1524">                        observer.shutdown();</span>
<span class="nc" id="L1525">                        setObserver(null);</span>
<span class="nc" id="L1526">                        updateServerState();</span>

                        // Add delay jitter before we switch to LOOKING
                        // state to reduce the load of ObserverMaster
<span class="nc bnc" id="L1530" title="All 2 branches missed.">                        if (isRunning()) {</span>
<span class="nc" id="L1531">                            Observer.waitForObserverElectionDelay();</span>
                        }
                    }
<span class="nc" id="L1534">                    break;</span>
                case FOLLOWING:
                    try {
<span class="nc" id="L1537">                        LOG.info(&quot;FOLLOWING&quot;);</span>
<span class="nc" id="L1538">                        setFollower(makeFollower(logFactory));</span>
<span class="nc" id="L1539">                        follower.followLeader();</span>
<span class="nc" id="L1540">                    } catch (Exception e) {</span>
<span class="nc" id="L1541">                        LOG.warn(&quot;Unexpected exception&quot;, e);</span>
                    } finally {
<span class="nc" id="L1543">                        follower.shutdown();</span>
<span class="nc" id="L1544">                        setFollower(null);</span>
<span class="nc" id="L1545">                        updateServerState();</span>
                    }
<span class="nc" id="L1547">                    break;</span>
                case LEADING:
<span class="nc" id="L1549">                    LOG.info(&quot;LEADING&quot;);</span>
                    try {
<span class="nc" id="L1551">                        setLeader(makeLeader(logFactory));</span>
<span class="nc" id="L1552">                        leader.lead();</span>
<span class="nc" id="L1553">                        setLeader(null);</span>
<span class="nc" id="L1554">                    } catch (Exception e) {</span>
<span class="nc" id="L1555">                        LOG.warn(&quot;Unexpected exception&quot;, e);</span>
                    } finally {
<span class="nc bnc" id="L1557" title="All 2 branches missed.">                        if (leader != null) {</span>
<span class="nc" id="L1558">                            leader.shutdown(&quot;Forcing shutdown&quot;);</span>
<span class="nc" id="L1559">                            setLeader(null);</span>
                        }
<span class="nc" id="L1561">                        updateServerState();</span>
                    }
<span class="nc" id="L1563">                    break;</span>
                }
            }
        } finally {
<span class="nc" id="L1567">            LOG.warn(&quot;QuorumPeer main thread exited&quot;);</span>
<span class="nc" id="L1568">            MBeanRegistry instance = MBeanRegistry.getInstance();</span>
<span class="nc" id="L1569">            instance.unregister(jmxQuorumBean);</span>
<span class="nc" id="L1570">            instance.unregister(jmxLocalPeerBean);</span>

<span class="nc bnc" id="L1572" title="All 2 branches missed.">            for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {</span>
<span class="nc" id="L1573">                instance.unregister(remotePeerBean);</span>
<span class="nc" id="L1574">            }</span>

<span class="nc" id="L1576">            jmxQuorumBean = null;</span>
<span class="nc" id="L1577">            jmxLocalPeerBean = null;</span>
<span class="nc" id="L1578">            jmxRemotePeerBean = null;</span>
        }
<span class="nc" id="L1580">    }</span>

    private synchronized void updateServerState() {
<span class="nc bnc" id="L1583" title="All 2 branches missed.">        if (!reconfigFlag) {</span>
<span class="nc" id="L1584">            setPeerState(ServerState.LOOKING);</span>
<span class="nc" id="L1585">            LOG.warn(&quot;PeerState set to LOOKING&quot;);</span>
<span class="nc" id="L1586">            return;</span>
        }

<span class="nc bnc" id="L1589" title="All 2 branches missed.">        if (getId() == getCurrentVote().getId()) {</span>
<span class="nc" id="L1590">            setPeerState(ServerState.LEADING);</span>
<span class="nc" id="L1591">            LOG.debug(&quot;PeerState set to LEADING&quot;);</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">        } else if (getLearnerType() == LearnerType.PARTICIPANT) {</span>
<span class="nc" id="L1593">            setPeerState(ServerState.FOLLOWING);</span>
<span class="nc" id="L1594">            LOG.debug(&quot;PeerState set to FOLLOWING&quot;);</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">        } else if (getLearnerType() == LearnerType.OBSERVER) {</span>
<span class="nc" id="L1596">            setPeerState(ServerState.OBSERVING);</span>
<span class="nc" id="L1597">            LOG.debug(&quot;PeerState set to OBSERVER&quot;);</span>
        } else { // currently shouldn't happen since there are only 2 learner types
<span class="nc" id="L1599">            setPeerState(ServerState.LOOKING);</span>
<span class="nc" id="L1600">            LOG.debug(&quot;Should not be here&quot;);</span>
        }
<span class="nc" id="L1602">        reconfigFlag = false;</span>
<span class="nc" id="L1603">    }</span>

    public void shutdown() {
<span class="nc" id="L1606">        running = false;</span>
<span class="nc" id="L1607">        x509Util.close();</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">        if (leader != null) {</span>
<span class="nc" id="L1609">            leader.shutdown(&quot;quorum Peer shutdown&quot;);</span>
        }
<span class="nc bnc" id="L1611" title="All 2 branches missed.">        if (follower != null) {</span>
<span class="nc" id="L1612">            follower.shutdown();</span>
        }
<span class="nc" id="L1614">        shutdownServerCnxnFactory();</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">        if (udpSocket != null) {</span>
<span class="nc" id="L1616">            udpSocket.close();</span>
        }
<span class="nc bnc" id="L1618" title="All 2 branches missed.">        if (jvmPauseMonitor != null) {</span>
<span class="nc" id="L1619">            jvmPauseMonitor.serviceStop();</span>
        }

        try {
<span class="nc" id="L1623">            adminServer.shutdown();</span>
<span class="nc" id="L1624">        } catch (AdminServerException e) {</span>
<span class="nc" id="L1625">            LOG.warn(&quot;Problem stopping AdminServer&quot;, e);</span>
<span class="nc" id="L1626">        }</span>

<span class="nc bnc" id="L1628" title="All 2 branches missed.">        if (getElectionAlg() != null) {</span>
<span class="nc" id="L1629">            this.interrupt();</span>
<span class="nc" id="L1630">            getElectionAlg().shutdown();</span>
        }
        try {
<span class="nc" id="L1633">            zkDb.close();</span>
<span class="nc" id="L1634">        } catch (IOException ie) {</span>
<span class="nc" id="L1635">            LOG.warn(&quot;Error closing logs &quot;, ie);</span>
<span class="nc" id="L1636">        }</span>
<span class="nc" id="L1637">    }</span>

    /**
     * A 'view' is a node's current opinion of the membership of the entire
     * ensemble.
     */
    public Map&lt;Long, QuorumPeer.QuorumServer&gt; getView() {
<span class="nc" id="L1644">        return Collections.unmodifiableMap(getQuorumVerifier().getAllMembers());</span>
    }

    /**
     * Observers are not contained in this view, only nodes with
     * PeerType=PARTICIPANT.
     */
    public Map&lt;Long, QuorumPeer.QuorumServer&gt; getVotingView() {
<span class="nc" id="L1652">        return getQuorumVerifier().getVotingMembers();</span>
    }

    /**
     * Returns only observers, no followers.
     */
    public Map&lt;Long, QuorumPeer.QuorumServer&gt; getObservingView() {
<span class="nc" id="L1659">        return getQuorumVerifier().getObservingMembers();</span>
    }

    public synchronized Set&lt;Long&gt; getCurrentAndNextConfigVoters() {
<span class="nc" id="L1663">        Set&lt;Long&gt; voterIds = new HashSet&lt;Long&gt;(getQuorumVerifier().getVotingMembers().keySet());</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">        if (getLastSeenQuorumVerifier() != null) {</span>
<span class="nc" id="L1665">            voterIds.addAll(getLastSeenQuorumVerifier().getVotingMembers().keySet());</span>
        }
<span class="nc" id="L1667">        return voterIds;</span>
    }

    /**
     * Check if a node is in the current view. With static membership, the
     * result of this check will never change; only when dynamic membership
     * is introduced will this be more useful.
     */
    public boolean viewContains(Long sid) {
<span class="nc" id="L1676">        return this.getView().containsKey(sid);</span>
    }

    /**
     * Only used by QuorumStats at the moment
     */
    public String[] getQuorumPeers() {
<span class="nc" id="L1683">        List&lt;String&gt; l = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1684">        synchronized (this) {</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">            if (leader != null) {</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">                for (LearnerHandler fh : leader.getLearners()) {</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">                    if (fh.getSocket() != null) {</span>
<span class="nc" id="L1688">                        String s = formatInetAddr((InetSocketAddress) fh.getSocket().getRemoteSocketAddress());</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">                        if (leader.isLearnerSynced(fh)) {</span>
<span class="nc" id="L1690">                            s += &quot;*&quot;;</span>
                        }
<span class="nc" id="L1692">                        l.add(s);</span>
                    }
<span class="nc" id="L1694">                }</span>
<span class="nc bnc" id="L1695" title="All 2 branches missed.">            } else if (follower != null) {</span>
<span class="nc" id="L1696">                l.add(formatInetAddr((InetSocketAddress) follower.sock.getRemoteSocketAddress()));</span>
            }
<span class="nc" id="L1698">        }</span>
<span class="nc" id="L1699">        return l.toArray(new String[0]);</span>
    }

    public String getServerState() {
<span class="nc bnc" id="L1703" title="All 5 branches missed.">        switch (getPeerState()) {</span>
        case LOOKING:
<span class="nc" id="L1705">            return QuorumStats.Provider.LOOKING_STATE;</span>
        case LEADING:
<span class="nc" id="L1707">            return QuorumStats.Provider.LEADING_STATE;</span>
        case FOLLOWING:
<span class="nc" id="L1709">            return QuorumStats.Provider.FOLLOWING_STATE;</span>
        case OBSERVING:
<span class="nc" id="L1711">            return QuorumStats.Provider.OBSERVING_STATE;</span>
        }
<span class="nc" id="L1713">        return QuorumStats.Provider.UNKNOWN_STATE;</span>
    }

    /**
     * set the id of this quorum peer.
     */
    public void setMyid(long myid) {
<span class="nc" id="L1720">        this.myid = myid;</span>
<span class="nc" id="L1721">    }</span>

    public void setInitialConfig(String initialConfig) {
<span class="nc" id="L1724">        this.initialConfig = initialConfig;</span>
<span class="nc" id="L1725">    }</span>

    public String getInitialConfig() {
<span class="nc" id="L1728">        return initialConfig;</span>
    }

    /**
     * Get the number of milliseconds of each tick
     */
    public int getTickTime() {
<span class="nc" id="L1735">        return tickTime;</span>
    }

    /**
     * Set the number of milliseconds of each tick
     */
    public void setTickTime(int tickTime) {
<span class="nc" id="L1742">        LOG.info(&quot;tickTime set to {}&quot;, tickTime);</span>
<span class="nc" id="L1743">        this.tickTime = tickTime;</span>
<span class="nc" id="L1744">    }</span>

    /** Maximum number of connections allowed from particular host (ip) */
    public int getMaxClientCnxnsPerHost() {
<span class="nc bnc" id="L1748" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L1749">            return cnxnFactory.getMaxClientCnxnsPerHost();</span>
        }
<span class="nc bnc" id="L1751" title="All 2 branches missed.">        if (secureCnxnFactory != null) {</span>
<span class="nc" id="L1752">            return secureCnxnFactory.getMaxClientCnxnsPerHost();</span>
        }
<span class="nc" id="L1754">        return -1;</span>
    }

    /** Whether local sessions are enabled */
    public boolean areLocalSessionsEnabled() {
<span class="nc" id="L1759">        return localSessionsEnabled;</span>
    }

    /** Whether to enable local sessions */
    public void enableLocalSessions(boolean flag) {
<span class="nc bnc" id="L1764" title="All 2 branches missed.">        LOG.info(&quot;Local sessions {}&quot;, (flag ? &quot;enabled&quot; : &quot;disabled&quot;));</span>
<span class="nc" id="L1765">        localSessionsEnabled = flag;</span>
<span class="nc" id="L1766">    }</span>

    /** Whether local sessions are allowed to upgrade to global sessions */
    public boolean isLocalSessionsUpgradingEnabled() {
<span class="nc" id="L1770">        return localSessionsUpgradingEnabled;</span>
    }

    /** Whether to allow local sessions to upgrade to global sessions */
    public void enableLocalSessionsUpgrading(boolean flag) {
<span class="nc bnc" id="L1775" title="All 2 branches missed.">        LOG.info(&quot;Local session upgrading {}&quot;, (flag ? &quot;enabled&quot; : &quot;disabled&quot;));</span>
<span class="nc" id="L1776">        localSessionsUpgradingEnabled = flag;</span>
<span class="nc" id="L1777">    }</span>

    /** minimum session timeout in milliseconds */
    public int getMinSessionTimeout() {
<span class="nc" id="L1781">        return minSessionTimeout;</span>
    }

    /** minimum session timeout in milliseconds */
    public void setMinSessionTimeout(int min) {
<span class="nc" id="L1786">        LOG.info(&quot;minSessionTimeout set to {}&quot;, min);</span>
<span class="nc" id="L1787">        this.minSessionTimeout = min;</span>
<span class="nc" id="L1788">    }</span>

    /** maximum session timeout in milliseconds */
    public int getMaxSessionTimeout() {
<span class="nc" id="L1792">        return maxSessionTimeout;</span>
    }

    /** maximum session timeout in milliseconds */
    public void setMaxSessionTimeout(int max) {
<span class="nc" id="L1797">        LOG.info(&quot;maxSessionTimeout set to {}&quot;, max);</span>
<span class="nc" id="L1798">        this.maxSessionTimeout = max;</span>
<span class="nc" id="L1799">    }</span>

    /** The server socket's listen backlog length */
    public int getClientPortListenBacklog() {
<span class="nc" id="L1803">        return this.clientPortListenBacklog;</span>
    }

    /** Sets the server socket's listen backlog length. */
    public void setClientPortListenBacklog(int backlog) {
<span class="nc" id="L1808">        this.clientPortListenBacklog = backlog;</span>
<span class="nc" id="L1809">    }</span>

    /**
     * Get the number of ticks that the initial synchronization phase can take
     */
    public int getInitLimit() {
<span class="nc" id="L1815">        return initLimit;</span>
    }

    /**
     * Set the number of ticks that the initial synchronization phase can take
     */
    public void setInitLimit(int initLimit) {
<span class="nc" id="L1822">        LOG.info(&quot;initLimit set to {}&quot;, initLimit);</span>
<span class="nc" id="L1823">        this.initLimit = initLimit;</span>
<span class="nc" id="L1824">    }</span>

    /**
     * Get the current tick
     */
    public int getTick() {
<span class="nc" id="L1830">        return tick.get();</span>
    }

    public QuorumVerifier configFromString(String s) throws IOException, ConfigException {
<span class="nc" id="L1834">        Properties props = new Properties();</span>
<span class="nc" id="L1835">        props.load(new StringReader(s));</span>
<span class="nc" id="L1836">        return QuorumPeerConfig.parseDynamicConfig(props, electionType, false, false, getQuorumVerifier().getOraclePath());</span>
    }

    /**
     * Return QuorumVerifier object for the last committed configuration.
     */
    public QuorumVerifier getQuorumVerifier() {
<span class="nc" id="L1843">        synchronized (QV_LOCK) {</span>
<span class="nc" id="L1844">            return quorumVerifier;</span>
        }
    }

    /**
     * Return QuorumVerifier object for the last proposed configuration.
     */
    public QuorumVerifier getLastSeenQuorumVerifier() {
<span class="nc" id="L1852">        synchronized (QV_LOCK) {</span>
<span class="nc" id="L1853">            return lastSeenQuorumVerifier;</span>
        }
    }

    public synchronized void restartLeaderElection(QuorumVerifier qvOLD, QuorumVerifier qvNEW) {
<span class="nc bnc" id="L1858" title="All 4 branches missed.">        if (qvOLD == null || !qvOLD.equals(qvNEW)) {</span>
<span class="nc" id="L1859">            LOG.warn(&quot;Restarting Leader Election&quot;);</span>
<span class="nc" id="L1860">            getElectionAlg().shutdown();</span>
<span class="nc" id="L1861">            shuttingDownLE = false;</span>
<span class="nc" id="L1862">            startLeaderElection();</span>
        }
<span class="nc" id="L1864">    }</span>

    public String getNextDynamicConfigFilename() {
<span class="nc bnc" id="L1867" title="All 2 branches missed.">        if (configFilename == null) {</span>
<span class="nc" id="L1868">            LOG.warn(&quot;configFilename is null! This should only happen in tests.&quot;);</span>
<span class="nc" id="L1869">            return null;</span>
        }
<span class="nc" id="L1871">        return configFilename + QuorumPeerConfig.nextDynamicConfigFileSuffix;</span>
    }

    // On entry to this method, qcm must be non-null and the locks on both qcm and QV_LOCK
    // must be held.  We don't want quorumVerifier/lastSeenQuorumVerifier to change out from
    // under us, so we have to hold QV_LOCK; and since the call to qcm.connectOne() will take
    // the lock on qcm (and take QV_LOCK again inside that), the caller needs to have taken
    // qcm outside QV_LOCK to avoid a deadlock against other callers of qcm.connectOne().
    private void connectNewPeers(QuorumCnxManager qcm) {
<span class="nc bnc" id="L1880" title="All 4 branches missed.">        if (quorumVerifier != null &amp;&amp; lastSeenQuorumVerifier != null) {</span>
<span class="nc" id="L1881">            Map&lt;Long, QuorumServer&gt; committedView = quorumVerifier.getAllMembers();</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">            for (Entry&lt;Long, QuorumServer&gt; e : lastSeenQuorumVerifier.getAllMembers().entrySet()) {</span>
<span class="nc bnc" id="L1883" title="All 4 branches missed.">                if (e.getKey() != getId() &amp;&amp; !committedView.containsKey(e.getKey())) {</span>
<span class="nc" id="L1884">                    qcm.connectOne(e.getKey());</span>
                }
<span class="nc" id="L1886">            }</span>
        }
<span class="nc" id="L1888">    }</span>

    public void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk) {
<span class="nc bnc" id="L1891" title="All 2 branches missed.">        if (!isReconfigEnabled()) {</span>
<span class="nc" id="L1892">            LOG.info(&quot;Dynamic reconfig is disabled, we don't store the last seen config.&quot;);</span>
<span class="nc" id="L1893">            return;</span>
        }

        // If qcm is non-null, we may call qcm.connectOne(), which will take the lock on qcm
        // and then take QV_LOCK.  Take the locks in the same order to ensure that we don't
        // deadlock against other callers of connectOne().  If qcmRef gets set in another
        // thread while we're inside the synchronized block, that does no harm; if we didn't
        // take a lock on qcm (because it was null when we sampled it), we won't call
        // connectOne() on it.  (Use of an AtomicReference is enough to guarantee visibility
        // of updates that provably happen in another thread before entering this method.)
<span class="nc" id="L1903">        QuorumCnxManager qcm = qcmRef.get();</span>
<span class="nc bnc" id="L1904" title="All 2 branches missed.">        Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;</span>
<span class="nc" id="L1905">        synchronized (outerLockObject) {</span>
<span class="nc" id="L1906">            synchronized (QV_LOCK) {</span>
<span class="nc bnc" id="L1907" title="All 4 branches missed.">                if (lastSeenQuorumVerifier != null &amp;&amp; lastSeenQuorumVerifier.getVersion() &gt; qv.getVersion()) {</span>
<span class="nc" id="L1908">                    LOG.error(&quot;setLastSeenQuorumVerifier called with stale config &quot;</span>
<span class="nc" id="L1909">                              + qv.getVersion()</span>
                              + &quot;. Current version: &quot;
<span class="nc" id="L1911">                              + quorumVerifier.getVersion());</span>
                }
                // assuming that a version uniquely identifies a configuration, so if
                // version is the same, nothing to do here.
<span class="nc bnc" id="L1915" title="All 4 branches missed.">                if (lastSeenQuorumVerifier != null &amp;&amp; lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {</span>
<span class="nc" id="L1916">                    return;</span>
                }
<span class="nc" id="L1918">                lastSeenQuorumVerifier = qv;</span>
<span class="nc bnc" id="L1919" title="All 2 branches missed.">                if (qcm != null) {</span>
<span class="nc" id="L1920">                    connectNewPeers(qcm);</span>
                }

<span class="nc bnc" id="L1923" title="All 2 branches missed.">                if (writeToDisk) {</span>
                    try {
<span class="nc" id="L1925">                        String fileName = getNextDynamicConfigFilename();</span>
<span class="nc bnc" id="L1926" title="All 2 branches missed.">                        if (fileName != null) {</span>
<span class="nc" id="L1927">                            QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);</span>
                        }
<span class="nc" id="L1929">                    } catch (IOException e) {</span>
<span class="nc" id="L1930">                        LOG.error(&quot;Error writing next dynamic config file to disk&quot;, e);</span>
<span class="nc" id="L1931">                    }</span>
                }
<span class="nc" id="L1933">            }</span>
<span class="nc" id="L1934">        }</span>
<span class="nc" id="L1935">    }</span>

    public QuorumVerifier setQuorumVerifier(QuorumVerifier qv, boolean writeToDisk) {
<span class="nc" id="L1938">        synchronized (QV_LOCK) {</span>
<span class="nc bnc" id="L1939" title="All 4 branches missed.">            if ((quorumVerifier != null) &amp;&amp; (quorumVerifier.getVersion() &gt;= qv.getVersion())) {</span>
                // this is normal. For example - server found out about new config through FastLeaderElection gossiping
                // and then got the same config in UPTODATE message so its already known
<span class="nc" id="L1942">                LOG.debug(</span>
                    &quot;{} setQuorumVerifier called with known or old config {}. Current version: {}&quot;,
<span class="nc" id="L1944">                    getId(),</span>
<span class="nc" id="L1945">                    qv.getVersion(),</span>
<span class="nc" id="L1946">                    quorumVerifier.getVersion());</span>
<span class="nc" id="L1947">                return quorumVerifier;</span>
            }
<span class="nc" id="L1949">            QuorumVerifier prevQV = quorumVerifier;</span>
<span class="nc" id="L1950">            quorumVerifier = qv;</span>
<span class="nc bnc" id="L1951" title="All 4 branches missed.">            if (lastSeenQuorumVerifier == null || (qv.getVersion() &gt; lastSeenQuorumVerifier.getVersion())) {</span>
<span class="nc" id="L1952">                lastSeenQuorumVerifier = qv;</span>
            }

<span class="nc bnc" id="L1955" title="All 2 branches missed.">            if (writeToDisk) {</span>
                // some tests initialize QuorumPeer without a static config file
<span class="nc bnc" id="L1957" title="All 2 branches missed.">                if (configFilename != null) {</span>
                    try {
<span class="nc" id="L1959">                        String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());</span>
<span class="nc" id="L1960">                        QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);</span>
<span class="nc" id="L1961">                        QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());</span>
<span class="nc" id="L1962">                    } catch (IOException e) {</span>
<span class="nc" id="L1963">                        LOG.error(&quot;Error closing file&quot;, e);</span>
<span class="nc" id="L1964">                    }</span>
                } else {
<span class="nc" id="L1966">                    LOG.info(&quot;writeToDisk == true but configFilename == null&quot;);</span>
                }
            }

<span class="nc bnc" id="L1970" title="All 2 branches missed.">            if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {</span>
<span class="nc" id="L1971">                QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());</span>
            }
<span class="nc" id="L1973">            QuorumServer qs = qv.getAllMembers().get(getId());</span>
<span class="nc bnc" id="L1974" title="All 2 branches missed.">            if (qs != null) {</span>
<span class="nc" id="L1975">                setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);</span>
            }
<span class="nc" id="L1977">            updateObserverMasterList();</span>
<span class="nc" id="L1978">            return prevQV;</span>
        }
    }

    private String makeDynamicConfigFilename(long version) {
<span class="nc" id="L1983">        return configFilename + &quot;.dynamic.&quot; + Long.toHexString(version);</span>
    }

    private boolean needEraseClientInfoFromStaticConfig() {
<span class="nc" id="L1987">        QuorumServer server = quorumVerifier.getAllMembers().get(getId());</span>
<span class="nc bnc" id="L1988" title="All 6 branches missed.">        return (server != null &amp;&amp; server.clientAddr != null &amp;&amp; !server.isClientAddrFromStatic);</span>
    }

    /**
     * Get an instance of LeaderElection
     */
    public Election getElectionAlg() {
<span class="nc" id="L1995">        return electionAlg;</span>
    }

    /**
     * Get the synclimit
     */
    public int getSyncLimit() {
<span class="nc" id="L2002">        return syncLimit;</span>
    }

    /**
     * Set the synclimit
     */
    public void setSyncLimit(int syncLimit) {
<span class="nc" id="L2009">        LOG.info(&quot;syncLimit set to {}&quot;, syncLimit);</span>
<span class="nc" id="L2010">        this.syncLimit = syncLimit;</span>
<span class="nc" id="L2011">    }</span>

    /**
     * Get the connectToLearnerMasterLimit
     */
    public int getConnectToLearnerMasterLimit() {
<span class="nc" id="L2017">        return connectToLearnerMasterLimit;</span>
    }

    /**
     * Set the connectToLearnerMasterLimit
     */
    public void setConnectToLearnerMasterLimit(int connectToLearnerMasterLimit) {
<span class="nc" id="L2024">        LOG.info(&quot;connectToLearnerMasterLimit set to {}&quot;, connectToLearnerMasterLimit);</span>
<span class="nc" id="L2025">        this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;</span>
<span class="nc" id="L2026">    }</span>

    /**
     * The syncEnabled can also be set via a system property.
     */
    public static final String SYNC_ENABLED = &quot;zookeeper.observer.syncEnabled&quot;;

    /**
     * Return syncEnabled.
     */
    public boolean getSyncEnabled() {
<span class="nc bnc" id="L2037" title="All 2 branches missed.">        if (System.getProperty(SYNC_ENABLED) != null) {</span>
<span class="nc" id="L2038">            LOG.info(&quot;{}={}&quot;, SYNC_ENABLED, Boolean.getBoolean(SYNC_ENABLED));</span>
<span class="nc" id="L2039">            return Boolean.getBoolean(SYNC_ENABLED);</span>
        } else {
<span class="nc" id="L2041">            return syncEnabled;</span>
        }
    }

    /**
     * Set syncEnabled.
     *
     * @param syncEnabled
     */
    public void setSyncEnabled(boolean syncEnabled) {
<span class="nc" id="L2051">        this.syncEnabled = syncEnabled;</span>
<span class="nc" id="L2052">    }</span>

    /**
     * Gets the election type
     */
    public int getElectionType() {
<span class="nc" id="L2058">        return electionType;</span>
    }

    /**
     * Sets the election type
     */
    public void setElectionType(int electionType) {
<span class="nc" id="L2065">        this.electionType = electionType;</span>
<span class="nc" id="L2066">    }</span>

    public boolean getQuorumListenOnAllIPs() {
<span class="nc" id="L2069">        return quorumListenOnAllIPs;</span>
    }

    public void setQuorumListenOnAllIPs(boolean quorumListenOnAllIPs) {
<span class="nc" id="L2073">        this.quorumListenOnAllIPs = quorumListenOnAllIPs;</span>
<span class="nc" id="L2074">    }</span>

    public void setCnxnFactory(ServerCnxnFactory cnxnFactory) {
<span class="nc" id="L2077">        this.cnxnFactory = cnxnFactory;</span>
<span class="nc" id="L2078">    }</span>

    public void setSecureCnxnFactory(ServerCnxnFactory secureCnxnFactory) {
<span class="nc" id="L2081">        this.secureCnxnFactory = secureCnxnFactory;</span>
<span class="nc" id="L2082">    }</span>

    public void setSslQuorum(boolean sslQuorum) {
<span class="nc bnc" id="L2085" title="All 2 branches missed.">        if (sslQuorum) {</span>
<span class="nc" id="L2086">            LOG.info(&quot;Using TLS encrypted quorum communication&quot;);</span>
        } else {
<span class="nc" id="L2088">            LOG.info(&quot;Using insecure (non-TLS) quorum communication&quot;);</span>
        }
<span class="nc" id="L2090">        this.sslQuorum = sslQuorum;</span>
<span class="nc" id="L2091">    }</span>

    public void setUsePortUnification(boolean shouldUsePortUnification) {
<span class="nc bnc" id="L2094" title="All 2 branches missed.">        LOG.info(&quot;Port unification {}&quot;, shouldUsePortUnification ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="nc" id="L2095">        this.shouldUsePortUnification = shouldUsePortUnification;</span>
<span class="nc" id="L2096">    }</span>

    private void startServerCnxnFactory() {
<span class="nc bnc" id="L2099" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L2100">            cnxnFactory.start();</span>
        }
<span class="nc bnc" id="L2102" title="All 2 branches missed.">        if (secureCnxnFactory != null) {</span>
<span class="nc" id="L2103">            secureCnxnFactory.start();</span>
        }
<span class="nc" id="L2105">    }</span>

    private void shutdownServerCnxnFactory() {
<span class="nc bnc" id="L2108" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L2109">            cnxnFactory.shutdown();</span>
        }
<span class="nc bnc" id="L2111" title="All 2 branches missed.">        if (secureCnxnFactory != null) {</span>
<span class="nc" id="L2112">            secureCnxnFactory.shutdown();</span>
        }
<span class="nc" id="L2114">    }</span>

    // Leader and learner will control the zookeeper server and pass it into QuorumPeer.
    public void setZooKeeperServer(ZooKeeperServer zks) {
<span class="nc bnc" id="L2118" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L2119">            cnxnFactory.setZooKeeperServer(zks);</span>
        }
<span class="nc bnc" id="L2121" title="All 2 branches missed.">        if (secureCnxnFactory != null) {</span>
<span class="nc" id="L2122">            secureCnxnFactory.setZooKeeperServer(zks);</span>
        }
<span class="nc" id="L2124">    }</span>

    public void closeAllConnections() {
<span class="nc bnc" id="L2127" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L2128">            cnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);</span>
        }
<span class="nc bnc" id="L2130" title="All 2 branches missed.">        if (secureCnxnFactory != null) {</span>
<span class="nc" id="L2131">            secureCnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);</span>
        }
<span class="nc" id="L2133">    }</span>

    public int getClientPort() {
<span class="nc bnc" id="L2136" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L2137">            return cnxnFactory.getLocalPort();</span>
        }
<span class="nc" id="L2139">        return -1;</span>
    }

    public void setTxnFactory(FileTxnSnapLog factory) {
<span class="nc" id="L2143">        this.logFactory = factory;</span>
<span class="nc" id="L2144">    }</span>

    public FileTxnSnapLog getTxnFactory() {
<span class="nc" id="L2147">        return this.logFactory;</span>
    }

    /**
     * set zk database for this node
     * @param database
     */
    public void setZKDatabase(ZKDatabase database) {
<span class="nc" id="L2155">        this.zkDb = database;</span>
<span class="nc" id="L2156">    }</span>

    protected ZKDatabase getZkDb() {
<span class="nc" id="L2159">        return zkDb;</span>
    }

    public synchronized void initConfigInZKDatabase() {
<span class="nc bnc" id="L2163" title="All 2 branches missed.">        if (zkDb != null) {</span>
<span class="nc" id="L2164">            zkDb.initConfigInZKDatabase(getQuorumVerifier());</span>
        }
<span class="nc" id="L2166">    }</span>

    public boolean isRunning() {
<span class="nc" id="L2169">        return running;</span>
    }

    /**
     * get reference to QuorumCnxManager
     */
    public QuorumCnxManager getQuorumCnxManager() {
<span class="nc" id="L2176">        return qcmRef.get();</span>
    }
    private long readLongFromFile(String name) throws IOException {
<span class="nc" id="L2179">        File file = new File(logFactory.getSnapDir(), name);</span>
<span class="nc" id="L2180">        BufferedReader br = new BufferedReader(new FileReader(file));</span>
<span class="nc" id="L2181">        String line = &quot;&quot;;</span>
        try {
<span class="nc" id="L2183">            line = br.readLine();</span>
<span class="nc" id="L2184">            return Long.parseLong(line);</span>
<span class="nc" id="L2185">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L2186">            throw new IOException(&quot;Found &quot; + line + &quot; in &quot; + file);</span>
        } finally {
<span class="nc" id="L2188">            br.close();</span>
        }
    }

<span class="nc" id="L2192">    private long acceptedEpoch = -1;</span>
<span class="nc" id="L2193">    private long currentEpoch = -1;</span>

    public static final String CURRENT_EPOCH_FILENAME = &quot;currentEpoch&quot;;

    public static final String ACCEPTED_EPOCH_FILENAME = &quot;acceptedEpoch&quot;;

    /**
     * Write a long value to disk atomically. Either succeeds or an exception
     * is thrown.
     * @param name file name to write the long to
     * @param value the long value to write to the named file
     * @throws IOException if the file cannot be written atomically
     */
    // visibleForTest
     void writeLongToFile(String name, final long value) throws IOException {
<span class="nc" id="L2208">        File file = new File(logFactory.getSnapDir(), name);</span>
<span class="nc" id="L2209">        new AtomicFileWritingIdiom(file, new WriterStatement() {</span>
            @Override
            public void write(Writer bw) throws IOException {
<span class="nc" id="L2212">                bw.write(Long.toString(value));</span>
<span class="nc" id="L2213">            }</span>
        });
<span class="nc" id="L2215">    }</span>

    public long getCurrentEpoch() throws IOException {
<span class="nc bnc" id="L2218" title="All 2 branches missed.">        if (currentEpoch == -1) {</span>
<span class="nc" id="L2219">            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);</span>
        }
<span class="nc" id="L2221">        return currentEpoch;</span>
    }

    public long getAcceptedEpoch() throws IOException {
<span class="nc bnc" id="L2225" title="All 2 branches missed.">        if (acceptedEpoch == -1) {</span>
<span class="nc" id="L2226">            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);</span>
        }
<span class="nc" id="L2228">        return acceptedEpoch;</span>
    }

    public void setCurrentEpoch(long e) throws IOException {
<span class="nc" id="L2232">        writeLongToFile(CURRENT_EPOCH_FILENAME, e);</span>
<span class="nc" id="L2233">        currentEpoch = e;</span>

<span class="nc" id="L2235">    }</span>

    public void setAcceptedEpoch(long e) throws IOException {
<span class="nc" id="L2238">        writeLongToFile(ACCEPTED_EPOCH_FILENAME, e);</span>
<span class="nc" id="L2239">        acceptedEpoch = e;</span>
<span class="nc" id="L2240">    }</span>

    public boolean processReconfig(QuorumVerifier qv, Long suggestedLeaderId, Long zxid, boolean restartLE) {
<span class="nc bnc" id="L2243" title="All 2 branches missed.">        if (!isReconfigEnabled()) {</span>
<span class="nc" id="L2244">            LOG.debug(&quot;Reconfig feature is disabled, skip reconfig processing.&quot;);</span>
<span class="nc" id="L2245">            return false;</span>
        }

<span class="nc" id="L2248">        InetSocketAddress oldClientAddr = getClientAddress();</span>

        // update last committed quorum verifier, write the new config to disk
        // and restart leader election if config changed.
<span class="nc" id="L2252">        QuorumVerifier prevQV = setQuorumVerifier(qv, true);</span>

        // There is no log record for the initial config, thus after syncing
        // with leader
        // /zookeeper/config is empty! it is also possible that last committed
        // config is propagated during leader election
        // without the propagation the corresponding log records.
        // so we should explicitly do this (this is not necessary when we're
        // already a Follower/Observer, only
        // for Learner):
<span class="nc" id="L2262">        initConfigInZKDatabase();</span>

<span class="nc bnc" id="L2264" title="All 4 branches missed.">        if (prevQV.getVersion() &lt; qv.getVersion() &amp;&amp; !prevQV.equals(qv)) {</span>
<span class="nc" id="L2265">            Map&lt;Long, QuorumServer&gt; newMembers = qv.getAllMembers();</span>
<span class="nc" id="L2266">            updateRemotePeerMXBeans(newMembers);</span>
<span class="nc bnc" id="L2267" title="All 2 branches missed.">            if (restartLE) {</span>
<span class="nc" id="L2268">                restartLeaderElection(prevQV, qv);</span>
            }

<span class="nc" id="L2271">            QuorumServer myNewQS = newMembers.get(getId());</span>
<span class="nc bnc" id="L2272" title="All 6 branches missed.">            if (myNewQS != null &amp;&amp; myNewQS.clientAddr != null &amp;&amp; !myNewQS.clientAddr.equals(oldClientAddr)) {</span>
<span class="nc" id="L2273">                cnxnFactory.reconfigure(myNewQS.clientAddr);</span>
<span class="nc" id="L2274">                updateThreadName();</span>
            }

<span class="nc" id="L2277">            boolean roleChange = updateLearnerType(qv);</span>
<span class="nc" id="L2278">            boolean leaderChange = false;</span>
<span class="nc bnc" id="L2279" title="All 2 branches missed.">            if (suggestedLeaderId != null) {</span>
                // zxid should be non-null too
<span class="nc" id="L2281">                leaderChange = updateVote(suggestedLeaderId, zxid);</span>
            } else {
<span class="nc" id="L2283">                long currentLeaderId = getCurrentVote().getId();</span>
<span class="nc" id="L2284">                QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);</span>
<span class="nc" id="L2285">                QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);</span>
<span class="nc bnc" id="L2286" title="All 6 branches missed.">                leaderChange = (myleaderInCurQV == null</span>
                                || myleaderInCurQV.addr == null
                                || myleaderInNewQV == null
<span class="nc bnc" id="L2289" title="All 2 branches missed.">                                || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));</span>
                // we don't have a designated leader - need to go into leader
                // election
<span class="nc" id="L2292">                reconfigFlagClear();</span>
            }

<span class="nc bnc" id="L2295" title="All 4 branches missed.">            return roleChange || leaderChange;</span>
        }
<span class="nc" id="L2297">        return false;</span>

    }

    private void updateRemotePeerMXBeans(Map&lt;Long, QuorumServer&gt; newMembers) {
<span class="nc" id="L2302">        Set&lt;Long&gt; existingMembers = new HashSet&lt;Long&gt;(newMembers.keySet());</span>
<span class="nc" id="L2303">        existingMembers.retainAll(jmxRemotePeerBean.keySet());</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">        for (Long id : existingMembers) {</span>
<span class="nc" id="L2305">            RemotePeerBean rBean = jmxRemotePeerBean.get(id);</span>
<span class="nc" id="L2306">            rBean.setQuorumServer(newMembers.get(id));</span>
<span class="nc" id="L2307">        }</span>

<span class="nc" id="L2309">        Set&lt;Long&gt; joiningMembers = new HashSet&lt;Long&gt;(newMembers.keySet());</span>
<span class="nc" id="L2310">        joiningMembers.removeAll(jmxRemotePeerBean.keySet());</span>
<span class="nc" id="L2311">        joiningMembers.remove(getId()); // remove self as it is local bean</span>
<span class="nc bnc" id="L2312" title="All 2 branches missed.">        for (Long id : joiningMembers) {</span>
<span class="nc" id="L2313">            QuorumServer qs = newMembers.get(id);</span>
<span class="nc" id="L2314">            RemotePeerBean rBean = new RemotePeerBean(this, qs);</span>
            try {
<span class="nc" id="L2316">                MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);</span>
<span class="nc" id="L2317">                jmxRemotePeerBean.put(qs.id, rBean);</span>
<span class="nc" id="L2318">            } catch (Exception e) {</span>
<span class="nc" id="L2319">                LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="nc" id="L2320">            }</span>
<span class="nc" id="L2321">        }</span>

<span class="nc" id="L2323">        Set&lt;Long&gt; leavingMembers = new HashSet&lt;Long&gt;(jmxRemotePeerBean.keySet());</span>
<span class="nc" id="L2324">        leavingMembers.removeAll(newMembers.keySet());</span>
<span class="nc bnc" id="L2325" title="All 2 branches missed.">        for (Long id : leavingMembers) {</span>
<span class="nc" id="L2326">            RemotePeerBean rBean = jmxRemotePeerBean.remove(id);</span>
            try {
<span class="nc" id="L2328">                MBeanRegistry.getInstance().unregister(rBean);</span>
<span class="nc" id="L2329">            } catch (Exception e) {</span>
<span class="nc" id="L2330">                LOG.warn(&quot;Failed to unregister with JMX&quot;, e);</span>
<span class="nc" id="L2331">            }</span>
<span class="nc" id="L2332">        }</span>
<span class="nc" id="L2333">    }</span>

<span class="nc" id="L2335">    private ArrayList&lt;QuorumServer&gt; observerMasters = new ArrayList&lt;&gt;();</span>
    private void updateObserverMasterList() {
<span class="nc bnc" id="L2337" title="All 2 branches missed.">        if (observerMasterPort &lt;= 0) {</span>
<span class="nc" id="L2338">            return; // observer masters not enabled</span>
        }
<span class="nc" id="L2340">        observerMasters.clear();</span>
<span class="nc" id="L2341">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L2342" title="All 2 branches missed.">        for (QuorumServer server : quorumVerifier.getVotingMembers().values()) {</span>
<span class="nc" id="L2343">            InetAddress address = server.addr.getReachableOrOne().getAddress();</span>
<span class="nc" id="L2344">            InetSocketAddress addr = new InetSocketAddress(address, observerMasterPort);</span>
<span class="nc" id="L2345">            observerMasters.add(new QuorumServer(server.id, addr));</span>
<span class="nc" id="L2346">            sb.append(addr).append(&quot;,&quot;);</span>
<span class="nc" id="L2347">        }</span>
<span class="nc" id="L2348">        LOG.info(&quot;Updated learner master list to be {}&quot;, sb.toString());</span>
<span class="nc" id="L2349">        Collections.shuffle(observerMasters);</span>
        // Reset the internal index of the observerMaster when
        // the observerMaster List is refreshed
<span class="nc" id="L2352">        nextObserverMaster = 0;</span>
<span class="nc" id="L2353">    }</span>

    private boolean useObserverMasters() {
<span class="nc bnc" id="L2356" title="All 4 branches missed.">        return getLearnerType() == LearnerType.OBSERVER &amp;&amp; observerMasters.size() &gt; 0;</span>
    }

<span class="nc" id="L2359">    private int nextObserverMaster = 0;</span>
    private QuorumServer nextObserverMaster() {
<span class="nc bnc" id="L2361" title="All 2 branches missed.">        if (nextObserverMaster &gt;= observerMasters.size()) {</span>
<span class="nc" id="L2362">            nextObserverMaster = 0;</span>
            // Add a reconnect delay only after the observer
            // has exhausted trying to connect to all the masters
            // from the observerMasterList
<span class="nc bnc" id="L2366" title="All 2 branches missed.">            if (isRunning()) {</span>
<span class="nc" id="L2367">                Observer.waitForReconnectDelay();</span>
            }
        }
<span class="nc" id="L2370">        return observerMasters.get(nextObserverMaster++);</span>
    }

    QuorumServer findLearnerMaster(QuorumServer leader) {
<span class="nc bnc" id="L2374" title="All 2 branches missed.">        if (useObserverMasters()) {</span>
<span class="nc" id="L2375">            return nextObserverMaster();</span>
        } else {
            // Add delay jitter to reduce the load on the leader
<span class="nc bnc" id="L2378" title="All 2 branches missed.">            if (isRunning()) {</span>
<span class="nc" id="L2379">                Observer.waitForReconnectDelay();</span>
            }
<span class="nc" id="L2381">            return leader;</span>
        }
    }

    /**
     * Vet a given learner master's information.
     * Allows specification by server id, ip  only, or ip and port
     */
    QuorumServer validateLearnerMaster(String desiredMaster) {
<span class="nc bnc" id="L2390" title="All 2 branches missed.">        if (useObserverMasters()) {</span>
            Long sid;
            try {
<span class="nc" id="L2393">                sid = Long.parseLong(desiredMaster);</span>
<span class="nc" id="L2394">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L2395">                sid = null;</span>
<span class="nc" id="L2396">            }</span>
<span class="nc bnc" id="L2397" title="All 2 branches missed.">            for (QuorumServer server : observerMasters) {</span>
<span class="nc bnc" id="L2398" title="All 2 branches missed.">                if (sid == null) {</span>
<span class="nc bnc" id="L2399" title="All 2 branches missed.">                    for (InetSocketAddress address : server.addr.getAllAddresses()) {</span>
<span class="nc" id="L2400">                        String serverAddr = address.getAddress().getHostAddress() + ':' + address.getPort();</span>
<span class="nc bnc" id="L2401" title="All 2 branches missed.">                        if (serverAddr.startsWith(desiredMaster)) {</span>
<span class="nc" id="L2402">                            return server;</span>
                        }
<span class="nc" id="L2404">                    }</span>
                } else {
<span class="nc bnc" id="L2406" title="All 2 branches missed.">                    if (sid.equals(server.id)) {</span>
<span class="nc" id="L2407">                        return server;</span>
                    }
                }
<span class="nc" id="L2410">            }</span>
<span class="nc bnc" id="L2411" title="All 2 branches missed.">            if (sid == null) {</span>
<span class="nc" id="L2412">                LOG.info(&quot;could not find learner master address={}&quot;, desiredMaster);</span>
            } else {
<span class="nc" id="L2414">                LOG.warn(&quot;could not find learner master sid={}&quot;, sid);</span>
            }
<span class="nc" id="L2416">        } else {</span>
<span class="nc" id="L2417">            LOG.info(&quot;cannot validate request, observer masters not enabled&quot;);</span>
        }
<span class="nc" id="L2419">        return null;</span>
    }

    private boolean updateLearnerType(QuorumVerifier newQV) {
        //check if I'm an observer in new config
<span class="nc bnc" id="L2424" title="All 2 branches missed.">        if (newQV.getObservingMembers().containsKey(getId())) {</span>
<span class="nc bnc" id="L2425" title="All 2 branches missed.">            if (getLearnerType() != LearnerType.OBSERVER) {</span>
<span class="nc" id="L2426">                setLearnerType(LearnerType.OBSERVER);</span>
<span class="nc" id="L2427">                LOG.info(&quot;Becoming an observer&quot;);</span>
<span class="nc" id="L2428">                reconfigFlagSet();</span>
<span class="nc" id="L2429">                return true;</span>
            } else {
<span class="nc" id="L2431">                return false;</span>
            }
<span class="nc bnc" id="L2433" title="All 2 branches missed.">        } else if (newQV.getVotingMembers().containsKey(getId())) {</span>
<span class="nc bnc" id="L2434" title="All 2 branches missed.">            if (getLearnerType() != LearnerType.PARTICIPANT) {</span>
<span class="nc" id="L2435">                setLearnerType(LearnerType.PARTICIPANT);</span>
<span class="nc" id="L2436">                LOG.info(&quot;Becoming a voting participant&quot;);</span>
<span class="nc" id="L2437">                reconfigFlagSet();</span>
<span class="nc" id="L2438">                return true;</span>
            } else {
<span class="nc" id="L2440">                return false;</span>
            }
        }
        // I'm not in the view
<span class="nc bnc" id="L2444" title="All 2 branches missed.">        if (getLearnerType() != LearnerType.PARTICIPANT) {</span>
<span class="nc" id="L2445">            setLearnerType(LearnerType.PARTICIPANT);</span>
<span class="nc" id="L2446">            LOG.info(&quot;Becoming a non-voting participant&quot;);</span>
<span class="nc" id="L2447">            reconfigFlagSet();</span>
<span class="nc" id="L2448">            return true;</span>
        }
<span class="nc" id="L2450">        return false;</span>
    }

    private boolean updateVote(long designatedLeader, long zxid) {
<span class="nc" id="L2454">        Vote currentVote = getCurrentVote();</span>
<span class="nc bnc" id="L2455" title="All 4 branches missed.">        if (currentVote != null &amp;&amp; designatedLeader != currentVote.getId()) {</span>
<span class="nc" id="L2456">            setCurrentVote(new Vote(designatedLeader, zxid));</span>
<span class="nc" id="L2457">            reconfigFlagSet();</span>
<span class="nc" id="L2458">            LOG.warn(&quot;Suggested leader: {}&quot;, designatedLeader);</span>
<span class="nc" id="L2459">            return true;</span>
        }
<span class="nc" id="L2461">        return false;</span>
    }

    /**
     * Updates leader election info to avoid inconsistencies when
     * a new server tries to join the ensemble.
     *
     * Here is the inconsistency scenario we try to solve by updating the peer
     * epoch after following leader:
     *
     * Let's say we have an ensemble with 3 servers z1, z2 and z3.
     *
     * 1. z1, z2 were following z3 with peerEpoch to be 0xb8, the new epoch is
     *    0xb9, aka current accepted epoch on disk.
     * 2. z2 get restarted, which will use 0xb9 as it's peer epoch when loading
     *    the current accept epoch from disk.
     * 3. z2 received notification from z1 and z3, which is following z3 with
     *    epoch 0xb8, so it started following z3 again with peer epoch 0xb8.
     * 4. before z2 successfully connected to z3, z3 get restarted with new
     *    epoch 0xb9.
     * 5. z2 will retry around a few round (default 5s) before giving up,
     *    meanwhile it will report z3 as leader.
     * 6. z1 restarted, and looking with peer epoch 0xb9.
     * 7. z1 voted z3, and z3 was elected as leader again with peer epoch 0xb9.
     * 8. z2 successfully connected to z3 before giving up, but with peer
     *    epoch 0xb8.
     * 9. z1 get restarted, looking for leader with peer epoch 0xba, but cannot
     *    join, because z2 is reporting peer epoch 0xb8, while z3 is reporting
     *    0xb9.
     *
     * By updating the election vote after actually following leader, we can
     * avoid this kind of stuck happened.
     *
     * Btw, the zxid and electionEpoch could be inconsistent because of the same
     * reason, it's better to update these as well after syncing with leader, but
     * that required protocol change which is non trivial. This problem is worked
     * around by skipping comparing the zxid and electionEpoch when counting for
     * votes for out of election servers during looking for leader.
     *
     * See https://issues.apache.org/jira/browse/ZOOKEEPER-1732
     */
    protected void updateElectionVote(long newEpoch) {
<span class="nc" id="L2503">        Vote currentVote = getCurrentVote();</span>
<span class="nc bnc" id="L2504" title="All 2 branches missed.">        if (currentVote != null) {</span>
<span class="nc" id="L2505">            setCurrentVote(new Vote(currentVote.getId(), currentVote.getZxid(), currentVote.getElectionEpoch(), newEpoch, currentVote</span>
<span class="nc" id="L2506">                .getState()));</span>
        }
<span class="nc" id="L2508">    }</span>

    private void updateThreadName() {
<span class="nc bnc" id="L2511" title="All 2 branches missed.">        String plain = cnxnFactory != null</span>
<span class="nc bnc" id="L2512" title="All 2 branches missed.">                ? cnxnFactory.getLocalAddress() != null</span>
<span class="nc" id="L2513">                    ? formatInetAddr(cnxnFactory.getLocalAddress())</span>
<span class="nc" id="L2514">                    : &quot;disabled&quot;</span>
<span class="nc" id="L2515">                : &quot;disabled&quot;;</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">        String secure = secureCnxnFactory != null ? formatInetAddr(secureCnxnFactory.getLocalAddress()) : &quot;disabled&quot;;</span>
<span class="nc" id="L2517">        setName(String.format(&quot;QuorumPeer[myid=%d](plain=%s)(secure=%s)&quot;, getId(), plain, secure));</span>
<span class="nc" id="L2518">    }</span>

    /**
     * Sets the time taken for leader election in milliseconds.
     *
     * @param electionTimeTaken time taken for leader election
     */
    void setElectionTimeTaken(long electionTimeTaken) {
<span class="nc" id="L2526">        this.electionTimeTaken = electionTimeTaken;</span>
<span class="nc" id="L2527">    }</span>

    /**
     * @return the time taken for leader election in milliseconds.
     */
    long getElectionTimeTaken() {
<span class="nc" id="L2533">        return electionTimeTaken;</span>
    }

    void setQuorumServerSaslRequired(boolean serverSaslRequired) {
<span class="nc" id="L2537">        quorumServerSaslAuthRequired = serverSaslRequired;</span>
<span class="nc" id="L2538">        LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, serverSaslRequired);</span>
<span class="nc" id="L2539">    }</span>

    void setQuorumLearnerSaslRequired(boolean learnerSaslRequired) {
<span class="nc" id="L2542">        quorumLearnerSaslAuthRequired = learnerSaslRequired;</span>
<span class="nc" id="L2543">        LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, learnerSaslRequired);</span>
<span class="nc" id="L2544">    }</span>

    void setQuorumSaslEnabled(boolean enableAuth) {
<span class="nc" id="L2547">        quorumSaslEnableAuth = enableAuth;</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">        if (!quorumSaslEnableAuth) {</span>
<span class="nc" id="L2549">            LOG.info(&quot;QuorumPeer communication is not secured! (SASL auth disabled)&quot;);</span>
        } else {
<span class="nc" id="L2551">            LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_SASL_AUTH_ENABLED, enableAuth);</span>
        }
<span class="nc" id="L2553">    }</span>

    void setQuorumServicePrincipal(String servicePrincipal) {
<span class="nc" id="L2556">        quorumServicePrincipal = servicePrincipal;</span>
<span class="nc" id="L2557">        LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, quorumServicePrincipal);</span>
<span class="nc" id="L2558">    }</span>

    void setQuorumLearnerLoginContext(String learnerContext) {
<span class="nc" id="L2561">        quorumLearnerLoginContext = learnerContext;</span>
<span class="nc" id="L2562">        LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, quorumLearnerLoginContext);</span>
<span class="nc" id="L2563">    }</span>

    void setQuorumServerLoginContext(String serverContext) {
<span class="nc" id="L2566">        quorumServerLoginContext = serverContext;</span>
<span class="nc" id="L2567">        LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT, quorumServerLoginContext);</span>
<span class="nc" id="L2568">    }</span>

    void setQuorumCnxnThreadsSize(int qCnxnThreadsSize) {
<span class="nc bnc" id="L2571" title="All 2 branches missed.">        if (qCnxnThreadsSize &gt; QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {</span>
<span class="nc" id="L2572">            quorumCnxnThreadsSize = qCnxnThreadsSize;</span>
        }
<span class="nc" id="L2574">        LOG.info(&quot;quorum.cnxn.threads.size set to {}&quot;, quorumCnxnThreadsSize);</span>
<span class="nc" id="L2575">    }</span>

    boolean isQuorumSaslAuthEnabled() {
<span class="nc" id="L2578">        return quorumSaslEnableAuth;</span>
    }

    private boolean isQuorumServerSaslAuthRequired() {
<span class="nc" id="L2582">        return quorumServerSaslAuthRequired;</span>
    }

    private boolean isQuorumLearnerSaslAuthRequired() {
<span class="nc" id="L2586">        return quorumLearnerSaslAuthRequired;</span>
    }

    public QuorumCnxManager createCnxnManager() {
<span class="nc bnc" id="L2590" title="All 2 branches missed.">        int timeout = quorumCnxnTimeoutMs &gt; 0 ? quorumCnxnTimeoutMs : this.tickTime * this.syncLimit;</span>
<span class="nc" id="L2591">        LOG.info(&quot;Using {}ms as the quorum cnxn socket timeout&quot;, timeout);</span>
<span class="nc" id="L2592">        return new QuorumCnxManager(</span>
            this,
<span class="nc" id="L2594">            this.getId(),</span>
<span class="nc" id="L2595">            this.getView(),</span>
            this.authServer,
            this.authLearner,
            timeout,
<span class="nc" id="L2599">            this.getQuorumListenOnAllIPs(),</span>
            this.quorumCnxnThreadsSize,
<span class="nc" id="L2601">            this.isQuorumSaslAuthEnabled());</span>
    }

    boolean isLeader(long id) {
<span class="nc" id="L2605">        Vote vote = getCurrentVote();</span>
<span class="nc bnc" id="L2606" title="All 4 branches missed.">        return vote != null &amp;&amp; id == vote.getId();</span>
    }

    public boolean isReconfigEnabled() {
<span class="nc" id="L2610">        return reconfigEnabled;</span>
    }

    @InterfaceAudience.Private
    /**
     * This is a metric that depends on the status of the peer.
     */ public Integer getSynced_observers_metric() {
<span class="nc bnc" id="L2617" title="All 2 branches missed.">        if (leader != null) {</span>
<span class="nc" id="L2618">            return leader.getObservingLearners().size();</span>
<span class="nc bnc" id="L2619" title="All 2 branches missed.">        } else if (follower != null) {</span>
<span class="nc" id="L2620">            return follower.getSyncedObserverSize();</span>
        } else {
<span class="nc" id="L2622">            return null;</span>
        }
    }

    /**
     * Create a new QuorumPeer and apply all the values per the already-parsed config.
     *
     * @param config The appertained quorum peer config.
     * @return A QuorumPeer instantiated with specified peer config. Note this peer
     *         is not fully initialized; caller should finish initialization through
     *         additional configurations (connection factory settings, etc).
     *
     * @throws IOException
     */
    public static QuorumPeer createFromConfig(QuorumPeerConfig config) throws IOException {
<span class="nc" id="L2637">        QuorumPeer quorumPeer = new QuorumPeer();</span>
<span class="nc" id="L2638">        quorumPeer.setTxnFactory(new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir()));</span>
<span class="nc" id="L2639">        quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());</span>
<span class="nc" id="L2640">        quorumPeer.enableLocalSessionsUpgrading(config.isLocalSessionsUpgradingEnabled());</span>
<span class="nc" id="L2641">        quorumPeer.setElectionType(config.getElectionAlg());</span>
<span class="nc" id="L2642">        quorumPeer.setMyid(config.getServerId());</span>
<span class="nc" id="L2643">        quorumPeer.setTickTime(config.getTickTime());</span>
<span class="nc" id="L2644">        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());</span>
<span class="nc" id="L2645">        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());</span>
<span class="nc" id="L2646">        quorumPeer.setInitLimit(config.getInitLimit());</span>
<span class="nc" id="L2647">        quorumPeer.setSyncLimit(config.getSyncLimit());</span>
<span class="nc" id="L2648">        quorumPeer.setConnectToLearnerMasterLimit(config.getConnectToLearnerMasterLimit());</span>
<span class="nc" id="L2649">        quorumPeer.setObserverMasterPort(config.getObserverMasterPort());</span>
<span class="nc" id="L2650">        quorumPeer.setConfigFileName(config.getConfigFilename());</span>
<span class="nc" id="L2651">        quorumPeer.setClientPortListenBacklog(config.getClientPortListenBacklog());</span>
<span class="nc" id="L2652">        quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));</span>
<span class="nc" id="L2653">        quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">        if (config.getLastSeenQuorumVerifier() != null) {</span>
<span class="nc" id="L2655">            quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);</span>
        }
<span class="nc" id="L2657">        quorumPeer.initConfigInZKDatabase();</span>
<span class="nc" id="L2658">        quorumPeer.setSslQuorum(config.isSslQuorum());</span>
<span class="nc" id="L2659">        quorumPeer.setUsePortUnification(config.shouldUsePortUnification());</span>
<span class="nc" id="L2660">        quorumPeer.setLearnerType(config.getPeerType());</span>
<span class="nc" id="L2661">        quorumPeer.setSyncEnabled(config.getSyncEnabled());</span>
<span class="nc" id="L2662">        quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());</span>
<span class="nc bnc" id="L2663" title="All 2 branches missed.">        if (config.sslQuorumReloadCertFiles) {</span>
<span class="nc" id="L2664">            quorumPeer.getX509Util().enableCertFileReloading();</span>
        }
<span class="nc" id="L2666">        quorumPeer.setMultiAddressEnabled(config.isMultiAddressEnabled());</span>
<span class="nc" id="L2667">        quorumPeer.setMultiAddressReachabilityCheckEnabled(config.isMultiAddressReachabilityCheckEnabled());</span>
<span class="nc" id="L2668">        quorumPeer.setMultiAddressReachabilityCheckTimeoutMs(config.getMultiAddressReachabilityCheckTimeoutMs());</span>

        // sets quorum sasl authentication configurations
<span class="nc" id="L2671">        quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);</span>
<span class="nc bnc" id="L2672" title="All 2 branches missed.">        if (quorumPeer.isQuorumSaslAuthEnabled()) {</span>
<span class="nc" id="L2673">            quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);</span>
<span class="nc" id="L2674">            quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);</span>
<span class="nc" id="L2675">            quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);</span>
<span class="nc" id="L2676">            quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);</span>
<span class="nc" id="L2677">            quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);</span>
        }
<span class="nc" id="L2679">        quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);</span>

<span class="nc bnc" id="L2681" title="All 2 branches missed.">        if (config.jvmPauseMonitorToRun) {</span>
<span class="nc" id="L2682">            quorumPeer.setJvmPauseMonitor(new JvmPauseMonitor(config));</span>
        }

<span class="nc" id="L2685">        return quorumPeer;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>