<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Learner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server.quorum</a> &gt; <span class="el_source">Learner.java</span></div><h1>Learner.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server.quorum;

import static java.nio.charset.StandardCharsets.UTF_8;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import javax.net.ssl.SSLSocket;
import org.apache.jute.BinaryInputArchive;
import org.apache.jute.BinaryOutputArchive;
import org.apache.jute.InputArchive;
import org.apache.jute.OutputArchive;
import org.apache.jute.Record;
import org.apache.zookeeper.ZooDefs.OpCode;
import org.apache.zookeeper.common.Time;
import org.apache.zookeeper.common.X509Exception;
import org.apache.zookeeper.server.ExitCode;
import org.apache.zookeeper.server.Request;
import org.apache.zookeeper.server.ServerCnxn;
import org.apache.zookeeper.server.ServerMetrics;
import org.apache.zookeeper.server.TxnLogEntry;
import org.apache.zookeeper.server.ZooTrace;
import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
import org.apache.zookeeper.server.util.ConfigUtils;
import org.apache.zookeeper.server.util.MessageTracker;
import org.apache.zookeeper.server.util.SerializeUtils;
import org.apache.zookeeper.server.util.ZxidUtils;
import org.apache.zookeeper.txn.SetDataTxn;
import org.apache.zookeeper.txn.TxnDigest;
import org.apache.zookeeper.txn.TxnHeader;
import org.apache.zookeeper.util.ServiceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class is the superclass of two of the three main actors in a ZK
 * ensemble: Followers and Observers. Both Followers and Observers share
 * a good deal of code which is moved into Peer to avoid duplication.
 */
<span class="nc" id="L77">public class Learner {</span>

<span class="nc" id="L79">    static class PacketInFlight {</span>

        TxnHeader hdr;
        Record rec;
        TxnDigest digest;

    }

    QuorumPeer self;
    LearnerZooKeeperServer zk;

    protected BufferedOutputStream bufferedOutput;

    protected Socket sock;
    protected MultipleAddresses leaderAddr;
<span class="nc" id="L94">    protected AtomicBoolean sockBeingClosed = new AtomicBoolean(false);</span>

    /**
     * Socket getter
     */
    public Socket getSocket() {
<span class="nc" id="L100">        return sock;</span>
    }

<span class="nc" id="L103">    LearnerSender sender = null;</span>
    protected InputArchive leaderIs;
    protected OutputArchive leaderOs;
    /** the protocol version of the leader */
<span class="nc" id="L107">    protected int leaderProtocolVersion = 0x01;</span>

    private static final int BUFFERED_MESSAGE_SIZE = 10;
<span class="nc" id="L110">    protected final MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);</span>

<span class="nc" id="L112">    protected static final Logger LOG = LoggerFactory.getLogger(Learner.class);</span>

    /**
     * Time to wait after connection attempt with the Leader or LearnerMaster before this
     * Learner tries to connect again.
     */
<span class="nc" id="L118">    private static final int leaderConnectDelayDuringRetryMs = Integer.getInteger(&quot;zookeeper.leaderConnectDelayDuringRetryMs&quot;, 100);</span>

<span class="nc" id="L120">    private static final boolean nodelay = System.getProperty(&quot;follower.nodelay&quot;, &quot;true&quot;).equals(&quot;true&quot;);</span>

    public static final String LEARNER_ASYNC_SENDING = &quot;zookeeper.learner.asyncSending&quot;;
<span class="nc" id="L123">    private static boolean asyncSending =</span>
<span class="nc" id="L124">        Boolean.parseBoolean(ConfigUtils.getPropertyBackwardCompatibleWay(LEARNER_ASYNC_SENDING));</span>
    public static final String LEARNER_CLOSE_SOCKET_ASYNC = &quot;zookeeper.learner.closeSocketAsync&quot;;
<span class="nc" id="L126">    public static final boolean closeSocketAsync = Boolean</span>
<span class="nc" id="L127">        .parseBoolean(ConfigUtils.getPropertyBackwardCompatibleWay(LEARNER_CLOSE_SOCKET_ASYNC));</span>

    static {
<span class="nc" id="L130">        LOG.info(&quot;leaderConnectDelayDuringRetryMs: {}&quot;, leaderConnectDelayDuringRetryMs);</span>
<span class="nc" id="L131">        LOG.info(&quot;TCP NoDelay set to: {}&quot;, nodelay);</span>
<span class="nc" id="L132">        LOG.info(&quot;{} = {}&quot;, LEARNER_ASYNC_SENDING, asyncSending);</span>
<span class="nc" id="L133">        LOG.info(&quot;{} = {}&quot;, LEARNER_CLOSE_SOCKET_ASYNC, closeSocketAsync);</span>
<span class="nc" id="L134">    }</span>

<span class="nc" id="L136">    final ConcurrentHashMap&lt;Long, ServerCnxn&gt; pendingRevalidations = new ConcurrentHashMap&lt;Long, ServerCnxn&gt;();</span>

    public int getPendingRevalidationsCount() {
<span class="nc" id="L139">        return pendingRevalidations.size();</span>
    }

    // for testing
    protected static void setAsyncSending(boolean newMode) {
<span class="nc" id="L144">        asyncSending = newMode;</span>
<span class="nc" id="L145">        LOG.info(&quot;{} = {}&quot;, LEARNER_ASYNC_SENDING, asyncSending);</span>

<span class="nc" id="L147">    }</span>
    protected static boolean getAsyncSending() {
<span class="nc" id="L149">        return asyncSending;</span>
    }
    /**
     * validate a session for a client
     *
     * @param clientId
     *                the client to be revalidated
     * @param timeout
     *                the timeout for which the session is valid
     * @throws IOException
     */
    void validateSession(ServerCnxn cnxn, long clientId, int timeout) throws IOException {
<span class="nc" id="L161">        LOG.info(&quot;Revalidating client: 0x{}&quot;, Long.toHexString(clientId));</span>
<span class="nc" id="L162">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L163">        DataOutputStream dos = new DataOutputStream(baos);</span>
<span class="nc" id="L164">        dos.writeLong(clientId);</span>
<span class="nc" id="L165">        dos.writeInt(timeout);</span>
<span class="nc" id="L166">        dos.close();</span>
<span class="nc" id="L167">        QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos.toByteArray(), null);</span>
<span class="nc" id="L168">        pendingRevalidations.put(clientId, cnxn);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L170">            ZooTrace.logTraceMessage(</span>
                LOG,
                ZooTrace.SESSION_TRACE_MASK,
<span class="nc" id="L173">                &quot;To validate session 0x&quot; + Long.toHexString(clientId));</span>
        }
<span class="nc" id="L175">        writePacket(qp, true);</span>
<span class="nc" id="L176">    }</span>

    /**
     * write a packet to the leader.
     *
     * This method is called by multiple threads. We need to make sure that only one thread is writing to leaderOs at a time.
     * When packets are sent synchronously, writing is done within a synchronization block.
     * When packets are sent asynchronously, sender.queuePacket() is called, which writes to a BlockingQueue, which is thread-safe.
     * Reading from this BlockingQueue and writing to leaderOs is the learner sender thread only.
     * So we have only one thread writing to leaderOs at a time in either case.
     *
     * @param pp
     *                the proposal packet to be sent to the leader
     * @throws IOException
     */
    void writePacket(QuorumPacket pp, boolean flush) throws IOException {
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (asyncSending) {</span>
<span class="nc" id="L193">            sender.queuePacket(pp);</span>
        } else {
<span class="nc" id="L195">            writePacketNow(pp, flush);</span>
        }
<span class="nc" id="L197">    }</span>

    void writePacketNow(QuorumPacket pp, boolean flush) throws IOException {
<span class="nc" id="L200">        synchronized (leaderOs) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (pp != null) {</span>
<span class="nc" id="L202">                messageTracker.trackSent(pp.getType());</span>
<span class="nc" id="L203">                leaderOs.writeRecord(pp, &quot;packet&quot;);</span>
            }
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (flush) {</span>
<span class="nc" id="L206">                bufferedOutput.flush();</span>
            }
<span class="nc" id="L208">        }</span>
<span class="nc" id="L209">    }</span>

    /**
     * Start thread that will forward any packet in the queue to the leader
     */
    protected void startSendingThread() {
<span class="nc" id="L215">        sender = new LearnerSender(this);</span>
<span class="nc" id="L216">        sender.start();</span>
<span class="nc" id="L217">    }</span>

    /**
     * read a packet from the leader
     *
     * @param pp
     *                the packet to be instantiated
     * @throws IOException
     */
    void readPacket(QuorumPacket pp) throws IOException {
<span class="nc" id="L227">        synchronized (leaderIs) {</span>
<span class="nc" id="L228">            leaderIs.readRecord(pp, &quot;packet&quot;);</span>
<span class="nc" id="L229">            messageTracker.trackReceived(pp.getType());</span>
<span class="nc" id="L230">        }</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
            final long traceMask =
<span class="nc bnc" id="L233" title="All 2 branches missed.">                (pp.getType() == Leader.PING) ? ZooTrace.SERVER_PING_TRACE_MASK</span>
<span class="nc" id="L234">                    : ZooTrace.SERVER_PACKET_TRACE_MASK;</span>

<span class="nc" id="L236">            ZooTrace.logQuorumPacket(LOG, traceMask, 'i', pp);</span>
        }
<span class="nc" id="L238">    }</span>

    /**
     * send a request packet to the leader
     *
     * @param request
     *                the request from the client
     * @throws IOException
     */
    void request(Request request) throws IOException {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (request.isThrottled()) {</span>
<span class="nc" id="L249">            LOG.error(&quot;Throttled request sent to leader: {}. Exiting&quot;, request);</span>
<span class="nc" id="L250">            ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());</span>
        }
<span class="nc" id="L252">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L253">        DataOutputStream oa = new DataOutputStream(baos);</span>
<span class="nc" id="L254">        oa.writeLong(request.sessionId);</span>
<span class="nc" id="L255">        oa.writeInt(request.cxid);</span>
<span class="nc" id="L256">        oa.writeInt(request.type);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (request.request != null) {</span>
<span class="nc" id="L258">            request.request.rewind();</span>
<span class="nc" id="L259">            int len = request.request.remaining();</span>
<span class="nc" id="L260">            byte[] b = new byte[len];</span>
<span class="nc" id="L261">            request.request.get(b);</span>
<span class="nc" id="L262">            request.request.rewind();</span>
<span class="nc" id="L263">            oa.write(b);</span>
        }
<span class="nc" id="L265">        oa.close();</span>
<span class="nc" id="L266">        QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos.toByteArray(), request.authInfo);</span>
<span class="nc" id="L267">        writePacket(qp, true);</span>
<span class="nc" id="L268">    }</span>

    /**
     * Returns the address of the node we think is the leader.
     */
    protected QuorumServer findLeader() {
<span class="nc" id="L274">        QuorumServer leaderServer = null;</span>
        // Find the leader by id
<span class="nc" id="L276">        Vote current = self.getCurrentVote();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        for (QuorumServer s : self.getView().values()) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (s.id == current.getId()) {</span>
                // Ensure we have the leader's correct IP address before
                // attempting to connect.
<span class="nc" id="L281">                s.recreateSocketAddresses();</span>
<span class="nc" id="L282">                leaderServer = s;</span>
<span class="nc" id="L283">                break;</span>
            }
<span class="nc" id="L285">        }</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (leaderServer == null) {</span>
<span class="nc" id="L287">            LOG.warn(&quot;Couldn't find the leader with id = {}&quot;, current.getId());</span>
        }
<span class="nc" id="L289">        return leaderServer;</span>
    }

    /**
     * Overridable helper method to return the System.nanoTime().
     * This method behaves identical to System.nanoTime().
     */
    protected long nanoTime() {
<span class="nc" id="L297">        return System.nanoTime();</span>
    }

    /**
     * Overridable helper method to simply call sock.connect(). This can be
     * overriden in tests to fake connection success/failure for connectToLeader.
     */
    protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout) throws IOException {
<span class="nc" id="L305">        sock.connect(addr, timeout);</span>
<span class="nc" id="L306">    }</span>

    /**
     * Establish a connection with the LearnerMaster found by findLearnerMaster.
     * Followers only connect to Leaders, Observers can connect to any active LearnerMaster.
     * Retries until either initLimit time has elapsed or 5 tries have happened.
     * @param multiAddr - the address of the Peer to connect to.
     * @throws IOException - if the socket connection fails on the 5th attempt
     * if there is an authentication failure while connecting to leader
     */
    protected void connectToLeader(MultipleAddresses multiAddr, String hostname) throws IOException {

<span class="nc" id="L318">        this.leaderAddr = multiAddr;</span>
        Set&lt;InetSocketAddress&gt; addresses;
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (self.isMultiAddressReachabilityCheckEnabled()) {</span>
            // even if none of the addresses are reachable, we want to try to establish connection
            // see ZOOKEEPER-3758
<span class="nc" id="L323">            addresses = multiAddr.getAllReachableAddressesOrAll();</span>
        } else {
<span class="nc" id="L325">            addresses = multiAddr.getAllAddresses();</span>
        }
<span class="nc" id="L327">        ExecutorService executor = Executors.newFixedThreadPool(addresses.size());</span>
<span class="nc" id="L328">        CountDownLatch latch = new CountDownLatch(addresses.size());</span>
<span class="nc" id="L329">        AtomicReference&lt;Socket&gt; socket = new AtomicReference&lt;&gt;(null);</span>
<span class="nc" id="L330">        addresses.stream().map(address -&gt; new LeaderConnector(address, socket, latch)).forEach(executor::submit);</span>

        try {
<span class="nc" id="L333">            latch.await();</span>
<span class="nc" id="L334">        } catch (InterruptedException e) {</span>
<span class="nc" id="L335">            LOG.warn(&quot;Interrupted while trying to connect to Leader&quot;, e);</span>
        } finally {
<span class="nc" id="L337">            executor.shutdown();</span>
            try {
<span class="nc bnc" id="L339" title="All 2 branches missed.">                if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L340">                    LOG.error(&quot;not all the LeaderConnector terminated properly&quot;);</span>
                }
<span class="nc" id="L342">            } catch (InterruptedException ie) {</span>
<span class="nc" id="L343">                LOG.error(&quot;Interrupted while terminating LeaderConnector executor.&quot;, ie);</span>
<span class="nc" id="L344">            }</span>
        }

<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (socket.get() == null) {</span>
<span class="nc" id="L348">            throw new IOException(&quot;Failed connect to &quot; + multiAddr);</span>
        } else {
<span class="nc" id="L350">            sock = socket.get();</span>
<span class="nc" id="L351">            sockBeingClosed.set(false);</span>
        }

<span class="nc" id="L354">        self.authLearner.authenticate(sock, hostname);</span>

<span class="nc" id="L356">        leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));</span>
<span class="nc" id="L357">        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());</span>
<span class="nc" id="L358">        leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (asyncSending) {</span>
<span class="nc" id="L360">            startSendingThread();</span>
        }
<span class="nc" id="L362">    }</span>

    class LeaderConnector implements Runnable {

        private AtomicReference&lt;Socket&gt; socket;
        private InetSocketAddress address;
        private CountDownLatch latch;

<span class="nc" id="L370">        LeaderConnector(InetSocketAddress address, AtomicReference&lt;Socket&gt; socket, CountDownLatch latch) {</span>
<span class="nc" id="L371">            this.address = address;</span>
<span class="nc" id="L372">            this.socket = socket;</span>
<span class="nc" id="L373">            this.latch = latch;</span>
<span class="nc" id="L374">        }</span>

        @Override
        public void run() {
            try {
<span class="nc" id="L379">                Thread.currentThread().setName(&quot;LeaderConnector-&quot; + address);</span>
<span class="nc" id="L380">                Socket sock = connectToLeader();</span>

<span class="nc bnc" id="L382" title="All 4 branches missed.">                if (sock != null &amp;&amp; sock.isConnected()) {</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">                    if (socket.compareAndSet(null, sock)) {</span>
<span class="nc" id="L384">                        LOG.info(&quot;Successfully connected to leader, using address: {}&quot;, address);</span>
                    } else {
<span class="nc" id="L386">                        LOG.info(&quot;Connection to the leader is already established, close the redundant connection&quot;);</span>
<span class="nc" id="L387">                        sock.close();</span>
                    }
                }

<span class="nc" id="L391">            } catch (Exception e) {</span>
<span class="nc" id="L392">                LOG.error(&quot;Failed connect to {}&quot;, address, e);</span>
            } finally {
<span class="nc" id="L394">                latch.countDown();</span>
            }
<span class="nc" id="L396">        }</span>

        private Socket connectToLeader() throws IOException, X509Exception, InterruptedException {
<span class="nc" id="L399">            Socket sock = createSocket();</span>

            // leader connection timeout defaults to tickTime * initLimit
<span class="nc" id="L402">            int connectTimeout = self.tickTime * self.initLimit;</span>

            // but if connectToLearnerMasterLimit is specified, use that value to calculate
            // timeout instead of using the initLimit value
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (self.connectToLearnerMasterLimit &gt; 0) {</span>
<span class="nc" id="L407">                connectTimeout = self.tickTime * self.connectToLearnerMasterLimit;</span>
            }

            int remainingTimeout;
<span class="nc" id="L411">            long startNanoTime = nanoTime();</span>

<span class="nc bnc" id="L413" title="All 4 branches missed.">            for (int tries = 0; tries &lt; 5 &amp;&amp; socket.get() == null; tries++) {</span>
                try {
                    // recalculate the init limit time because retries sleep for 1000 milliseconds
<span class="nc" id="L416">                    remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">                    if (remainingTimeout &lt;= 0) {</span>
<span class="nc" id="L418">                        LOG.error(&quot;connectToLeader exceeded on retries.&quot;);</span>
<span class="nc" id="L419">                        throw new IOException(&quot;connectToLeader exceeded on retries.&quot;);</span>
                    }

<span class="nc" id="L422">                    sockConnect(sock, address, Math.min(connectTimeout, remainingTimeout));</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                    if (self.isSslQuorum()) {</span>
<span class="nc" id="L424">                        ((SSLSocket) sock).startHandshake();</span>
                    }
<span class="nc" id="L426">                    sock.setTcpNoDelay(nodelay);</span>
<span class="nc" id="L427">                    break;</span>
<span class="nc" id="L428">                } catch (IOException e) {</span>
<span class="nc" id="L429">                    remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);</span>

<span class="nc bnc" id="L431" title="All 2 branches missed.">                    if (remainingTimeout &lt;= leaderConnectDelayDuringRetryMs) {</span>
<span class="nc" id="L432">                        LOG.error(</span>
                          &quot;Unexpected exception, connectToLeader exceeded. tries={}, remaining init limit={}, connecting to {}&quot;,
<span class="nc" id="L434">                          tries,</span>
<span class="nc" id="L435">                          remainingTimeout,</span>
                          address,
                          e);
<span class="nc" id="L438">                        throw e;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">                    } else if (tries &gt;= 4) {</span>
<span class="nc" id="L440">                        LOG.error(</span>
                          &quot;Unexpected exception, retries exceeded. tries={}, remaining init limit={}, connecting to {}&quot;,
<span class="nc" id="L442">                          tries,</span>
<span class="nc" id="L443">                          remainingTimeout,</span>
                          address,
                          e);
<span class="nc" id="L446">                        throw e;</span>
                    } else {
<span class="nc" id="L448">                        LOG.warn(</span>
                          &quot;Unexpected exception, tries={}, remaining init limit={}, connecting to {}&quot;,
<span class="nc" id="L450">                          tries,</span>
<span class="nc" id="L451">                          remainingTimeout,</span>
                          address,
                          e);
<span class="nc" id="L454">                        sock = createSocket();</span>
                    }
                }
<span class="nc" id="L457">                Thread.sleep(leaderConnectDelayDuringRetryMs);</span>
            }

<span class="nc" id="L460">            return sock;</span>
        }
    }

    /**
     * Creating a simple or and SSL socket.
     * This can be overridden in tests to fake already connected sockets for connectToLeader.
     */
    protected Socket createSocket() throws X509Exception, IOException {
        Socket sock;
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (self.isSslQuorum()) {</span>
<span class="nc" id="L471">            sock = self.getX509Util().createSSLSocket();</span>
        } else {
<span class="nc" id="L473">            sock = new Socket();</span>
        }
<span class="nc" id="L475">        sock.setSoTimeout(self.tickTime * self.initLimit);</span>
<span class="nc" id="L476">        return sock;</span>
    }

    /**
     * Once connected to the leader or learner master, perform the handshake
     * protocol to establish a following / observing connection.
     * @param pktType
     * @return the zxid the Leader sends for synchronization purposes.
     * @throws IOException
     */
    protected long registerWithLeader(int pktType) throws IOException {
        /*
         * Send follower info, including last zxid and sid
         */
<span class="nc" id="L490">        long lastLoggedZxid = self.getLastLoggedZxid();</span>
<span class="nc" id="L491">        QuorumPacket qp = new QuorumPacket();</span>
<span class="nc" id="L492">        qp.setType(pktType);</span>
<span class="nc" id="L493">        qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), 0));</span>

        /*
         * Add sid to payload
         */
<span class="nc" id="L498">        LearnerInfo li = new LearnerInfo(self.getId(), 0x10000, self.getQuorumVerifier().getVersion());</span>
<span class="nc" id="L499">        ByteArrayOutputStream bsid = new ByteArrayOutputStream();</span>
<span class="nc" id="L500">        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);</span>
<span class="nc" id="L501">        boa.writeRecord(li, &quot;LearnerInfo&quot;);</span>
<span class="nc" id="L502">        qp.setData(bsid.toByteArray());</span>

<span class="nc" id="L504">        writePacket(qp, true);</span>
<span class="nc" id="L505">        readPacket(qp);</span>
<span class="nc" id="L506">        final long newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (qp.getType() == Leader.LEADERINFO) {</span>
            // we are connected to a 1.0 server so accept the new epoch and read the next packet
<span class="nc" id="L509">            leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();</span>
<span class="nc" id="L510">            byte[] epochBytes = new byte[4];</span>
<span class="nc" id="L511">            final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (newEpoch &gt; self.getAcceptedEpoch()) {</span>
<span class="nc" id="L513">                wrappedEpochBytes.putInt((int) self.getCurrentEpoch());</span>
<span class="nc" id="L514">                self.setAcceptedEpoch(newEpoch);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            } else if (newEpoch == self.getAcceptedEpoch()) {</span>
                // since we have already acked an epoch equal to the leaders, we cannot ack
                // again, but we still need to send our lastZxid to the leader so that we can
                // sync with it if it does assume leadership of the epoch.
                // the -1 indicates that this reply should not count as an ack for the new epoch
<span class="nc" id="L520">                wrappedEpochBytes.putInt(-1);</span>
            } else {
<span class="nc" id="L522">                throw new IOException(&quot;Leaders epoch, &quot;</span>
                                      + newEpoch
                                      + &quot; is less than accepted epoch, &quot;
<span class="nc" id="L525">                                      + self.getAcceptedEpoch());</span>
            }
<span class="nc" id="L527">            QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);</span>
<span class="nc" id="L528">            writePacket(ackNewEpoch, true);</span>
<span class="nc" id="L529">            return ZxidUtils.makeZxid(newEpoch, 0);</span>
        } else {
<span class="nc bnc" id="L531" title="All 2 branches missed.">            if (newEpoch &gt; self.getAcceptedEpoch()) {</span>
<span class="nc" id="L532">                self.setAcceptedEpoch(newEpoch);</span>
            }
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if (qp.getType() != Leader.NEWLEADER) {</span>
<span class="nc" id="L535">                LOG.error(&quot;First packet should have been NEWLEADER&quot;);</span>
<span class="nc" id="L536">                throw new IOException(&quot;First packet should have been NEWLEADER&quot;);</span>
            }
<span class="nc" id="L538">            return qp.getZxid();</span>
        }
    }

    /**
     * Finally, synchronize our history with the Leader (if Follower)
     * or the LearnerMaster (if Observer).
     * @param newLeaderZxid
     * @throws IOException
     * @throws InterruptedException
     */
    protected void syncWithLeader(long newLeaderZxid) throws Exception {
<span class="nc" id="L550">        QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);</span>
<span class="nc" id="L551">        QuorumPacket qp = new QuorumPacket();</span>
<span class="nc" id="L552">        long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);</span>

<span class="nc" id="L554">        QuorumVerifier newLeaderQV = null;</span>

        // In the DIFF case we don't need to do a snapshot because the transactions will sync on top of any existing snapshot
        // For SNAP and TRUNC the snapshot is needed to save that history
<span class="nc" id="L558">        boolean snapshotNeeded = true;</span>
<span class="nc" id="L559">        boolean syncSnapshot = false;</span>
<span class="nc" id="L560">        readPacket(qp);</span>
<span class="nc" id="L561">        Deque&lt;Long&gt; packetsCommitted = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L562">        Deque&lt;PacketInFlight&gt; packetsNotCommitted = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L563">        synchronized (zk) {</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">            if (qp.getType() == Leader.DIFF) {</span>
<span class="nc" id="L565">                LOG.info(&quot;Getting a diff from the leader 0x{}&quot;, Long.toHexString(qp.getZxid()));</span>
<span class="nc" id="L566">                self.setSyncMode(QuorumPeer.SyncMode.DIFF);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                if (zk.shouldForceWriteInitialSnapshotAfterLeaderElection()) {</span>
<span class="nc" id="L568">                    LOG.info(&quot;Forcing a snapshot write as part of upgrading from an older Zookeeper. This should only happen while upgrading.&quot;);</span>
<span class="nc" id="L569">                    snapshotNeeded = true;</span>
<span class="nc" id="L570">                    syncSnapshot = true;</span>
                } else {
<span class="nc" id="L572">                    snapshotNeeded = false;</span>
                }
<span class="nc bnc" id="L574" title="All 2 branches missed.">            } else if (qp.getType() == Leader.SNAP) {</span>
<span class="nc" id="L575">                self.setSyncMode(QuorumPeer.SyncMode.SNAP);</span>
<span class="nc" id="L576">                LOG.info(&quot;Getting a snapshot from leader 0x{}&quot;, Long.toHexString(qp.getZxid()));</span>
                // The leader is going to dump the database
                // db is clear as part of deserializeSnapshot()
<span class="nc" id="L579">                zk.getZKDatabase().deserializeSnapshot(leaderIs);</span>
                // ZOOKEEPER-2819: overwrite config node content extracted
                // from leader snapshot with local config, to avoid potential
                // inconsistency of config node content during rolling restart.
<span class="nc bnc" id="L583" title="All 2 branches missed.">                if (!self.isReconfigEnabled()) {</span>
<span class="nc" id="L584">                    LOG.debug(&quot;Reset config node content from local config after deserialization of snapshot.&quot;);</span>
<span class="nc" id="L585">                    zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());</span>
                }
<span class="nc" id="L587">                String signature = leaderIs.readString(&quot;signature&quot;);</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">                if (!signature.equals(&quot;BenWasHere&quot;)) {</span>
<span class="nc" id="L589">                    LOG.error(&quot;Missing signature. Got {}&quot;, signature);</span>
<span class="nc" id="L590">                    throw new IOException(&quot;Missing signature&quot;);</span>
                }
<span class="nc" id="L592">                zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());</span>

                // immediately persist the latest snapshot when there is txn log gap
<span class="nc" id="L595">                syncSnapshot = true;</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">            } else if (qp.getType() == Leader.TRUNC) {</span>
                //we need to truncate the log to the lastzxid of the leader
<span class="nc" id="L598">                self.setSyncMode(QuorumPeer.SyncMode.TRUNC);</span>
<span class="nc" id="L599">                LOG.warn(&quot;Truncating log to get in sync with the leader 0x{}&quot;, Long.toHexString(qp.getZxid()));</span>
<span class="nc" id="L600">                boolean truncated = zk.getZKDatabase().truncateLog(qp.getZxid());</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">                if (!truncated) {</span>
                    // not able to truncate the log
<span class="nc" id="L603">                    LOG.error(&quot;Not able to truncate the log 0x{}&quot;, Long.toHexString(qp.getZxid()));</span>
<span class="nc" id="L604">                    ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());</span>
                }
<span class="nc" id="L606">                zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());</span>

<span class="nc" id="L608">            } else {</span>
<span class="nc" id="L609">                LOG.error(&quot;Got unexpected packet from leader: {}, exiting ... &quot;, LearnerHandler.packetToString(qp));</span>
<span class="nc" id="L610">                ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());</span>
            }
<span class="nc" id="L612">            zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());</span>
<span class="nc" id="L613">            zk.createSessionTracker();</span>

<span class="nc" id="L615">            long lastQueued = 0;</span>

            // in Zab V1.0 (ZK 3.4+) we might take a snapshot when we get the NEWLEADER message, but in pre V1.0
            // we take the snapshot on the UPDATE message, since Zab V1.0 also gets the UPDATE (after the NEWLEADER)
            // we need to make sure that we don't take the snapshot twice.
<span class="nc" id="L620">            boolean isPreZAB1_0 = true;</span>
            //If we are not going to take the snapshot be sure the transactions are not applied in memory
            // but written out to the transaction log
<span class="nc bnc" id="L623" title="All 2 branches missed.">            boolean writeToTxnLog = !snapshotNeeded;</span>
            TxnLogEntry logEntry;
            // we are now going to start getting transactions to apply followed by an UPTODATE
            outerLoop:
<span class="nc bnc" id="L627" title="All 2 branches missed.">            while (self.isRunning()) {</span>
<span class="nc" id="L628">                readPacket(qp);</span>
<span class="nc bnc" id="L629" title="All 6 branches missed.">                switch (qp.getType()) {</span>
                case Leader.PROPOSAL:
<span class="nc" id="L631">                    PacketInFlight pif = new PacketInFlight();</span>
<span class="nc" id="L632">                    logEntry = SerializeUtils.deserializeTxn(qp.getData());</span>
<span class="nc" id="L633">                    pif.hdr = logEntry.getHeader();</span>
<span class="nc" id="L634">                    pif.rec = logEntry.getTxn();</span>
<span class="nc" id="L635">                    pif.digest = logEntry.getDigest();</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">                    if (pif.hdr.getZxid() != lastQueued + 1) {</span>
<span class="nc" id="L637">                        LOG.warn(</span>
                            &quot;Got zxid 0x{} expected 0x{}&quot;,
<span class="nc" id="L639">                            Long.toHexString(pif.hdr.getZxid()),</span>
<span class="nc" id="L640">                            Long.toHexString(lastQueued + 1));</span>
                    }
<span class="nc" id="L642">                    lastQueued = pif.hdr.getZxid();</span>

<span class="nc bnc" id="L644" title="All 2 branches missed.">                    if (pif.hdr.getType() == OpCode.reconfig) {</span>
<span class="nc" id="L645">                        SetDataTxn setDataTxn = (SetDataTxn) pif.rec;</span>
<span class="nc" id="L646">                        QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));</span>
<span class="nc" id="L647">                        self.setLastSeenQuorumVerifier(qv, true);</span>
                    }

<span class="nc" id="L650">                    packetsNotCommitted.add(pif);</span>
<span class="nc" id="L651">                    break;</span>
                case Leader.COMMIT:
                case Leader.COMMITANDACTIVATE:
<span class="nc" id="L654">                    pif = packetsNotCommitted.peekFirst();</span>
<span class="nc bnc" id="L655" title="All 4 branches missed.">                    if (pif.hdr.getZxid() == qp.getZxid() &amp;&amp; qp.getType() == Leader.COMMITANDACTIVATE) {</span>
<span class="nc" id="L656">                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData(), UTF_8));</span>
<span class="nc" id="L657">                        boolean majorChange = self.processReconfig(</span>
                            qv,
<span class="nc" id="L659">                            ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(),</span>
                            true);
<span class="nc bnc" id="L661" title="All 2 branches missed.">                        if (majorChange) {</span>
<span class="nc" id="L662">                            throw new Exception(&quot;changes proposed in reconfig&quot;);</span>
                        }
                    }
<span class="nc bnc" id="L665" title="All 2 branches missed.">                    if (!writeToTxnLog) {</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                        if (pif.hdr.getZxid() != qp.getZxid()) {</span>
<span class="nc" id="L667">                            LOG.warn(</span>
                                &quot;Committing 0x{}, but next proposal is 0x{}&quot;,
<span class="nc" id="L669">                                Long.toHexString(qp.getZxid()),</span>
<span class="nc" id="L670">                                Long.toHexString(pif.hdr.getZxid()));</span>
                        } else {
<span class="nc" id="L672">                            zk.processTxn(pif.hdr, pif.rec);</span>
<span class="nc" id="L673">                            packetsNotCommitted.remove();</span>
                        }
                    } else {
<span class="nc" id="L676">                        packetsCommitted.add(qp.getZxid());</span>
                    }
<span class="nc" id="L678">                    break;</span>
                case Leader.INFORM:
                case Leader.INFORMANDACTIVATE:
<span class="nc" id="L681">                    PacketInFlight packet = new PacketInFlight();</span>

<span class="nc bnc" id="L683" title="All 2 branches missed.">                    if (qp.getType() == Leader.INFORMANDACTIVATE) {</span>
<span class="nc" id="L684">                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());</span>
<span class="nc" id="L685">                        long suggestedLeaderId = buffer.getLong();</span>
<span class="nc" id="L686">                        byte[] remainingdata = new byte[buffer.remaining()];</span>
<span class="nc" id="L687">                        buffer.get(remainingdata);</span>
<span class="nc" id="L688">                        logEntry = SerializeUtils.deserializeTxn(remainingdata);</span>
<span class="nc" id="L689">                        packet.hdr = logEntry.getHeader();</span>
<span class="nc" id="L690">                        packet.rec = logEntry.getTxn();</span>
<span class="nc" id="L691">                        packet.digest = logEntry.getDigest();</span>
<span class="nc" id="L692">                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) packet.rec).getData(), UTF_8));</span>
<span class="nc" id="L693">                        boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                        if (majorChange) {</span>
<span class="nc" id="L695">                            throw new Exception(&quot;changes proposed in reconfig&quot;);</span>
                        }
<span class="nc" id="L697">                    } else {</span>
<span class="nc" id="L698">                        logEntry = SerializeUtils.deserializeTxn(qp.getData());</span>
<span class="nc" id="L699">                        packet.rec = logEntry.getTxn();</span>
<span class="nc" id="L700">                        packet.hdr = logEntry.getHeader();</span>
<span class="nc" id="L701">                        packet.digest = logEntry.getDigest();</span>
                        // Log warning message if txn comes out-of-order
<span class="nc bnc" id="L703" title="All 2 branches missed.">                        if (packet.hdr.getZxid() != lastQueued + 1) {</span>
<span class="nc" id="L704">                            LOG.warn(</span>
                                &quot;Got zxid 0x{} expected 0x{}&quot;,
<span class="nc" id="L706">                                Long.toHexString(packet.hdr.getZxid()),</span>
<span class="nc" id="L707">                                Long.toHexString(lastQueued + 1));</span>
                        }
<span class="nc" id="L709">                        lastQueued = packet.hdr.getZxid();</span>
                    }
<span class="nc bnc" id="L711" title="All 2 branches missed.">                    if (!writeToTxnLog) {</span>
                        // Apply to db directly if we haven't taken the snapshot
<span class="nc" id="L713">                        zk.processTxn(packet.hdr, packet.rec);</span>
                    } else {
<span class="nc" id="L715">                        packetsNotCommitted.add(packet);</span>
<span class="nc" id="L716">                        packetsCommitted.add(qp.getZxid());</span>
                    }

<span class="nc" id="L719">                    break;</span>
                case Leader.UPTODATE:
<span class="nc" id="L721">                    LOG.info(&quot;Learner received UPTODATE message&quot;);</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">                    if (newLeaderQV != null) {</span>
<span class="nc" id="L723">                        boolean majorChange = self.processReconfig(newLeaderQV, null, null, true);</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                        if (majorChange) {</span>
<span class="nc" id="L725">                            throw new Exception(&quot;changes proposed in reconfig&quot;);</span>
                        }
                    }
<span class="nc bnc" id="L728" title="All 2 branches missed.">                    if (isPreZAB1_0) {</span>
<span class="nc" id="L729">                        zk.takeSnapshot(syncSnapshot);</span>
<span class="nc" id="L730">                        self.setCurrentEpoch(newEpoch);</span>
                    }
<span class="nc" id="L732">                    self.setZooKeeperServer(zk);</span>
<span class="nc" id="L733">                    self.adminServer.setZooKeeperServer(zk);</span>
<span class="nc" id="L734">                    break outerLoop;</span>
                case Leader.NEWLEADER: // Getting NEWLEADER here instead of in discovery
                    // means this is Zab 1.0
<span class="nc" id="L737">                    LOG.info(&quot;Learner received NEWLEADER message&quot;);</span>
<span class="nc bnc" id="L738" title="All 4 branches missed.">                    if (qp.getData() != null &amp;&amp; qp.getData().length &gt; 1) {</span>
                        try {
<span class="nc" id="L740">                            QuorumVerifier qv = self.configFromString(new String(qp.getData(), UTF_8));</span>
<span class="nc" id="L741">                            self.setLastSeenQuorumVerifier(qv, true);</span>
<span class="nc" id="L742">                            newLeaderQV = qv;</span>
<span class="nc" id="L743">                        } catch (Exception e) {</span>
<span class="nc" id="L744">                            e.printStackTrace();</span>
<span class="nc" id="L745">                        }</span>
                    }

<span class="nc bnc" id="L748" title="All 2 branches missed.">                    if (snapshotNeeded) {</span>
<span class="nc" id="L749">                        zk.takeSnapshot(syncSnapshot);</span>
                    }

<span class="nc" id="L752">                    self.setCurrentEpoch(newEpoch);</span>
<span class="nc" id="L753">                    writeToTxnLog = true;</span>
                    //Anything after this needs to go to the transaction log, not applied directly in memory
<span class="nc" id="L755">                    isPreZAB1_0 = false;</span>

                    // ZOOKEEPER-3911: make sure sync the uncommitted logs before commit them (ACK NEWLEADER).
<span class="nc" id="L758">                    sock.setSoTimeout(self.tickTime * self.syncLimit);</span>
<span class="nc" id="L759">                    self.setSyncMode(QuorumPeer.SyncMode.NONE);</span>
<span class="nc" id="L760">                    zk.startupWithoutServing();</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">                    if (zk instanceof FollowerZooKeeperServer) {</span>
<span class="nc" id="L762">                        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">                        for (PacketInFlight p : packetsNotCommitted) {</span>
<span class="nc" id="L764">                            fzk.logRequest(p.hdr, p.rec, p.digest);</span>
<span class="nc" id="L765">                        }</span>
<span class="nc" id="L766">                        packetsNotCommitted.clear();</span>
                    }

<span class="nc" id="L769">                    writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);</span>
<span class="nc" id="L770">                    break;</span>
                }
            }
<span class="nc" id="L773">        }</span>
<span class="nc" id="L774">        ack.setZxid(ZxidUtils.makeZxid(newEpoch, 0));</span>
<span class="nc" id="L775">        writePacket(ack, true);</span>
<span class="nc" id="L776">        zk.startServing();</span>
        /*
         * Update the election vote here to ensure that all members of the
         * ensemble report the same vote to new servers that start up and
         * send leader election notifications to the ensemble.
         *
         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732
         */
<span class="nc" id="L784">        self.updateElectionVote(newEpoch);</span>

        // We need to log the stuff that came in between the snapshot and the uptodate
<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (zk instanceof FollowerZooKeeperServer) {</span>
<span class="nc" id="L788">            FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">            for (PacketInFlight p : packetsNotCommitted) {</span>
<span class="nc" id="L790">                fzk.logRequest(p.hdr, p.rec, p.digest);</span>
<span class="nc" id="L791">            }</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">            for (Long zxid : packetsCommitted) {</span>
<span class="nc" id="L793">                fzk.commit(zxid);</span>
<span class="nc" id="L794">            }</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">        } else if (zk instanceof ObserverZooKeeperServer) {</span>
            // Similar to follower, we need to log requests between the snapshot
            // and UPTODATE
<span class="nc" id="L798">            ObserverZooKeeperServer ozk = (ObserverZooKeeperServer) zk;</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">            for (PacketInFlight p : packetsNotCommitted) {</span>
<span class="nc" id="L800">                Long zxid = packetsCommitted.peekFirst();</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                if (p.hdr.getZxid() != zxid) {</span>
                    // log warning message if there is no matching commit
                    // old leader send outstanding proposal to observer
<span class="nc" id="L804">                    LOG.warn(</span>
                        &quot;Committing 0x{}, but next proposal is 0x{}&quot;,
<span class="nc" id="L806">                        Long.toHexString(zxid),</span>
<span class="nc" id="L807">                        Long.toHexString(p.hdr.getZxid()));</span>
<span class="nc" id="L808">                    continue;</span>
                }
<span class="nc" id="L810">                packetsCommitted.remove();</span>
<span class="nc" id="L811">                Request request = new Request(null, p.hdr.getClientId(), p.hdr.getCxid(), p.hdr.getType(), null, null);</span>
<span class="nc" id="L812">                request.setTxn(p.rec);</span>
<span class="nc" id="L813">                request.setHdr(p.hdr);</span>
<span class="nc" id="L814">                request.setTxnDigest(p.digest);</span>
<span class="nc" id="L815">                ozk.commitRequest(request);</span>
<span class="nc" id="L816">            }</span>
<span class="nc" id="L817">        } else {</span>
            // New server type need to handle in-flight packets
<span class="nc" id="L819">            throw new UnsupportedOperationException(&quot;Unknown server type&quot;);</span>
        }
<span class="nc" id="L821">    }</span>

    protected void revalidate(QuorumPacket qp) throws IOException {
<span class="nc" id="L824">        ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());</span>
<span class="nc" id="L825">        DataInputStream dis = new DataInputStream(bis);</span>
<span class="nc" id="L826">        long sessionId = dis.readLong();</span>
<span class="nc" id="L827">        boolean valid = dis.readBoolean();</span>
<span class="nc" id="L828">        ServerCnxn cnxn = pendingRevalidations.remove(sessionId);</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (cnxn == null) {</span>
<span class="nc" id="L830">            LOG.warn(&quot;Missing session 0x{} for validation&quot;, Long.toHexString(sessionId));</span>
        } else {
<span class="nc" id="L832">            zk.finishSessionInit(cnxn, valid);</span>
        }
<span class="nc bnc" id="L834" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L835">            ZooTrace.logTraceMessage(</span>
                LOG,
                ZooTrace.SESSION_TRACE_MASK,
<span class="nc" id="L838">                &quot;Session 0x&quot; + Long.toHexString(sessionId) + &quot; is valid: &quot; + valid);</span>
        }
<span class="nc" id="L840">    }</span>

    protected void ping(QuorumPacket qp) throws IOException {
        // Send back the ping with our session data
<span class="nc" id="L844">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="nc" id="L845">        DataOutputStream dos = new DataOutputStream(bos);</span>
<span class="nc" id="L846">        Map&lt;Long, Integer&gt; touchTable = zk.getTouchSnapshot();</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">        for (Entry&lt;Long, Integer&gt; entry : touchTable.entrySet()) {</span>
<span class="nc" id="L848">            dos.writeLong(entry.getKey());</span>
<span class="nc" id="L849">            dos.writeInt(entry.getValue());</span>
<span class="nc" id="L850">        }</span>

<span class="nc" id="L852">        QuorumPacket pingReply = new QuorumPacket(qp.getType(), qp.getZxid(), bos.toByteArray(), qp.getAuthinfo());</span>
<span class="nc" id="L853">        writePacket(pingReply, true);</span>
<span class="nc" id="L854">    }</span>

    /**
     * Shutdown the Peer
     */
    public void shutdown() {
<span class="nc" id="L860">        self.setZooKeeperServer(null);</span>
<span class="nc" id="L861">        self.closeAllConnections();</span>
<span class="nc" id="L862">        self.adminServer.setZooKeeperServer(null);</span>

<span class="nc bnc" id="L864" title="All 2 branches missed.">        if (sender != null) {</span>
<span class="nc" id="L865">            sender.shutdown();</span>
        }

<span class="nc" id="L868">        closeSocket();</span>
        // shutdown previous zookeeper
<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (zk != null) {</span>
            // If we haven't finished SNAP sync, force fully shutdown
            // to avoid potential inconsistency
<span class="nc" id="L873">            zk.shutdown(self.getSyncMode().equals(QuorumPeer.SyncMode.SNAP));</span>
        }
<span class="nc" id="L875">    }</span>

    boolean isRunning() {
<span class="nc bnc" id="L878" title="All 4 branches missed.">        return self.isRunning() &amp;&amp; zk.isRunning();</span>
    }

    void closeSocket() {
<span class="nc bnc" id="L882" title="All 2 branches missed.">        if (sock != null) {</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">            if (sockBeingClosed.compareAndSet(false, true)) {</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                if (closeSocketAsync) {</span>
<span class="nc" id="L885">                    final Thread closingThread = new Thread(() -&gt; closeSockSync(), &quot;CloseSocketThread(sid:&quot; + zk.getServerId());</span>
<span class="nc" id="L886">                    closingThread.setDaemon(true);</span>
<span class="nc" id="L887">                    closingThread.start();</span>
<span class="nc" id="L888">                } else {</span>
<span class="nc" id="L889">                    closeSockSync();</span>
                }
            }
        }
<span class="nc" id="L893">    }</span>

    void closeSockSync() {
        try {
<span class="nc" id="L897">            long startTime = Time.currentElapsedTime();</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">            if (sock != null) {</span>
<span class="nc" id="L899">                sock.close();</span>
<span class="nc" id="L900">                sock = null;</span>
            }
<span class="nc" id="L902">            ServerMetrics.getMetrics().SOCKET_CLOSING_TIME.add(Time.currentElapsedTime() - startTime);</span>
<span class="nc" id="L903">        } catch (IOException e) {</span>
<span class="nc" id="L904">            LOG.warn(&quot;Ignoring error closing connection to leader&quot;, e);</span>
<span class="nc" id="L905">        }</span>
<span class="nc" id="L906">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>