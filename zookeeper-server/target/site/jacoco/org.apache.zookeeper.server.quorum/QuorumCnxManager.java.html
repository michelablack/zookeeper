<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuorumCnxManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server.quorum</a> &gt; <span class="el_source">QuorumCnxManager.java</span></div><h1>QuorumCnxManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server.quorum;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.apache.zookeeper.common.NetUtils.formatInetAddr;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.channels.UnresolvedAddressException;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import javax.net.ssl.SSLSocket;
import org.apache.zookeeper.common.NetUtils;
import org.apache.zookeeper.common.X509Exception;
import org.apache.zookeeper.server.ExitCode;
import org.apache.zookeeper.server.ZooKeeperThread;
import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;
import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;
import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
import org.apache.zookeeper.server.util.ConfigUtils;
import org.apache.zookeeper.util.CircularBlockingQueue;
import org.apache.zookeeper.util.ServiceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * This class implements a connection manager for leader election using TCP. It
 * maintains one connection for every pair of servers. The tricky part is to
 * guarantee that there is exactly one connection for every pair of servers that
 * are operating correctly and that can communicate over the network.
 *
 * If two servers try to start a connection concurrently, then the connection
 * manager uses a very simple tie-breaking mechanism to decide which connection
 * to drop based on the IP addressed of the two parties.
 *
 * For every peer, the manager maintains a queue of messages to send. If the
 * connection to any particular peer drops, then the sender thread puts the
 * message back on the list. As this implementation currently uses a queue
 * implementation to maintain messages to send to another peer, we add the
 * message to the tail of the queue, thus changing the order of messages.
 * Although this is not a problem for the leader election, it could be a problem
 * when consolidating peer communication. This is to be verified, though.
 *
 */

public class QuorumCnxManager {

<span class="nc" id="L101">    private static final Logger LOG = LoggerFactory.getLogger(QuorumCnxManager.class);</span>

    /*
     * Maximum capacity of thread queues
     */
    static final int RECV_CAPACITY = 100;
    // Initialized to 1 to prevent sending
    // stale notifications to peers
    static final int SEND_CAPACITY = 1;

    static final int PACKETMAXSIZE = 1024 * 512;

    /*
     * Negative counter for observer server ids.
     */

<span class="nc" id="L117">    private AtomicLong observerCounter = new AtomicLong(-1);</span>

    /*
     * Protocol identifier used among peers (must be a negative number for backward compatibility reasons)
     */
    // the following protocol version was sent in every connection initiation message since ZOOKEEPER-107 released in 3.5.0
    public static final long PROTOCOL_VERSION_V1 = -65536L;
    // ZOOKEEPER-3188 introduced multiple addresses in the connection initiation message, released in 3.6.0
    public static final long PROTOCOL_VERSION_V2 = -65535L;

    /*
     * Max buffer size to be read from the network.
     */
    public static final int maxBuffer = 2048;

    /*
     * Connection time out value in milliseconds
     */

<span class="nc" id="L136">    private int cnxTO = 5000;</span>

    final QuorumPeer self;

    /*
     * Local IP address
     */
    final long mySid;
    final int socketTimeout;
    final Map&lt;Long, QuorumPeer.QuorumServer&gt; view;
    final boolean listenOnAllIPs;
    private ThreadPoolExecutor connectionExecutor;
<span class="nc" id="L148">    private final Set&lt;Long&gt; inprogressConnections = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
    private QuorumAuthServer authServer;
    private QuorumAuthLearner authLearner;
    private boolean quorumSaslAuthEnabled;
    /*
     * Counter to count connection processing threads.
     */
<span class="nc" id="L155">    private AtomicInteger connectionThreadCnt = new AtomicInteger(0);</span>

    /*
     * Mapping from Peer to Thread number
     */
    final ConcurrentHashMap&lt;Long, SendWorker&gt; senderWorkerMap;
    final ConcurrentHashMap&lt;Long, BlockingQueue&lt;ByteBuffer&gt;&gt; queueSendMap;
    final ConcurrentHashMap&lt;Long, ByteBuffer&gt; lastMessageSent;

    /*
     * Reception queue
     */
    public final BlockingQueue&lt;Message&gt; recvQueue;

    /*
     * Shutdown flag
     */

<span class="nc" id="L173">    volatile boolean shutdown = false;</span>

    /*
     * Listener thread
     */
    public final Listener listener;

    /*
     * Counter to count worker threads
     */
<span class="nc" id="L183">    private AtomicInteger threadCnt = new AtomicInteger(0);</span>

    /*
     * Socket options for TCP keepalive
     */
<span class="nc" id="L188">    private final boolean tcpKeepAlive = Boolean.getBoolean(&quot;zookeeper.tcpKeepAlive&quot;);</span>


    /*
     * Socket factory, allowing the injection of custom socket implementations for testing
     */
<span class="nc" id="L194">    static final Supplier&lt;Socket&gt; DEFAULT_SOCKET_FACTORY = () -&gt; new Socket();</span>
<span class="nc" id="L195">    private static Supplier&lt;Socket&gt; SOCKET_FACTORY = DEFAULT_SOCKET_FACTORY;</span>
    static void setSocketFactory(Supplier&lt;Socket&gt; factory) {
<span class="nc" id="L197">        SOCKET_FACTORY = factory;</span>
<span class="nc" id="L198">    }</span>


    public static class Message {

<span class="nc" id="L203">        Message(ByteBuffer buffer, long sid) {</span>
<span class="nc" id="L204">            this.buffer = buffer;</span>
<span class="nc" id="L205">            this.sid = sid;</span>
<span class="nc" id="L206">        }</span>

        ByteBuffer buffer;
        long sid;

    }

    /*
     * This class parses the initial identification sent out by peers with their
     * sid &amp; hostname.
     */
    public static class InitialMessage {

        public Long sid;
        public List&lt;InetSocketAddress&gt; electionAddr;

<span class="nc" id="L222">        InitialMessage(Long sid, List&lt;InetSocketAddress&gt; addresses) {</span>
<span class="nc" id="L223">            this.sid = sid;</span>
<span class="nc" id="L224">            this.electionAddr = addresses;</span>
<span class="nc" id="L225">        }</span>

        @SuppressWarnings(&quot;serial&quot;)
        public static class InitialMessageException extends Exception {

            InitialMessageException(String message, Object... args) {
<span class="nc" id="L231">                super(String.format(message, args));</span>
<span class="nc" id="L232">            }</span>

        }

        public static InitialMessage parse(Long protocolVersion, DataInputStream din) throws InitialMessageException, IOException {
            Long sid;

<span class="nc bnc" id="L239" title="All 4 branches missed.">            if (protocolVersion != PROTOCOL_VERSION_V1 &amp;&amp; protocolVersion != PROTOCOL_VERSION_V2) {</span>
<span class="nc" id="L240">                throw new InitialMessageException(&quot;Got unrecognized protocol version %s&quot;, protocolVersion);</span>
            }

<span class="nc" id="L243">            sid = din.readLong();</span>

<span class="nc" id="L245">            int remaining = din.readInt();</span>
<span class="nc bnc" id="L246" title="All 4 branches missed.">            if (remaining &lt;= 0 || remaining &gt; maxBuffer) {</span>
<span class="nc" id="L247">                throw new InitialMessageException(&quot;Unreasonable buffer length: %s&quot;, remaining);</span>
            }

<span class="nc" id="L250">            byte[] b = new byte[remaining];</span>
<span class="nc" id="L251">            int num_read = din.read(b);</span>

<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (num_read != remaining) {</span>
<span class="nc" id="L254">                throw new InitialMessageException(&quot;Read only %s bytes out of %s sent by server %s&quot;, num_read, remaining, sid);</span>
            }

            // in PROTOCOL_VERSION_V1 we expect to get a single address here represented as a 'host:port' string
            // in PROTOCOL_VERSION_V2 we expect to get multiple addresses like: 'host1:port1|host2:port2|...'
<span class="nc" id="L259">            String[] addressStrings = new String(b, UTF_8).split(&quot;\\|&quot;);</span>
<span class="nc" id="L260">            List&lt;InetSocketAddress&gt; addresses = new ArrayList&lt;&gt;(addressStrings.length);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            for (String addr : addressStrings) {</span>

                String[] host_port;
                try {
<span class="nc" id="L265">                    host_port = ConfigUtils.getHostAndPort(addr);</span>
<span class="nc" id="L266">                } catch (ConfigException e) {</span>
<span class="nc" id="L267">                    throw new InitialMessageException(&quot;Badly formed address: %s&quot;, addr);</span>
<span class="nc" id="L268">                }</span>

<span class="nc bnc" id="L270" title="All 2 branches missed.">                if (host_port.length != 2) {</span>
<span class="nc" id="L271">                    throw new InitialMessageException(&quot;Badly formed address: %s&quot;, addr);</span>
                }

                int port;
                try {
<span class="nc" id="L276">                    port = Integer.parseInt(host_port[1]);</span>
<span class="nc" id="L277">                } catch (NumberFormatException e) {</span>
<span class="nc" id="L278">                    throw new InitialMessageException(&quot;Bad port number: %s&quot;, host_port[1]);</span>
<span class="nc" id="L279">                } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L280">                    throw new InitialMessageException(&quot;No port number in: %s&quot;, addr);</span>
<span class="nc" id="L281">                }</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                if (!isWildcardAddress(host_port[0])) {</span>
<span class="nc" id="L283">                    addresses.add(new InetSocketAddress(host_port[0], port));</span>
                }
            }

<span class="nc" id="L287">            return new InitialMessage(sid, addresses);</span>
        }

        /**
         * Returns true if the specified hostname is a wildcard address,
         * like 0.0.0.0 for IPv4 or :: for IPv6
         *
         * (the function is package-private to be visible for testing)
         */
        static boolean isWildcardAddress(final String hostname) {
            try {
<span class="nc" id="L298">                return InetAddress.getByName(hostname).isAnyLocalAddress();</span>
<span class="nc" id="L299">            } catch (UnknownHostException e) {</span>
                // if we can not resolve, it can not be a wildcard address
<span class="nc" id="L301">                return false;</span>
            }
        }

        @Override
        public String toString() {
<span class="nc" id="L307">            return &quot;InitialMessage{sid=&quot; + sid + &quot;, electionAddr=&quot; + electionAddr + '}';</span>
        }
    }

    public QuorumCnxManager(QuorumPeer self, final long mySid, Map&lt;Long, QuorumPeer.QuorumServer&gt; view,
        QuorumAuthServer authServer, QuorumAuthLearner authLearner, int socketTimeout, boolean listenOnAllIPs,
<span class="nc" id="L313">        int quorumCnxnThreadsSize, boolean quorumSaslAuthEnabled) {</span>

<span class="nc" id="L315">        this.recvQueue = new CircularBlockingQueue&lt;&gt;(RECV_CAPACITY);</span>
<span class="nc" id="L316">        this.queueSendMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L317">        this.senderWorkerMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L318">        this.lastMessageSent = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc" id="L320">        String cnxToValue = System.getProperty(&quot;zookeeper.cnxTimeout&quot;);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (cnxToValue != null) {</span>
<span class="nc" id="L322">            this.cnxTO = Integer.parseInt(cnxToValue);</span>
        }

<span class="nc" id="L325">        this.self = self;</span>

<span class="nc" id="L327">        this.mySid = mySid;</span>
<span class="nc" id="L328">        this.socketTimeout = socketTimeout;</span>
<span class="nc" id="L329">        this.view = view;</span>
<span class="nc" id="L330">        this.listenOnAllIPs = listenOnAllIPs;</span>
<span class="nc" id="L331">        this.authServer = authServer;</span>
<span class="nc" id="L332">        this.authLearner = authLearner;</span>
<span class="nc" id="L333">        this.quorumSaslAuthEnabled = quorumSaslAuthEnabled;</span>

<span class="nc" id="L335">        initializeConnectionExecutor(mySid, quorumCnxnThreadsSize);</span>

        // Starts listener thread that waits for connection requests
<span class="nc" id="L338">        listener = new Listener();</span>
<span class="nc" id="L339">        listener.setName(&quot;QuorumPeerListener&quot;);</span>
<span class="nc" id="L340">    }</span>

    // we always use the Connection Executor during connection initiation (to handle connection
    // timeouts), and optionally use it during receiving connections (as the Quorum SASL authentication
    // can take extra time)
    private void initializeConnectionExecutor(final long mySid, final int quorumCnxnThreadsSize) {
<span class="nc" id="L346">        final AtomicInteger threadIndex = new AtomicInteger(1);</span>
<span class="nc" id="L347">        SecurityManager s = System.getSecurityManager();</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        final ThreadGroup group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span>

<span class="nc" id="L350">        final ThreadFactory daemonThFactory = runnable -&gt; new Thread(group, runnable,</span>
<span class="nc" id="L351">            String.format(&quot;QuorumConnectionThread-[myid=%d]-%d&quot;, mySid, threadIndex.getAndIncrement()));</span>

<span class="nc" id="L353">        this.connectionExecutor = new ThreadPoolExecutor(3, quorumCnxnThreadsSize, 60, TimeUnit.SECONDS,</span>
                                                         new SynchronousQueue&lt;&gt;(), daemonThFactory);
<span class="nc" id="L355">        this.connectionExecutor.allowCoreThreadTimeOut(true);</span>
<span class="nc" id="L356">    }</span>

    /**
     * Invokes initiateConnection for testing purposes
     *
     * @param sid
     */
    public void testInitiateConnection(long sid) {
<span class="nc" id="L364">        LOG.debug(&quot;Opening channel to server {}&quot;, sid);</span>
<span class="nc" id="L365">        initiateConnection(self.getVotingView().get(sid).electionAddr, sid);</span>
<span class="nc" id="L366">    }</span>

    /**
     * First we create the socket, perform SSL handshake and authentication if needed.
     * Then we perform the initiation protocol.
     * If this server has initiated the connection, then it gives up on the
     * connection if it loses challenge. Otherwise, it keeps the connection.
     */
    public void initiateConnection(final MultipleAddresses electionAddr, final Long sid) {
<span class="nc" id="L375">        Socket sock = null;</span>
        try {
<span class="nc" id="L377">            LOG.debug(&quot;Opening channel to server {}&quot;, sid);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">            if (self.isSslQuorum()) {</span>
<span class="nc" id="L379">                sock = self.getX509Util().createSSLSocket();</span>
            } else {
<span class="nc" id="L381">                sock = SOCKET_FACTORY.get();</span>
            }
<span class="nc" id="L383">            setSockOpts(sock);</span>
<span class="nc" id="L384">            sock.connect(electionAddr.getReachableOrOne(), cnxTO);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">            if (sock instanceof SSLSocket) {</span>
<span class="nc" id="L386">                SSLSocket sslSock = (SSLSocket) sock;</span>
<span class="nc" id="L387">                sslSock.startHandshake();</span>
<span class="nc" id="L388">                LOG.info(&quot;SSL handshake complete with {} - {} - {}&quot;,</span>
<span class="nc" id="L389">                         sslSock.getRemoteSocketAddress(),</span>
<span class="nc" id="L390">                         sslSock.getSession().getProtocol(),</span>
<span class="nc" id="L391">                         sslSock.getSession().getCipherSuite());</span>
            }

<span class="nc" id="L394">            LOG.debug(&quot;Connected to server {} using election address: {}:{}&quot;,</span>
<span class="nc" id="L395">                      sid, sock.getInetAddress(), sock.getPort());</span>
<span class="nc" id="L396">        } catch (X509Exception e) {</span>
<span class="nc" id="L397">            LOG.warn(&quot;Cannot open secure channel to {} at election address {}&quot;, sid, electionAddr, e);</span>
<span class="nc" id="L398">            closeSocket(sock);</span>
<span class="nc" id="L399">            return;</span>
<span class="nc" id="L400">        } catch (UnresolvedAddressException | IOException e) {</span>
<span class="nc" id="L401">            LOG.warn(&quot;Cannot open channel to {} at election address {}&quot;, sid, electionAddr, e);</span>
<span class="nc" id="L402">            closeSocket(sock);</span>
<span class="nc" id="L403">            return;</span>
<span class="nc" id="L404">        }</span>

        try {
<span class="nc" id="L407">            startConnection(sock, sid);</span>
<span class="nc" id="L408">        } catch (IOException e) {</span>
<span class="nc" id="L409">            LOG.error(</span>
              &quot;Exception while connecting, id: {}, addr: {}, closing learner connection&quot;,
              sid,
<span class="nc" id="L412">              sock.getRemoteSocketAddress(),</span>
              e);
<span class="nc" id="L414">            closeSocket(sock);</span>
<span class="nc" id="L415">        }</span>
<span class="nc" id="L416">    }</span>

    /**
     * Server will initiate the connection request to its peer server
     * asynchronously via separate connection thread.
     */
    public boolean initiateConnectionAsync(final MultipleAddresses electionAddr, final Long sid) {
<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (!inprogressConnections.add(sid)) {</span>
            // simply return as there is a connection request to
            // server 'sid' already in progress.
<span class="nc" id="L426">            LOG.debug(&quot;Connection request to server id: {} is already in progress, so skipping this request&quot;, sid);</span>
<span class="nc" id="L427">            return true;</span>
        }
        try {
<span class="nc" id="L430">            connectionExecutor.execute(new QuorumConnectionReqThread(electionAddr, sid));</span>
<span class="nc" id="L431">            connectionThreadCnt.incrementAndGet();</span>
<span class="nc" id="L432">        } catch (Throwable e) {</span>
            // Imp: Safer side catching all type of exceptions and remove 'sid'
            // from inprogress connections. This is to avoid blocking further
            // connection requests from this 'sid' in case of errors.
<span class="nc" id="L436">            inprogressConnections.remove(sid);</span>
<span class="nc" id="L437">            LOG.error(&quot;Exception while submitting quorum connection request&quot;, e);</span>
<span class="nc" id="L438">            return false;</span>
<span class="nc" id="L439">        }</span>
<span class="nc" id="L440">        return true;</span>
    }

    /**
     * Thread to send connection request to peer server.
     */
    private class QuorumConnectionReqThread extends ZooKeeperThread {
        final MultipleAddresses electionAddr;
        final Long sid;
<span class="nc" id="L449">        QuorumConnectionReqThread(final MultipleAddresses electionAddr, final Long sid) {</span>
<span class="nc" id="L450">            super(&quot;QuorumConnectionReqThread-&quot; + sid);</span>
<span class="nc" id="L451">            this.electionAddr = electionAddr;</span>
<span class="nc" id="L452">            this.sid = sid;</span>
<span class="nc" id="L453">        }</span>

        @Override
        public void run() {
            try {
<span class="nc" id="L458">                initiateConnection(electionAddr, sid);</span>
            } finally {
<span class="nc" id="L460">                inprogressConnections.remove(sid);</span>
            }
<span class="nc" id="L462">        }</span>

    }

    private boolean startConnection(Socket sock, Long sid) throws IOException {
<span class="nc" id="L467">        DataOutputStream dout = null;</span>
<span class="nc" id="L468">        DataInputStream din = null;</span>
<span class="nc" id="L469">        LOG.debug(&quot;startConnection (myId:{} --&gt; sid:{})&quot;, self.getId(), sid);</span>
        try {
            // Use BufferedOutputStream to reduce the number of IP packets. This is
            // important for x-DC scenarios.
<span class="nc" id="L473">            BufferedOutputStream buf = new BufferedOutputStream(sock.getOutputStream());</span>
<span class="nc" id="L474">            dout = new DataOutputStream(buf);</span>

            // Sending id and challenge

            // First sending the protocol version (in other words - message type).
            // For backward compatibility reasons we stick to the old protocol version, unless the MultiAddress
            // feature is enabled. During rolling upgrade, we must make sure that all the servers can
            // understand the protocol version we use to avoid multiple partitions. see ZOOKEEPER-3720
<span class="nc bnc" id="L482" title="All 2 branches missed.">            long protocolVersion = self.isMultiAddressEnabled() ? PROTOCOL_VERSION_V2 : PROTOCOL_VERSION_V1;</span>
<span class="nc" id="L483">            dout.writeLong(protocolVersion);</span>
<span class="nc" id="L484">            dout.writeLong(self.getId());</span>

            // now we send our election address. For the new protocol version, we can send multiple addresses.
<span class="nc bnc" id="L487" title="All 2 branches missed.">            Collection&lt;InetSocketAddress&gt; addressesToSend = protocolVersion == PROTOCOL_VERSION_V2</span>
<span class="nc" id="L488">                    ? self.getElectionAddress().getAllAddresses()</span>
<span class="nc" id="L489">                    : Arrays.asList(self.getElectionAddress().getOne());</span>

<span class="nc" id="L491">            String addr = addressesToSend.stream()</span>
<span class="nc" id="L492">                    .map(NetUtils::formatInetAddr).collect(Collectors.joining(&quot;|&quot;));</span>
<span class="nc" id="L493">            byte[] addr_bytes = addr.getBytes();</span>
<span class="nc" id="L494">            dout.writeInt(addr_bytes.length);</span>
<span class="nc" id="L495">            dout.write(addr_bytes);</span>
<span class="nc" id="L496">            dout.flush();</span>

<span class="nc" id="L498">            din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));</span>
<span class="nc" id="L499">        } catch (IOException e) {</span>
<span class="nc" id="L500">            LOG.warn(&quot;Ignoring exception reading or writing challenge: &quot;, e);</span>
<span class="nc" id="L501">            closeSocket(sock);</span>
<span class="nc" id="L502">            return false;</span>
<span class="nc" id="L503">        }</span>

        // authenticate learner
<span class="nc" id="L506">        QuorumPeer.QuorumServer qps = self.getVotingView().get(sid);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (qps != null) {</span>
            // TODO - investigate why reconfig makes qps null.
<span class="nc" id="L509">            authLearner.authenticate(sock, qps.hostname);</span>
        }

        // If lost the challenge, then drop the new connection
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (sid &gt; self.getId()) {</span>
<span class="nc" id="L514">            LOG.info(&quot;Have smaller server identifier, so dropping the connection: (myId:{} --&gt; sid:{})&quot;, self.getId(), sid);</span>
<span class="nc" id="L515">            closeSocket(sock);</span>
            // Otherwise proceed with the connection
        } else {
<span class="nc" id="L518">            LOG.debug(&quot;Have larger server identifier, so keeping the connection: (myId:{} --&gt; sid:{})&quot;, self.getId(), sid);</span>
<span class="nc" id="L519">            SendWorker sw = new SendWorker(sock, sid);</span>
<span class="nc" id="L520">            RecvWorker rw = new RecvWorker(sock, din, sid, sw);</span>
<span class="nc" id="L521">            sw.setRecv(rw);</span>

<span class="nc" id="L523">            SendWorker vsw = senderWorkerMap.get(sid);</span>

<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (vsw != null) {</span>
<span class="nc" id="L526">                vsw.finish();</span>
            }

<span class="nc" id="L529">            senderWorkerMap.put(sid, sw);</span>

<span class="nc" id="L531">            queueSendMap.putIfAbsent(sid, new CircularBlockingQueue&lt;&gt;(SEND_CAPACITY));</span>

<span class="nc" id="L533">            sw.start();</span>
<span class="nc" id="L534">            rw.start();</span>

<span class="nc" id="L536">            return true;</span>

        }
<span class="nc" id="L539">        return false;</span>
    }

    /**
     * If this server receives a connection request, then it gives up on the new
     * connection if it wins. Notice that it checks whether it has a connection
     * to this server already or not. If it does, then it sends the smallest
     * possible long value to lose the challenge.
     *
     */
    public void receiveConnection(final Socket sock) {
<span class="nc" id="L550">        DataInputStream din = null;</span>
        try {
<span class="nc" id="L552">            din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));</span>

<span class="nc" id="L554">            LOG.debug(&quot;Sync handling of connection request received from: {}&quot;, sock.getRemoteSocketAddress());</span>
<span class="nc" id="L555">            handleConnection(sock, din);</span>
<span class="nc" id="L556">        } catch (IOException e) {</span>
<span class="nc" id="L557">            LOG.error(&quot;Exception handling connection, addr: {}, closing server connection&quot;, sock.getRemoteSocketAddress());</span>
<span class="nc" id="L558">            LOG.debug(&quot;Exception details: &quot;, e);</span>
<span class="nc" id="L559">            closeSocket(sock);</span>
<span class="nc" id="L560">        }</span>
<span class="nc" id="L561">    }</span>

    /**
     * Server receives a connection request and handles it asynchronously via
     * separate thread.
     */
    public void receiveConnectionAsync(final Socket sock) {
        try {
<span class="nc" id="L569">            LOG.debug(&quot;Async handling of connection request received from: {}&quot;, sock.getRemoteSocketAddress());</span>
<span class="nc" id="L570">            connectionExecutor.execute(new QuorumConnectionReceiverThread(sock));</span>
<span class="nc" id="L571">            connectionThreadCnt.incrementAndGet();</span>
<span class="nc" id="L572">        } catch (Throwable e) {</span>
<span class="nc" id="L573">            LOG.error(&quot;Exception handling connection, addr: {}, closing server connection&quot;, sock.getRemoteSocketAddress());</span>
<span class="nc" id="L574">            LOG.debug(&quot;Exception details: &quot;, e);</span>
<span class="nc" id="L575">            closeSocket(sock);</span>
<span class="nc" id="L576">        }</span>
<span class="nc" id="L577">    }</span>

    /**
     * Thread to receive connection request from peer server.
     */
    private class QuorumConnectionReceiverThread extends ZooKeeperThread {

        private final Socket sock;
<span class="nc" id="L585">        QuorumConnectionReceiverThread(final Socket sock) {</span>
<span class="nc" id="L586">            super(&quot;QuorumConnectionReceiverThread-&quot; + sock.getRemoteSocketAddress());</span>
<span class="nc" id="L587">            this.sock = sock;</span>
<span class="nc" id="L588">        }</span>

        @Override
        public void run() {
<span class="nc" id="L592">            receiveConnection(sock);</span>
<span class="nc" id="L593">        }</span>

    }

    private void handleConnection(Socket sock, DataInputStream din) throws IOException {
<span class="nc" id="L598">        Long sid = null, protocolVersion = null;</span>
<span class="nc" id="L599">        MultipleAddresses electionAddr = null;</span>

        try {
<span class="nc" id="L602">            protocolVersion = din.readLong();</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">            if (protocolVersion &gt;= 0) { // this is a server id and not a protocol version</span>
<span class="nc" id="L604">                sid = protocolVersion;</span>
            } else {
                try {
<span class="nc" id="L607">                    InitialMessage init = InitialMessage.parse(protocolVersion, din);</span>
<span class="nc" id="L608">                    sid = init.sid;</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                    if (!init.electionAddr.isEmpty()) {</span>
<span class="nc" id="L610">                        electionAddr = new MultipleAddresses(init.electionAddr,</span>
<span class="nc" id="L611">                                Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));</span>
                    }
<span class="nc" id="L613">                    LOG.debug(&quot;Initial message parsed by {}: {}&quot;, self.getId(), init.toString());</span>
<span class="nc" id="L614">                } catch (InitialMessage.InitialMessageException ex) {</span>
<span class="nc" id="L615">                    LOG.error(&quot;Initial message parsing error!&quot;, ex);</span>
<span class="nc" id="L616">                    closeSocket(sock);</span>
<span class="nc" id="L617">                    return;</span>
<span class="nc" id="L618">                }</span>
            }

<span class="nc bnc" id="L621" title="All 2 branches missed.">            if (sid == QuorumPeer.OBSERVER_ID) {</span>
                /*
                 * Choose identifier at random. We need a value to identify
                 * the connection.
                 */
<span class="nc" id="L626">                sid = observerCounter.getAndDecrement();</span>
<span class="nc" id="L627">                LOG.info(&quot;Setting arbitrary identifier to observer: {}&quot;, sid);</span>
            }
<span class="nc" id="L629">        } catch (IOException e) {</span>
<span class="nc" id="L630">            LOG.warn(&quot;Exception reading or writing challenge&quot;, e);</span>
<span class="nc" id="L631">            closeSocket(sock);</span>
<span class="nc" id="L632">            return;</span>
<span class="nc" id="L633">        }</span>

        // do authenticating learner
<span class="nc" id="L636">        authServer.authenticate(sock, din);</span>
        //If wins the challenge, then close the new connection.
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if (sid &lt; self.getId()) {</span>
            /*
             * This replica might still believe that the connection to sid is
             * up, so we have to shut down the workers before trying to open a
             * new connection.
             */
<span class="nc" id="L644">            SendWorker sw = senderWorkerMap.get(sid);</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">            if (sw != null) {</span>
<span class="nc" id="L646">                sw.finish();</span>
            }

            /*
             * Now we start a new connection
             */
<span class="nc" id="L652">            LOG.debug(&quot;Create new connection to server: {}&quot;, sid);</span>
<span class="nc" id="L653">            closeSocket(sock);</span>

<span class="nc bnc" id="L655" title="All 2 branches missed.">            if (electionAddr != null) {</span>
<span class="nc" id="L656">                connectOne(sid, electionAddr);</span>
            } else {
<span class="nc" id="L658">                connectOne(sid);</span>
            }

<span class="nc bnc" id="L661" title="All 2 branches missed.">        } else if (sid == self.getId()) {</span>
            // we saw this case in ZOOKEEPER-2164
<span class="nc" id="L663">            LOG.warn(&quot;We got a connection request from a server with our own ID. &quot;</span>
                     + &quot;This should be either a configuration error, or a bug.&quot;);
        } else { // Otherwise start worker threads to receive data.
<span class="nc" id="L666">            SendWorker sw = new SendWorker(sock, sid);</span>
<span class="nc" id="L667">            RecvWorker rw = new RecvWorker(sock, din, sid, sw);</span>
<span class="nc" id="L668">            sw.setRecv(rw);</span>

<span class="nc" id="L670">            SendWorker vsw = senderWorkerMap.get(sid);</span>

<span class="nc bnc" id="L672" title="All 2 branches missed.">            if (vsw != null) {</span>
<span class="nc" id="L673">                vsw.finish();</span>
            }

<span class="nc" id="L676">            senderWorkerMap.put(sid, sw);</span>

<span class="nc" id="L678">            queueSendMap.putIfAbsent(sid, new CircularBlockingQueue&lt;&gt;(SEND_CAPACITY));</span>

<span class="nc" id="L680">            sw.start();</span>
<span class="nc" id="L681">            rw.start();</span>
        }
<span class="nc" id="L683">    }</span>

    /**
     * Processes invoke this message to queue a message to send. Currently,
     * only leader election uses it.
     */
    public void toSend(Long sid, ByteBuffer b) {
        /*
         * If sending message to myself, then simply enqueue it (loopback).
         */
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (this.mySid == sid) {</span>
<span class="nc" id="L694">            b.position(0);</span>
<span class="nc" id="L695">            addToRecvQueue(new Message(b.duplicate(), sid));</span>
            /*
             * Otherwise send to the corresponding thread to send.
             */
        } else {
            /*
             * Start a new connection if doesn't have one already.
             */
<span class="nc" id="L703">            BlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.computeIfAbsent(sid, serverId -&gt; new CircularBlockingQueue&lt;&gt;(SEND_CAPACITY));</span>
<span class="nc" id="L704">            addToSendQueue(bq, b);</span>
<span class="nc" id="L705">            connectOne(sid);</span>
        }
<span class="nc" id="L707">    }</span>

    /**
     * Try to establish a connection to server with id sid using its electionAddr.
     * The function will return quickly and the connection will be established asynchronously.
     *
     * VisibleForTesting.
     *
     *  @param sid  server id
     *  @return boolean success indication
     */
    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (senderWorkerMap.get(sid) != null) {</span>
<span class="nc" id="L720">            LOG.debug(&quot;There is a connection already for server {}&quot;, sid);</span>
<span class="nc bnc" id="L721" title="All 6 branches missed.">            if (self.isMultiAddressEnabled() &amp;&amp; electionAddr.size() &gt; 1 &amp;&amp; self.isMultiAddressReachabilityCheckEnabled()) {</span>
                // since ZOOKEEPER-3188 we can use multiple election addresses to reach a server. It is possible, that the
                // one we are using is already dead and we need to clean-up, so when we will create a new connection
                // then we will choose an other one, which is actually reachable
<span class="nc" id="L725">                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();</span>
            }
<span class="nc" id="L727">            return true;</span>
        }

        // we are doing connection initiation always asynchronously, since it is possible that
        // the socket connection timeouts or the SSL handshake takes too long and don't want
        // to keep the rest of the connections to wait
<span class="nc" id="L733">        return initiateConnectionAsync(electionAddr, sid);</span>
    }

    /**
     * Try to establish a connection to server with id sid.
     * The function will return quickly and the connection will be established asynchronously.
     *
     *  @param sid  server id
     */
    synchronized void connectOne(long sid) {
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (senderWorkerMap.get(sid) != null) {</span>
<span class="nc" id="L744">            LOG.debug(&quot;There is a connection already for server {}&quot;, sid);</span>
<span class="nc bnc" id="L745" title="All 4 branches missed.">            if (self.isMultiAddressEnabled() &amp;&amp; self.isMultiAddressReachabilityCheckEnabled()) {</span>
                // since ZOOKEEPER-3188 we can use multiple election addresses to reach a server. It is possible, that the
                // one we are using is already dead and we need to clean-up, so when we will create a new connection
                // then we will choose an other one, which is actually reachable
<span class="nc" id="L749">                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();</span>
            }
<span class="nc" id="L751">            return;</span>
        }
<span class="nc" id="L753">        synchronized (self.QV_LOCK) {</span>
<span class="nc" id="L754">            boolean knownId = false;</span>
            // Resolve hostname for the remote server before attempting to
            // connect in case the underlying ip address has changed.
<span class="nc" id="L757">            self.recreateSocketAddresses(sid);</span>
<span class="nc" id="L758">            Map&lt;Long, QuorumPeer.QuorumServer&gt; lastCommittedView = self.getView();</span>
<span class="nc" id="L759">            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();</span>
<span class="nc" id="L760">            Map&lt;Long, QuorumPeer.QuorumServer&gt; lastProposedView = lastSeenQV.getAllMembers();</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">            if (lastCommittedView.containsKey(sid)) {</span>
<span class="nc" id="L762">                knownId = true;</span>
<span class="nc" id="L763">                LOG.debug(&quot;Server {} knows {} already, it is in the lastCommittedView&quot;, self.getId(), sid);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {</span>
<span class="nc" id="L765">                    return;</span>
                }
            }
<span class="nc bnc" id="L768" title="All 2 branches missed.">            if (lastSeenQV != null</span>
<span class="nc bnc" id="L769" title="All 4 branches missed.">                &amp;&amp; lastProposedView.containsKey(sid)</span>
                &amp;&amp; (!knownId
<span class="nc bnc" id="L771" title="All 2 branches missed.">                    || !lastProposedView.get(sid).electionAddr.equals(lastCommittedView.get(sid).electionAddr))) {</span>
<span class="nc" id="L772">                knownId = true;</span>
<span class="nc" id="L773">                LOG.debug(&quot;Server {} knows {} already, it is in the lastProposedView&quot;, self.getId(), sid);</span>

<span class="nc bnc" id="L775" title="All 2 branches missed.">                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {</span>
<span class="nc" id="L776">                    return;</span>
                }
            }
<span class="nc bnc" id="L779" title="All 2 branches missed.">            if (!knownId) {</span>
<span class="nc" id="L780">                LOG.warn(&quot;Invalid server id: {} &quot;, sid);</span>
            }
<span class="nc" id="L782">        }</span>
<span class="nc" id="L783">    }</span>

    /**
     * Try to establish a connection with each server if one
     * doesn't exist.
     */

    public void connectAll() {
        long sid;
<span class="nc bnc" id="L792" title="All 2 branches missed.">        for (Enumeration&lt;Long&gt; en = queueSendMap.keys(); en.hasMoreElements(); ) {</span>
<span class="nc" id="L793">            sid = en.nextElement();</span>
<span class="nc" id="L794">            connectOne(sid);</span>
        }
<span class="nc" id="L796">    }</span>

    /**
     * Check if all queues are empty, indicating that all messages have been delivered.
     */
    boolean haveDelivered() {
<span class="nc bnc" id="L802" title="All 2 branches missed.">        for (BlockingQueue&lt;ByteBuffer&gt; queue : queueSendMap.values()) {</span>
<span class="nc" id="L803">            final int queueSize = queue.size();</span>
<span class="nc" id="L804">            LOG.debug(&quot;Queue size: {}&quot;, queueSize);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">            if (queueSize == 0) {</span>
<span class="nc" id="L806">                return true;</span>
            }
<span class="nc" id="L808">        }</span>

<span class="nc" id="L810">        return false;</span>
    }

    /**
     * Flag that it is time to wrap up all activities and interrupt the listener.
     */
    public void halt() {
<span class="nc" id="L817">        shutdown = true;</span>
<span class="nc" id="L818">        LOG.debug(&quot;Halting listener&quot;);</span>
<span class="nc" id="L819">        listener.halt();</span>

        // Wait for the listener to terminate.
        try {
<span class="nc" id="L823">            listener.join();</span>
<span class="nc" id="L824">        } catch (InterruptedException ex) {</span>
<span class="nc" id="L825">            LOG.warn(&quot;Got interrupted before joining the listener&quot;, ex);</span>
<span class="nc" id="L826">        }</span>
<span class="nc" id="L827">        softHalt();</span>

        // clear data structures used for auth
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (connectionExecutor != null) {</span>
<span class="nc" id="L831">            connectionExecutor.shutdown();</span>
        }
<span class="nc" id="L833">        inprogressConnections.clear();</span>
<span class="nc" id="L834">        resetConnectionThreadCount();</span>
<span class="nc" id="L835">    }</span>

    /**
     * A soft halt simply finishes workers.
     */
    public void softHalt() {
<span class="nc bnc" id="L841" title="All 2 branches missed.">        for (SendWorker sw : senderWorkerMap.values()) {</span>
<span class="nc" id="L842">            LOG.debug(&quot;Server {} is soft-halting sender towards: {}&quot;, self.getId(), sw);</span>
<span class="nc" id="L843">            sw.finish();</span>
<span class="nc" id="L844">        }</span>
<span class="nc" id="L845">    }</span>

    /**
     * Helper method to set socket options.
     *
     * @param sock
     *            Reference to socket
     */
    private void setSockOpts(Socket sock) throws SocketException {
<span class="nc" id="L854">        sock.setTcpNoDelay(true);</span>
<span class="nc" id="L855">        sock.setKeepAlive(tcpKeepAlive);</span>
<span class="nc" id="L856">        sock.setSoTimeout(this.socketTimeout);</span>
<span class="nc" id="L857">    }</span>

    /**
     * Helper method to close a socket.
     *
     * @param sock
     *            Reference to socket
     */
    private void closeSocket(Socket sock) {
<span class="nc bnc" id="L866" title="All 2 branches missed.">        if (sock == null) {</span>
<span class="nc" id="L867">            return;</span>
        }

        try {
<span class="nc" id="L871">            sock.close();</span>
<span class="nc" id="L872">        } catch (IOException ie) {</span>
<span class="nc" id="L873">            LOG.error(&quot;Exception while closing&quot;, ie);</span>
<span class="nc" id="L874">        }</span>
<span class="nc" id="L875">    }</span>

    /**
     * Return number of worker threads
     */
    public long getThreadCount() {
<span class="nc" id="L881">        return threadCnt.get();</span>
    }

    /**
     * Return number of connection processing threads.
     */
    public long getConnectionThreadCount() {
<span class="nc" id="L888">        return connectionThreadCnt.get();</span>
    }

    /**
     * Reset the value of connection processing threads count to zero.
     */
    private void resetConnectionThreadCount() {
<span class="nc" id="L895">        connectionThreadCnt.set(0);</span>
<span class="nc" id="L896">    }</span>

    /**
     * Thread to listen on some ports
     */
    public class Listener extends ZooKeeperThread {

        private static final String ELECTION_PORT_BIND_RETRY = &quot;zookeeper.electionPortBindRetry&quot;;
        private static final int DEFAULT_PORT_BIND_MAX_RETRY = 3;

        private final int portBindMaxRetry;
<span class="nc" id="L907">        private Runnable socketBindErrorHandler = () -&gt; ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_BIND_QUORUM_PORT.getValue());</span>
        private List&lt;ListenerHandler&gt; listenerHandlers;
        private final AtomicBoolean socketException;


<span class="nc" id="L912">        public Listener() {</span>
            // During startup of thread, thread name will be overridden to
            // specific election address
<span class="nc" id="L915">            super(&quot;ListenerThread&quot;);</span>

<span class="nc" id="L917">            socketException = new AtomicBoolean(false);</span>

            // maximum retry count while trying to bind to election port
            // see ZOOKEEPER-3320 for more details
<span class="nc" id="L921">            final Integer maxRetry = Integer.getInteger(ELECTION_PORT_BIND_RETRY,</span>
                    DEFAULT_PORT_BIND_MAX_RETRY);
<span class="nc bnc" id="L923" title="All 2 branches missed.">            if (maxRetry &gt;= 0) {</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                LOG.info(&quot;Election port bind maximum retries is {}&quot;, maxRetry == 0 ? &quot;infinite&quot; : maxRetry);</span>
<span class="nc" id="L925">                portBindMaxRetry = maxRetry;</span>
            } else {
<span class="nc" id="L927">                LOG.info(</span>
                  &quot;'{}' contains invalid value: {}(must be &gt;= 0). Use default value of {} instead.&quot;,
                  ELECTION_PORT_BIND_RETRY,
                  maxRetry,
<span class="nc" id="L931">                  DEFAULT_PORT_BIND_MAX_RETRY);</span>
<span class="nc" id="L932">                portBindMaxRetry = DEFAULT_PORT_BIND_MAX_RETRY;</span>
            }
<span class="nc" id="L934">        }</span>

        /**
         * Change socket bind error handler. Used for testing.
         */
        void setSocketBindErrorHandler(Runnable errorHandler) {
<span class="nc" id="L940">            this.socketBindErrorHandler = errorHandler;</span>
<span class="nc" id="L941">        }</span>

        @Override
        public void run() {
<span class="nc bnc" id="L945" title="All 2 branches missed.">            if (!shutdown) {</span>
<span class="nc" id="L946">                LOG.debug(&quot;Listener thread started, myId: {}&quot;, self.getId());</span>
                Set&lt;InetSocketAddress&gt; addresses;

<span class="nc bnc" id="L949" title="All 2 branches missed.">                if (self.getQuorumListenOnAllIPs()) {</span>
<span class="nc" id="L950">                    addresses = self.getElectionAddress().getWildcardAddresses();</span>
                } else {
<span class="nc" id="L952">                    addresses = self.getElectionAddress().getAllAddresses();</span>
                }

<span class="nc" id="L955">                CountDownLatch latch = new CountDownLatch(addresses.size());</span>
<span class="nc" id="L956">                listenerHandlers = addresses.stream().map(address -&gt;</span>
<span class="nc" id="L957">                                new ListenerHandler(address, self.shouldUsePortUnification(), self.isSslQuorum(), latch))</span>
<span class="nc" id="L958">                        .collect(Collectors.toList());</span>

<span class="nc" id="L960">                final ExecutorService executor = Executors.newFixedThreadPool(addresses.size());</span>
                try {
<span class="nc" id="L962">                    listenerHandlers.forEach(executor::submit);</span>
                } finally {
                    // prevent executor's threads to leak after ListenerHandler tasks complete
<span class="nc" id="L965">                    executor.shutdown();</span>
                }

                try {
<span class="nc" id="L969">                    latch.await();</span>
<span class="nc" id="L970">                } catch (InterruptedException ie) {</span>
<span class="nc" id="L971">                    LOG.error(&quot;Interrupted while sleeping. Ignoring exception&quot;, ie);</span>
                } finally {
                    // Clean up for shutdown.
<span class="nc bnc" id="L974" title="All 2 branches missed.">                    for (ListenerHandler handler : listenerHandlers) {</span>
                        try {
<span class="nc" id="L976">                            handler.close();</span>
<span class="nc" id="L977">                        } catch (IOException ie) {</span>
                            // Don't log an error for shutdown.
<span class="nc" id="L979">                            LOG.debug(&quot;Error closing server socket&quot;, ie);</span>
<span class="nc" id="L980">                        }</span>
<span class="nc" id="L981">                    }</span>
                }
            }

<span class="nc" id="L985">            LOG.info(&quot;Leaving listener&quot;);</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">            if (!shutdown) {</span>
<span class="nc" id="L987">                LOG.error(</span>
                  &quot;As I'm leaving the listener thread, I won't be able to participate in leader election any longer: {}&quot;,
<span class="nc" id="L989">                  self.getElectionAddress().getAllAddresses().stream()</span>
<span class="nc" id="L990">                    .map(NetUtils::formatInetAddr)</span>
<span class="nc" id="L991">                    .collect(Collectors.joining(&quot;|&quot;)));</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">                if (socketException.get()) {</span>
                    // After leaving listener thread, the host cannot join the quorum anymore,
                    // this is a severe error that we cannot recover from, so we need to exit
<span class="nc" id="L995">                    socketBindErrorHandler.run();</span>
                }
            }
<span class="nc" id="L998">        }</span>

        /**
         * Halts this listener thread.
         */
        void halt() {
<span class="nc" id="L1004">            LOG.debug(&quot;Halt called: Trying to close listeners&quot;);</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            if (listenerHandlers != null) {</span>
<span class="nc" id="L1006">                LOG.debug(&quot;Closing listener: {}&quot;, QuorumCnxManager.this.mySid);</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">                for (ListenerHandler handler : listenerHandlers) {</span>
                    try {
<span class="nc" id="L1009">                        handler.close();</span>
<span class="nc" id="L1010">                    } catch (IOException e) {</span>
<span class="nc" id="L1011">                        LOG.warn(&quot;Exception when shutting down listener: &quot;, e);</span>
<span class="nc" id="L1012">                    }</span>
<span class="nc" id="L1013">                }</span>
            }
<span class="nc" id="L1015">        }</span>

        class ListenerHandler implements Runnable, Closeable {
            private ServerSocket serverSocket;
            private InetSocketAddress address;
            private boolean portUnification;
            private boolean sslQuorum;
            private CountDownLatch latch;

            ListenerHandler(InetSocketAddress address, boolean portUnification, boolean sslQuorum,
<span class="nc" id="L1025">                            CountDownLatch latch) {</span>
<span class="nc" id="L1026">                this.address = address;</span>
<span class="nc" id="L1027">                this.portUnification = portUnification;</span>
<span class="nc" id="L1028">                this.sslQuorum = sslQuorum;</span>
<span class="nc" id="L1029">                this.latch = latch;</span>
<span class="nc" id="L1030">            }</span>

            /**
             * Sleeps on acceptConnections().
             */
            @Override
            public void run() {
                try {
<span class="nc" id="L1038">                    Thread.currentThread().setName(&quot;ListenerHandler-&quot; + address);</span>
<span class="nc" id="L1039">                    acceptConnections();</span>
                    try {
<span class="nc" id="L1041">                        close();</span>
<span class="nc" id="L1042">                    } catch (IOException e) {</span>
<span class="nc" id="L1043">                        LOG.warn(&quot;Exception when shutting down listener: &quot;, e);</span>
<span class="nc" id="L1044">                    }</span>
<span class="nc" id="L1045">                } catch (Exception e) {</span>
                    // Output of unexpected exception, should never happen
<span class="nc" id="L1047">                    LOG.error(&quot;Unexpected error &quot;, e);</span>
                } finally {
<span class="nc" id="L1049">                    latch.countDown();</span>
                }
<span class="nc" id="L1051">            }</span>

            @Override
            public synchronized void close() throws IOException {
<span class="nc bnc" id="L1055" title="All 4 branches missed.">                if (serverSocket != null &amp;&amp; !serverSocket.isClosed()) {</span>
<span class="nc" id="L1056">                    LOG.debug(&quot;Trying to close listeners: {}&quot;, serverSocket);</span>
<span class="nc" id="L1057">                    serverSocket.close();</span>
                }
<span class="nc" id="L1059">            }</span>

            /**
             * Sleeps on accept().
             */
            private void acceptConnections() {
<span class="nc" id="L1065">                int numRetries = 0;</span>
<span class="nc" id="L1066">                Socket client = null;</span>

<span class="nc bnc" id="L1068" title="All 6 branches missed.">                while ((!shutdown) &amp;&amp; (portBindMaxRetry == 0 || numRetries &lt; portBindMaxRetry)) {</span>
                    try {
<span class="nc" id="L1070">                        serverSocket = createNewServerSocket();</span>
<span class="nc" id="L1071">                        LOG.info(&quot;{} is accepting connections now, my election bind port: {}&quot;, QuorumCnxManager.this.mySid, address.toString());</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                        while (!shutdown) {</span>
                            try {
<span class="nc" id="L1074">                                client = serverSocket.accept();</span>
<span class="nc" id="L1075">                                setSockOpts(client);</span>
<span class="nc" id="L1076">                                LOG.info(&quot;Received connection request from {}&quot;, client.getRemoteSocketAddress());</span>
                                // Receive and handle the connection request
                                // asynchronously if the quorum sasl authentication is
                                // enabled. This is required because sasl server
                                // authentication process may take few seconds to finish,
                                // this may delay next peer connection requests.
<span class="nc bnc" id="L1082" title="All 2 branches missed.">                                if (quorumSaslAuthEnabled) {</span>
<span class="nc" id="L1083">                                    receiveConnectionAsync(client);</span>
                                } else {
<span class="nc" id="L1085">                                    receiveConnection(client);</span>
                                }
<span class="nc" id="L1087">                                numRetries = 0;</span>
<span class="nc" id="L1088">                            } catch (SocketTimeoutException e) {</span>
<span class="nc" id="L1089">                                LOG.warn(&quot;The socket is listening for the election accepted &quot;</span>
                                        + &quot;and it timed out unexpectedly, but will retry.&quot;
                                        + &quot;see ZOOKEEPER-2836&quot;);
<span class="nc" id="L1092">                            }</span>
                        }
<span class="nc" id="L1094">                    } catch (IOException e) {</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">                        if (shutdown) {</span>
<span class="nc" id="L1096">                            break;</span>
                        }

<span class="nc" id="L1099">                        LOG.error(&quot;Exception while listening&quot;, e);</span>

<span class="nc bnc" id="L1101" title="All 2 branches missed.">                        if (e instanceof SocketException) {</span>
<span class="nc" id="L1102">                            socketException.set(true);</span>
                        }

<span class="nc" id="L1105">                        numRetries++;</span>
                        try {
<span class="nc" id="L1107">                            close();</span>
<span class="nc" id="L1108">                            Thread.sleep(1000);</span>
<span class="nc" id="L1109">                        } catch (IOException ie) {</span>
<span class="nc" id="L1110">                            LOG.error(&quot;Error closing server socket&quot;, ie);</span>
<span class="nc" id="L1111">                        } catch (InterruptedException ie) {</span>
<span class="nc" id="L1112">                            LOG.error(&quot;Interrupted while sleeping. Ignoring exception&quot;, ie);</span>
<span class="nc" id="L1113">                        }</span>
<span class="nc" id="L1114">                        closeSocket(client);</span>
<span class="nc" id="L1115">                    }</span>
                }
<span class="nc bnc" id="L1117" title="All 2 branches missed.">                if (!shutdown) {</span>
<span class="nc" id="L1118">                    LOG.error(</span>
                      &quot;Leaving listener thread for address {} after {} errors. Use {} property to increase retry count.&quot;,
<span class="nc" id="L1120">                      formatInetAddr(address),</span>
<span class="nc" id="L1121">                      numRetries,</span>
                      ELECTION_PORT_BIND_RETRY);
                }
<span class="nc" id="L1124">            }</span>

            private ServerSocket createNewServerSocket() throws IOException {
                ServerSocket socket;

<span class="nc bnc" id="L1129" title="All 2 branches missed.">                if (portUnification) {</span>
<span class="nc" id="L1130">                    LOG.info(&quot;Creating TLS-enabled quorum server socket&quot;);</span>
<span class="nc" id="L1131">                    socket = new UnifiedServerSocket(self.getX509Util(), true);</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">                } else if (sslQuorum) {</span>
<span class="nc" id="L1133">                    LOG.info(&quot;Creating TLS-only quorum server socket&quot;);</span>
<span class="nc" id="L1134">                    socket = new UnifiedServerSocket(self.getX509Util(), false);</span>
                } else {
<span class="nc" id="L1136">                    socket = new ServerSocket();</span>
                }

<span class="nc" id="L1139">                socket.setReuseAddress(true);</span>
<span class="nc" id="L1140">                address = new InetSocketAddress(address.getHostString(), address.getPort());</span>
<span class="nc" id="L1141">                socket.bind(address);</span>

<span class="nc" id="L1143">                return socket;</span>
            }
        }

    }

    /**
     * Thread to send messages. Instance waits on a queue, and send a message as
     * soon as there is one available. If connection breaks, then opens a new
     * one.
     */
    class SendWorker extends ZooKeeperThread {

        Long sid;
        Socket sock;
        RecvWorker recvWorker;
<span class="nc" id="L1159">        volatile boolean running = true;</span>
        DataOutputStream dout;
<span class="nc" id="L1161">        AtomicBoolean ongoingAsyncValidation = new AtomicBoolean(false);</span>

        /**
         * An instance of this thread receives messages to send
         * through a queue and sends them to the server sid.
         *
         * @param sock
         *            Socket to remote peer
         * @param sid
         *            Server identifier of remote peer
         */
<span class="nc" id="L1172">        SendWorker(Socket sock, Long sid) {</span>
<span class="nc" id="L1173">            super(&quot;SendWorker:&quot; + sid);</span>
<span class="nc" id="L1174">            this.sid = sid;</span>
<span class="nc" id="L1175">            this.sock = sock;</span>
<span class="nc" id="L1176">            recvWorker = null;</span>
            try {
<span class="nc" id="L1178">                dout = new DataOutputStream(sock.getOutputStream());</span>
<span class="nc" id="L1179">            } catch (IOException e) {</span>
<span class="nc" id="L1180">                LOG.error(&quot;Unable to access socket output stream&quot;, e);</span>
<span class="nc" id="L1181">                closeSocket(sock);</span>
<span class="nc" id="L1182">                running = false;</span>
<span class="nc" id="L1183">            }</span>
<span class="nc" id="L1184">            LOG.debug(&quot;Address of remote peer: {}&quot;, this.sid);</span>
<span class="nc" id="L1185">        }</span>

        synchronized void setRecv(RecvWorker recvWorker) {
<span class="nc" id="L1188">            this.recvWorker = recvWorker;</span>
<span class="nc" id="L1189">        }</span>

        /**
         * Returns RecvWorker that pairs up with this SendWorker.
         *
         * @return RecvWorker
         */
        synchronized RecvWorker getRecvWorker() {
<span class="nc" id="L1197">            return recvWorker;</span>
        }

        synchronized boolean finish() {
<span class="nc" id="L1201">            LOG.debug(&quot;Calling SendWorker.finish for {}&quot;, sid);</span>

<span class="nc bnc" id="L1203" title="All 2 branches missed.">            if (!running) {</span>
                /*
                 * Avoids running finish() twice.
                 */
<span class="nc" id="L1207">                return running;</span>
            }

<span class="nc" id="L1210">            running = false;</span>
<span class="nc" id="L1211">            closeSocket(sock);</span>

<span class="nc" id="L1213">            this.interrupt();</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">            if (recvWorker != null) {</span>
<span class="nc" id="L1215">                recvWorker.finish();</span>
            }

<span class="nc" id="L1218">            LOG.debug(&quot;Removing entry from senderWorkerMap sid={}&quot;, sid);</span>

<span class="nc" id="L1220">            senderWorkerMap.remove(sid, this);</span>
<span class="nc" id="L1221">            threadCnt.decrementAndGet();</span>
<span class="nc" id="L1222">            return running;</span>
        }

        synchronized void send(ByteBuffer b) throws IOException {
<span class="nc" id="L1226">            byte[] msgBytes = new byte[b.capacity()];</span>
            try {
<span class="nc" id="L1228">                b.position(0);</span>
<span class="nc" id="L1229">                b.get(msgBytes);</span>
<span class="nc" id="L1230">            } catch (BufferUnderflowException be) {</span>
<span class="nc" id="L1231">                LOG.error(&quot;BufferUnderflowException &quot;, be);</span>
<span class="nc" id="L1232">                return;</span>
<span class="nc" id="L1233">            }</span>
<span class="nc" id="L1234">            dout.writeInt(b.capacity());</span>
<span class="nc" id="L1235">            dout.write(b.array());</span>
<span class="nc" id="L1236">            dout.flush();</span>
<span class="nc" id="L1237">        }</span>

        @Override
        public void run() {
<span class="nc" id="L1241">            threadCnt.incrementAndGet();</span>
            try {
                /**
                 * If there is nothing in the queue to send, then we
                 * send the lastMessage to ensure that the last message
                 * was received by the peer. The message could be dropped
                 * in case self or the peer shutdown their connection
                 * (and exit the thread) prior to reading/processing
                 * the last message. Duplicate messages are handled correctly
                 * by the peer.
                 *
                 * If the send queue is non-empty, then we have a recent
                 * message than that stored in lastMessage. To avoid sending
                 * stale message, we should send the message in the send queue.
                 */
<span class="nc" id="L1256">                BlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);</span>
<span class="nc bnc" id="L1257" title="All 4 branches missed.">                if (bq == null || isSendQueueEmpty(bq)) {</span>
<span class="nc" id="L1258">                    ByteBuffer b = lastMessageSent.get(sid);</span>
<span class="nc bnc" id="L1259" title="All 2 branches missed.">                    if (b != null) {</span>
<span class="nc" id="L1260">                        LOG.debug(&quot;Attempting to send lastMessage to sid={}&quot;, sid);</span>
<span class="nc" id="L1261">                        send(b);</span>
                    }
                }
<span class="nc" id="L1264">            } catch (IOException e) {</span>
<span class="nc" id="L1265">                LOG.error(&quot;Failed to send last message. Shutting down thread.&quot;, e);</span>
<span class="nc" id="L1266">                this.finish();</span>
<span class="nc" id="L1267">            }</span>
<span class="nc" id="L1268">            LOG.debug(&quot;SendWorker thread started towards {}. myId: {}&quot;, sid, QuorumCnxManager.this.mySid);</span>

            try {
<span class="nc bnc" id="L1271" title="All 6 branches missed.">                while (running &amp;&amp; !shutdown &amp;&amp; sock != null) {</span>

<span class="nc" id="L1273">                    ByteBuffer b = null;</span>
                    try {
<span class="nc" id="L1275">                        BlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                        if (bq != null) {</span>
<span class="nc" id="L1277">                            b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);</span>
                        } else {
<span class="nc" id="L1279">                            LOG.error(&quot;No queue of incoming messages for server {}&quot;, sid);</span>
<span class="nc" id="L1280">                            break;</span>
                        }

<span class="nc bnc" id="L1283" title="All 2 branches missed.">                        if (b != null) {</span>
<span class="nc" id="L1284">                            lastMessageSent.put(sid, b);</span>
<span class="nc" id="L1285">                            send(b);</span>
                        }
<span class="nc" id="L1287">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L1288">                        LOG.warn(&quot;Interrupted while waiting for message on queue&quot;, e);</span>
<span class="nc" id="L1289">                    }</span>
<span class="nc" id="L1290">                }</span>
<span class="nc" id="L1291">            } catch (Exception e) {</span>
<span class="nc" id="L1292">                LOG.warn(</span>
                    &quot;Exception when using channel: for id {} my id = {}&quot;,
                    sid ,
<span class="nc" id="L1295">                    QuorumCnxManager.this.mySid,</span>
                    e);
<span class="nc" id="L1297">            }</span>
<span class="nc" id="L1298">            this.finish();</span>

<span class="nc" id="L1300">            LOG.warn(&quot;Send worker leaving thread id {} my id = {}&quot;, sid, self.getId());</span>
<span class="nc" id="L1301">        }</span>


        public void asyncValidateIfSocketIsStillReachable() {
<span class="nc bnc" id="L1305" title="All 2 branches missed.">            if (ongoingAsyncValidation.compareAndSet(false, true)) {</span>
<span class="nc" id="L1306">                new Thread(() -&gt; {</span>
<span class="nc" id="L1307">                    LOG.debug(&quot;validate if destination address is reachable for sid {}&quot;, sid);</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">                    if (sock != null) {</span>
<span class="nc" id="L1309">                        InetAddress address = sock.getInetAddress();</span>
                        try {
<span class="nc bnc" id="L1311" title="All 2 branches missed.">                            if (address.isReachable(500)) {</span>
<span class="nc" id="L1312">                                LOG.debug(&quot;destination address {} is reachable for sid {}&quot;, address.toString(), sid);</span>
<span class="nc" id="L1313">                                ongoingAsyncValidation.set(false);</span>
<span class="nc" id="L1314">                                return;</span>
                            }
<span class="nc" id="L1316">                        } catch (NullPointerException | IOException ignored) {</span>
<span class="nc" id="L1317">                        }</span>
<span class="nc" id="L1318">                        LOG.warn(</span>
                          &quot;destination address {} not reachable anymore, shutting down the SendWorker for sid {}&quot;,
<span class="nc" id="L1320">                          address.toString(),</span>
                          sid);
<span class="nc" id="L1322">                        this.finish();</span>
                    }
<span class="nc" id="L1324">                }).start();</span>
            } else {
<span class="nc" id="L1326">                LOG.debug(&quot;validation of destination address for sid {} is skipped (it is already running)&quot;, sid);</span>
            }
<span class="nc" id="L1328">        }</span>

    }

    /**
     * Thread to receive messages. Instance waits on a socket read. If the
     * channel breaks, then removes itself from the pool of receivers.
     */
    class RecvWorker extends ZooKeeperThread {

        Long sid;
        Socket sock;
<span class="nc" id="L1340">        volatile boolean running = true;</span>
        final DataInputStream din;
        final SendWorker sw;

<span class="nc" id="L1344">        RecvWorker(Socket sock, DataInputStream din, Long sid, SendWorker sw) {</span>
<span class="nc" id="L1345">            super(&quot;RecvWorker:&quot; + sid);</span>
<span class="nc" id="L1346">            this.sid = sid;</span>
<span class="nc" id="L1347">            this.sock = sock;</span>
<span class="nc" id="L1348">            this.sw = sw;</span>
<span class="nc" id="L1349">            this.din = din;</span>
            try {
                // OK to wait until socket disconnects while reading.
<span class="nc" id="L1352">                sock.setSoTimeout(0);</span>
<span class="nc" id="L1353">            } catch (IOException e) {</span>
<span class="nc" id="L1354">                LOG.error(&quot;Error while accessing socket for {}&quot;, sid, e);</span>
<span class="nc" id="L1355">                closeSocket(sock);</span>
<span class="nc" id="L1356">                running = false;</span>
<span class="nc" id="L1357">            }</span>
<span class="nc" id="L1358">        }</span>

        /**
         * Shuts down this worker
         *
         * @return boolean  Value of variable running
         */
        synchronized boolean finish() {
<span class="nc" id="L1366">            LOG.debug(&quot;RecvWorker.finish called. sid: {}. myId: {}&quot;, sid, QuorumCnxManager.this.mySid);</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">            if (!running) {</span>
                /*
                 * Avoids running finish() twice.
                 */
<span class="nc" id="L1371">                return running;</span>
            }
<span class="nc" id="L1373">            running = false;</span>

<span class="nc" id="L1375">            this.interrupt();</span>
<span class="nc" id="L1376">            threadCnt.decrementAndGet();</span>
<span class="nc" id="L1377">            return running;</span>
        }

        @Override
        public void run() {
<span class="nc" id="L1382">            threadCnt.incrementAndGet();</span>
            try {
<span class="nc" id="L1384">                LOG.debug(&quot;RecvWorker thread towards {} started. myId: {}&quot;, sid, QuorumCnxManager.this.mySid);</span>
<span class="nc bnc" id="L1385" title="All 6 branches missed.">                while (running &amp;&amp; !shutdown &amp;&amp; sock != null) {</span>
                    /**
                     * Reads the first int to determine the length of the
                     * message
                     */
<span class="nc" id="L1390">                    int length = din.readInt();</span>
<span class="nc bnc" id="L1391" title="All 4 branches missed.">                    if (length &lt;= 0 || length &gt; PACKETMAXSIZE) {</span>
<span class="nc" id="L1392">                        throw new IOException(&quot;Received packet with invalid packet: &quot; + length);</span>
                    }
                    /**
                     * Allocates a new ByteBuffer to receive the message
                     */
<span class="nc" id="L1397">                    final byte[] msgArray = new byte[length];</span>
<span class="nc" id="L1398">                    din.readFully(msgArray, 0, length);</span>
<span class="nc" id="L1399">                    addToRecvQueue(new Message(ByteBuffer.wrap(msgArray), sid));</span>
<span class="nc" id="L1400">                }</span>
<span class="nc" id="L1401">            } catch (Exception e) {</span>
<span class="nc" id="L1402">                LOG.warn(</span>
                    &quot;Connection broken for id {}, my id = {}&quot;,
                    sid,
<span class="nc" id="L1405">                    QuorumCnxManager.this.mySid,</span>
                    e);
            } finally {
<span class="nc" id="L1408">                LOG.warn(&quot;Interrupting SendWorker thread from RecvWorker. sid: {}. myId: {}&quot;, sid, QuorumCnxManager.this.mySid);</span>
<span class="nc" id="L1409">                sw.finish();</span>
<span class="nc" id="L1410">                closeSocket(sock);</span>
            }
<span class="nc" id="L1412">        }</span>

    }

    /**
     * Inserts an element in the provided {@link BlockingQueue}. This method
     * assumes that if the Queue is full, an element from the head of the Queue is
     * removed and the new item is inserted at the tail of the queue. This is done
     * to prevent a thread from blocking while inserting an element in the queue.
     *
     * @param queue Reference to the Queue
     * @param buffer Reference to the buffer to be inserted in the queue
     */
    private void addToSendQueue(final BlockingQueue&lt;ByteBuffer&gt; queue,
        final ByteBuffer buffer) {
<span class="nc" id="L1427">        final boolean success = queue.offer(buffer);</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">        if (!success) {</span>
<span class="nc" id="L1429">          throw new RuntimeException(&quot;Could not insert into receive queue&quot;);</span>
        }
<span class="nc" id="L1431">    }</span>

    /**
     * Returns true if queue is empty.
     * @param queue
     *          Reference to the queue
     * @return
     *      true if the specified queue is empty
     */
    private boolean isSendQueueEmpty(final BlockingQueue&lt;ByteBuffer&gt; queue) {
<span class="nc" id="L1441">        return queue.isEmpty();</span>
    }

    /**
     * Retrieves and removes buffer at the head of this queue,
     * waiting up to the specified wait time if necessary for an element to
     * become available.
     *
     * {@link BlockingQueue#poll(long, java.util.concurrent.TimeUnit)}
     */
    private ByteBuffer pollSendQueue(final BlockingQueue&lt;ByteBuffer&gt; queue,
          final long timeout, final TimeUnit unit) throws InterruptedException {
<span class="nc" id="L1453">       return queue.poll(timeout, unit);</span>
    }

    /**
     * Inserts an element in the {@link #recvQueue}. If the Queue is full, this
     * methods removes an element from the head of the Queue and then inserts the
     * element at the tail of the queue.
     *
     * @param msg Reference to the message to be inserted in the queue
     */
    public void addToRecvQueue(final Message msg) {
<span class="nc" id="L1464">      final boolean success = this.recvQueue.offer(msg);</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">      if (!success) {</span>
<span class="nc" id="L1466">          throw new RuntimeException(&quot;Could not insert into receive queue&quot;);</span>
      }
<span class="nc" id="L1468">    }</span>

    /**
     * Retrieves and removes a message at the head of this queue,
     * waiting up to the specified wait time if necessary for an element to
     * become available.
     *
     * {@link BlockingQueue#poll(long, java.util.concurrent.TimeUnit)}
     */
    public Message pollRecvQueue(final long timeout, final TimeUnit unit)
       throws InterruptedException {
<span class="nc" id="L1479">       return this.recvQueue.poll(timeout, unit);</span>
    }

    public boolean connectedToPeer(long peerSid) {
<span class="nc bnc" id="L1483" title="All 2 branches missed.">        return senderWorkerMap.get(peerSid) != null;</span>
    }

    public boolean isReconfigEnabled() {
<span class="nc" id="L1487">        return self.isReconfigEnabled();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>