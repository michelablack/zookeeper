<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Observer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server.quorum</a> &gt; <span class="el_source">Observer.java</span></div><h1>Observer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server.quorum;

import static java.nio.charset.StandardCharsets.UTF_8;
import java.nio.ByteBuffer;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicReference;
import org.apache.jute.Record;
import org.apache.zookeeper.common.Time;
import org.apache.zookeeper.server.ObserverBean;
import org.apache.zookeeper.server.Request;
import org.apache.zookeeper.server.ServerMetrics;
import org.apache.zookeeper.server.TxnLogEntry;
import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
import org.apache.zookeeper.server.util.SerializeUtils;
import org.apache.zookeeper.txn.SetDataTxn;
import org.apache.zookeeper.txn.TxnDigest;
import org.apache.zookeeper.txn.TxnHeader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Observers are peers that do not take part in the atomic broadcast protocol.
 * Instead, they are informed of successful proposals by the Leader. Observers
 * therefore naturally act as a relay point for publishing the proposal stream
 * and can relieve Followers of some of the connection load. Observers may
 * submit proposals, but do not vote in their acceptance.
 *
 * See ZOOKEEPER-368 for a discussion of this feature.
 */
public class Observer extends Learner {

<span class="nc" id="L51">    private static final Logger LOG = LoggerFactory.getLogger(Observer.class);</span>

    /**
     * When observer lost its connection with the leader, it waits for 0 to the
     * specified value before trying to reconnect with the leader. So that
     * the entire observer fleet won't try to run leader election and reconnect
     * to the leader at once. Default value is zero.
     */
    public static final String OBSERVER_RECONNECT_DELAY_MS = &quot;zookeeper.observer.reconnectDelayMs&quot;;

    /**
     * Delay the Observer's participation in a leader election upon disconnect
     * so as to prevent unexpected additional load on the voting peers during
     * the process. Default value is 200.
     */
    public static final String OBSERVER_ELECTION_DELAY_MS = &quot;zookeeper.observer.election.DelayMs&quot;;

    private static final long reconnectDelayMs;

    private static volatile long observerElectionDelayMs;

    static {
<span class="nc" id="L73">        reconnectDelayMs = Long.getLong(OBSERVER_RECONNECT_DELAY_MS, 0);</span>
<span class="nc" id="L74">        LOG.info(&quot;{} = {}&quot;, OBSERVER_RECONNECT_DELAY_MS, reconnectDelayMs);</span>
<span class="nc" id="L75">        observerElectionDelayMs = Long.getLong(OBSERVER_ELECTION_DELAY_MS, 200);</span>
<span class="nc" id="L76">        LOG.info(&quot;{} = {}&quot;, OBSERVER_ELECTION_DELAY_MS , observerElectionDelayMs);</span>
    }

    /**
     * next learner master to try, when specified
     */
<span class="nc" id="L82">    private static final AtomicReference&lt;QuorumPeer.QuorumServer&gt; nextLearnerMaster = new AtomicReference&lt;&gt;();</span>

<span class="nc" id="L84">    private QuorumPeer.QuorumServer currentLearnerMaster = null;</span>

<span class="nc" id="L86">    Observer(QuorumPeer self, ObserverZooKeeperServer observerZooKeeperServer) {</span>
<span class="nc" id="L87">        this.self = self;</span>
<span class="nc" id="L88">        this.zk = observerZooKeeperServer;</span>
<span class="nc" id="L89">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L93">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L94">        sb.append(&quot;Observer &quot;).append(sock);</span>
<span class="nc" id="L95">        sb.append(&quot; pendingRevalidationCount:&quot;).append(pendingRevalidations.size());</span>
<span class="nc" id="L96">        return sb.toString();</span>
    }

    /**
     * the main method called by the observer to observe the leader
     * @throws Exception
     */
    void observeLeader() throws Exception {
<span class="nc" id="L104">        zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);</span>
<span class="nc" id="L105">        long connectTime = 0;</span>
<span class="nc" id="L106">        boolean completedSync = false;</span>
        try {
<span class="nc" id="L108">            self.setZabState(QuorumPeer.ZabState.DISCOVERY);</span>
<span class="nc" id="L109">            QuorumServer master = findLearnerMaster();</span>
            try {
<span class="nc" id="L111">                connectToLeader(master.addr, master.hostname);</span>
<span class="nc" id="L112">                connectTime = System.currentTimeMillis();</span>
<span class="nc" id="L113">                long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">                if (self.isReconfigStateChange()) {</span>
<span class="nc" id="L115">                    throw new Exception(&quot;learned about role change&quot;);</span>
                }

<span class="nc" id="L118">                final long startTime = Time.currentElapsedTime();</span>
<span class="nc" id="L119">                self.setLeaderAddressAndId(master.addr, master.getId());</span>
<span class="nc" id="L120">                self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);</span>
<span class="nc" id="L121">                syncWithLeader(newLeaderZxid);</span>
<span class="nc" id="L122">                self.setZabState(QuorumPeer.ZabState.BROADCAST);</span>
<span class="nc" id="L123">                completedSync = true;</span>
<span class="nc" id="L124">                final long syncTime = Time.currentElapsedTime() - startTime;</span>
<span class="nc" id="L125">                ServerMetrics.getMetrics().OBSERVER_SYNC_TIME.add(syncTime);</span>
<span class="nc" id="L126">                QuorumPacket qp = new QuorumPacket();</span>
<span class="nc bnc" id="L127" title="All 4 branches missed.">                while (this.isRunning() &amp;&amp; nextLearnerMaster.get() == null) {</span>
<span class="nc" id="L128">                    readPacket(qp);</span>
<span class="nc" id="L129">                    processPacket(qp);</span>
                }
<span class="nc" id="L131">            } catch (Exception e) {</span>
<span class="nc" id="L132">                LOG.warn(&quot;Exception when observing the leader&quot;, e);</span>
<span class="nc" id="L133">                closeSocket();</span>

                // clear pending revalidations
<span class="nc" id="L136">                pendingRevalidations.clear();</span>
<span class="nc" id="L137">            }</span>
        } finally {
<span class="nc" id="L139">            currentLearnerMaster = null;</span>
<span class="nc" id="L140">            zk.unregisterJMX(this);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (connectTime != 0) {</span>
<span class="nc" id="L142">                long connectionDuration = System.currentTimeMillis() - connectTime;</span>

<span class="nc" id="L144">                LOG.info(</span>
                    &quot;Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}&quot;,
                    leaderAddr,
<span class="nc" id="L147">                    connectionDuration,</span>
<span class="nc" id="L148">                    completedSync);</span>
<span class="nc" id="L149">                messageTracker.dumpToLog(leaderAddr.toString());</span>
            }
        }
<span class="nc" id="L152">    }</span>

    private QuorumServer findLearnerMaster() {
<span class="nc" id="L155">        QuorumPeer.QuorumServer prescribedLearnerMaster = nextLearnerMaster.getAndSet(null);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (prescribedLearnerMaster != null</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            &amp;&amp; self.validateLearnerMaster(Long.toString(prescribedLearnerMaster.id)) == null) {</span>
<span class="nc" id="L158">            LOG.warn(&quot;requested next learner master {} is no longer valid&quot;, prescribedLearnerMaster);</span>
<span class="nc" id="L159">            prescribedLearnerMaster = null;</span>
        }
<span class="nc bnc" id="L161" title="All 2 branches missed.">        final QuorumPeer.QuorumServer master = (prescribedLearnerMaster == null)</span>
<span class="nc" id="L162">            ? self.findLearnerMaster(findLeader())</span>
<span class="nc" id="L163">            : prescribedLearnerMaster;</span>
<span class="nc" id="L164">        currentLearnerMaster = master;</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (master == null) {</span>
<span class="nc" id="L166">            LOG.warn(&quot;No learner master found&quot;);</span>
        } else {
<span class="nc" id="L168">            LOG.info(&quot;Observing new leader sid={} addr={}&quot;, master.id, master.addr);</span>
        }
<span class="nc" id="L170">        return master;</span>
    }

    /**
     * Controls the response of an observer to the receipt of a quorumpacket
     * @param qp
     * @throws Exception
     */
    protected void processPacket(QuorumPacket qp) throws Exception {
        TxnLogEntry logEntry;
        TxnHeader hdr;
        TxnDigest digest;
        Record txn;
<span class="nc bnc" id="L183" title="All 9 branches missed.">        switch (qp.getType()) {</span>
        case Leader.PING:
<span class="nc" id="L185">            ping(qp);</span>
<span class="nc" id="L186">            break;</span>
        case Leader.PROPOSAL:
<span class="nc" id="L188">            LOG.warn(&quot;Ignoring proposal&quot;);</span>
<span class="nc" id="L189">            break;</span>
        case Leader.COMMIT:
<span class="nc" id="L191">            LOG.warn(&quot;Ignoring commit&quot;);</span>
<span class="nc" id="L192">            break;</span>
        case Leader.UPTODATE:
<span class="nc" id="L194">            LOG.error(&quot;Received an UPTODATE message after Observer started&quot;);</span>
<span class="nc" id="L195">            break;</span>
        case Leader.REVALIDATE:
<span class="nc" id="L197">            revalidate(qp);</span>
<span class="nc" id="L198">            break;</span>
        case Leader.SYNC:
<span class="nc" id="L200">            ((ObserverZooKeeperServer) zk).sync();</span>
<span class="nc" id="L201">            break;</span>
        case Leader.INFORM:
<span class="nc" id="L203">            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);</span>
<span class="nc" id="L204">            logEntry = SerializeUtils.deserializeTxn(qp.getData());</span>
<span class="nc" id="L205">            hdr = logEntry.getHeader();</span>
<span class="nc" id="L206">            txn = logEntry.getTxn();</span>
<span class="nc" id="L207">            digest = logEntry.getDigest();</span>
<span class="nc" id="L208">            Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);</span>
<span class="nc" id="L209">            request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);</span>
<span class="nc" id="L210">            request.setTxnDigest(digest);</span>
<span class="nc" id="L211">            ObserverZooKeeperServer obs = (ObserverZooKeeperServer) zk;</span>
<span class="nc" id="L212">            obs.commitRequest(request);</span>
<span class="nc" id="L213">            break;</span>
        case Leader.INFORMANDACTIVATE:
            // get new designated leader from (current) leader's message
<span class="nc" id="L216">            ByteBuffer buffer = ByteBuffer.wrap(qp.getData());</span>
<span class="nc" id="L217">            long suggestedLeaderId = buffer.getLong();</span>

<span class="nc" id="L219">            byte[] remainingdata = new byte[buffer.remaining()];</span>
<span class="nc" id="L220">            buffer.get(remainingdata);</span>
<span class="nc" id="L221">            logEntry = SerializeUtils.deserializeTxn(remainingdata);</span>
<span class="nc" id="L222">            hdr = logEntry.getHeader();</span>
<span class="nc" id="L223">            txn = logEntry.getTxn();</span>
<span class="nc" id="L224">            digest = logEntry.getDigest();</span>
<span class="nc" id="L225">            QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) txn).getData(), UTF_8));</span>

<span class="nc" id="L227">            request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);</span>
<span class="nc" id="L228">            request.setTxnDigest(digest);</span>
<span class="nc" id="L229">            obs = (ObserverZooKeeperServer) zk;</span>

<span class="nc" id="L231">            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);</span>

<span class="nc" id="L233">            obs.commitRequest(request);</span>

<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (majorChange) {</span>
<span class="nc" id="L236">                throw new Exception(&quot;changes proposed in reconfig&quot;);</span>
            }
            break;
        default:
<span class="nc" id="L240">            LOG.warn(&quot;Unknown packet type: {}&quot;, LearnerHandler.packetToString(qp));</span>
            break;
        }
<span class="nc" id="L243">    }</span>

    /**
     * Shutdown the Observer.
     */
    public void shutdown() {
<span class="nc" id="L249">        LOG.info(&quot;shutdown Observer&quot;);</span>
<span class="nc" id="L250">        super.shutdown();</span>
<span class="nc" id="L251">    }</span>

    static void waitForReconnectDelay() {
<span class="nc" id="L254">        waitForReconnectDelayHelper(reconnectDelayMs);</span>
<span class="nc" id="L255">    }</span>

    static void waitForObserverElectionDelay() {
<span class="nc" id="L258">        waitForReconnectDelayHelper(observerElectionDelayMs);</span>
<span class="nc" id="L259">    }</span>

    private static void waitForReconnectDelayHelper(long delayValueMs) {
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (delayValueMs &gt; 0) {</span>
<span class="nc" id="L263">            long randomDelay = ThreadLocalRandom.current().nextLong(delayValueMs);</span>
<span class="nc" id="L264">            LOG.info(&quot;Waiting for {} ms before reconnecting with the leader&quot;, randomDelay);</span>
            try {
<span class="nc" id="L266">                Thread.sleep(randomDelay);</span>
<span class="nc" id="L267">            } catch (InterruptedException e) {</span>
<span class="nc" id="L268">                LOG.warn(&quot;Interrupted while waiting&quot;, e);</span>
<span class="nc" id="L269">            }</span>
        }
<span class="nc" id="L271">    }</span>

    public long getLearnerMasterId() {
<span class="nc" id="L274">        QuorumPeer.QuorumServer current = currentLearnerMaster;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        return current == null ? -1 : current.id;</span>
    }

    /**
     * Prompts the Observer to disconnect from its current learner master and reconnect
     * to the specified server. If that connection attempt fails, the Observer will
     * fail over to the next available learner master.
     */
    public boolean setLearnerMaster(String learnerMaster) {
<span class="nc" id="L284">        final QuorumPeer.QuorumServer server = self.validateLearnerMaster(learnerMaster);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (server == null) {</span>
<span class="nc" id="L286">            return false;</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        } else if (server.equals(currentLearnerMaster)) {</span>
<span class="nc" id="L288">            LOG.info(&quot;Already connected to requested learner master sid={} addr={}&quot;, server.id, server.addr);</span>
<span class="nc" id="L289">            return true;</span>
        } else {
<span class="nc" id="L291">            LOG.info(&quot;Requesting disconnect and reconnect to new learner master sid={} addr={}&quot;, server.id, server.addr);</span>
<span class="nc" id="L292">            nextLearnerMaster.set(server);</span>
<span class="nc" id="L293">            return true;</span>
        }
    }

    public QuorumPeer.QuorumServer getCurrentLearnerMaster() {
<span class="nc" id="L298">        return currentLearnerMaster;</span>
    }

    public static long getObserverElectionDelayMs() {
<span class="nc" id="L302">        return observerElectionDelayMs;</span>
    }

    public static void setObserverElectionDelayMs(long electionDelayMs) {
<span class="nc" id="L306">        observerElectionDelayMs = electionDelayMs;</span>
<span class="nc" id="L307">        LOG.info(&quot;{} = {}&quot;, OBSERVER_ELECTION_DELAY_MS, observerElectionDelayMs);</span>
<span class="nc" id="L308">    }</span>

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>