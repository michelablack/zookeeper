<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PrepRequestProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">PrepRequestProcessor.java</span></div><h1>PrepRequestProcessor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import static java.nio.charset.StandardCharsets.UTF_8;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.StringReader;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.LinkedBlockingQueue;
import org.apache.jute.BinaryOutputArchive;
import org.apache.jute.Record;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.KeeperException.BadArgumentsException;
import org.apache.zookeeper.KeeperException.Code;
import org.apache.zookeeper.MultiOperationRecord;
import org.apache.zookeeper.Op;
import org.apache.zookeeper.ZooDefs;
import org.apache.zookeeper.ZooDefs.OpCode;
import org.apache.zookeeper.common.PathUtils;
import org.apache.zookeeper.common.StringUtils;
import org.apache.zookeeper.common.Time;
import org.apache.zookeeper.data.ACL;
import org.apache.zookeeper.data.Id;
import org.apache.zookeeper.data.StatPersisted;
import org.apache.zookeeper.proto.CheckVersionRequest;
import org.apache.zookeeper.proto.CreateRequest;
import org.apache.zookeeper.proto.CreateTTLRequest;
import org.apache.zookeeper.proto.DeleteRequest;
import org.apache.zookeeper.proto.ReconfigRequest;
import org.apache.zookeeper.proto.SetACLRequest;
import org.apache.zookeeper.proto.SetDataRequest;
import org.apache.zookeeper.server.ZooKeeperServer.ChangeRecord;
import org.apache.zookeeper.server.ZooKeeperServer.PrecalculatedDigest;
import org.apache.zookeeper.server.auth.ProviderRegistry;
import org.apache.zookeeper.server.auth.ServerAuthenticationProvider;
import org.apache.zookeeper.server.quorum.LeaderZooKeeperServer;
import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
import org.apache.zookeeper.server.quorum.flexible.QuorumOracleMaj;
import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
import org.apache.zookeeper.txn.CheckVersionTxn;
import org.apache.zookeeper.txn.CloseSessionTxn;
import org.apache.zookeeper.txn.CreateContainerTxn;
import org.apache.zookeeper.txn.CreateSessionTxn;
import org.apache.zookeeper.txn.CreateTTLTxn;
import org.apache.zookeeper.txn.CreateTxn;
import org.apache.zookeeper.txn.DeleteTxn;
import org.apache.zookeeper.txn.ErrorTxn;
import org.apache.zookeeper.txn.MultiTxn;
import org.apache.zookeeper.txn.SetACLTxn;
import org.apache.zookeeper.txn.SetDataTxn;
import org.apache.zookeeper.txn.Txn;
import org.apache.zookeeper.txn.TxnDigest;
import org.apache.zookeeper.txn.TxnHeader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This request processor is generally at the start of a RequestProcessor
 * change. It sets up any transactions associated with requests that change the
 * state of the system. It counts on ZooKeeperServer to update
 * outstandingRequests, so that it can take into account transactions that are
 * in the queue to be applied when generating a transaction.
 */
public class PrepRequestProcessor extends ZooKeeperCriticalThread implements RequestProcessor {

<span class="nc" id="L96">    private static final Logger LOG = LoggerFactory.getLogger(PrepRequestProcessor.class);</span>

    /**
     * this is only for testing purposes.
     * should never be used otherwise
     */
<span class="nc" id="L102">    private static boolean failCreate = false;</span>

<span class="nc" id="L104">    LinkedBlockingQueue&lt;Request&gt; submittedRequests = new LinkedBlockingQueue&lt;Request&gt;();</span>

    private final RequestProcessor nextProcessor;
    private final boolean digestEnabled;
    private DigestCalculator digestCalculator;

    ZooKeeperServer zks;

<span class="nc" id="L112">    public enum DigestOpCode {</span>
<span class="nc" id="L113">        NOOP, ADD, REMOVE, UPDATE;</span>
    }

    public PrepRequestProcessor(ZooKeeperServer zks, RequestProcessor nextProcessor) {
<span class="nc" id="L117">        super(</span>
<span class="nc" id="L118">            &quot;ProcessThread(sid:&quot; + zks.getServerId()</span>
<span class="nc" id="L119">            + &quot; cport:&quot; + zks.getClientPort()</span>
<span class="nc" id="L120">            + &quot;):&quot;, zks.getZooKeeperServerListener());</span>
<span class="nc" id="L121">        this.nextProcessor = nextProcessor;</span>
<span class="nc" id="L122">        this.zks = zks;</span>
<span class="nc" id="L123">        this.digestEnabled = ZooKeeperServer.isDigestEnabled();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (this.digestEnabled) {</span>
<span class="nc" id="L125">            this.digestCalculator = new DigestCalculator();</span>
        }
<span class="nc" id="L127">    }</span>

    /**
     * method for tests to set failCreate
     * @param b
     */
    public static void setFailCreate(boolean b) {
<span class="nc" id="L134">        failCreate = b;</span>
<span class="nc" id="L135">    }</span>
    @Override
    public void run() {
<span class="nc" id="L138">        LOG.info(String.format(&quot;PrepRequestProcessor (sid:%d) started, reconfigEnabled=%s&quot;, zks.getServerId(), zks.reconfigEnabled));</span>
        try {
            while (true) {
<span class="nc" id="L141">                ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_SIZE.add(submittedRequests.size());</span>
<span class="nc" id="L142">                Request request = submittedRequests.take();</span>
<span class="nc" id="L143">                ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_TIME</span>
<span class="nc" id="L144">                    .add(Time.currentElapsedTime() - request.prepQueueStartTime);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">                if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L146">                    long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">                    if (request.type == OpCode.ping) {</span>
<span class="nc" id="L148">                        traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span>
                    }
<span class="nc" id="L150">                    ZooTrace.logRequest(LOG, traceMask, 'P', request, &quot;&quot;);</span>
                }
<span class="nc bnc" id="L152" title="All 2 branches missed.">                if (Request.requestOfDeath == request) {</span>
<span class="nc" id="L153">                    break;</span>
                }

<span class="nc" id="L156">                request.prepStartTime = Time.currentElapsedTime();</span>
<span class="nc" id="L157">                pRequest(request);</span>
<span class="nc" id="L158">            }</span>
<span class="nc" id="L159">        } catch (Exception e) {</span>
<span class="nc" id="L160">            handleException(this.getName(), e);</span>
<span class="nc" id="L161">        }</span>
<span class="nc" id="L162">        LOG.info(&quot;PrepRequestProcessor exited loop!&quot;);</span>
<span class="nc" id="L163">    }</span>

    private ChangeRecord getRecordForPath(String path) throws KeeperException.NoNodeException {
<span class="nc" id="L166">        ChangeRecord lastChange = null;</span>
<span class="nc" id="L167">        synchronized (zks.outstandingChanges) {</span>
<span class="nc" id="L168">            lastChange = zks.outstandingChangesForPath.get(path);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (lastChange == null) {</span>
<span class="nc" id="L170">                DataNode n = zks.getZKDatabase().getNode(path);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                if (n != null) {</span>
                    Set&lt;String&gt; children;
<span class="nc" id="L173">                    synchronized (n) {</span>
<span class="nc" id="L174">                        children = n.getChildren();</span>
<span class="nc" id="L175">                    }</span>
<span class="nc" id="L176">                    lastChange = new ChangeRecord(-1, path, n.stat, children.size(), zks.getZKDatabase().aclForNode(n));</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">                    if (digestEnabled) {</span>
<span class="nc" id="L179">                        lastChange.precalculatedDigest = new PrecalculatedDigest(</span>
<span class="nc" id="L180">                                digestCalculator.calculateDigest(path, n), 0);</span>
                    }
<span class="nc" id="L182">                    lastChange.data = n.getData();</span>
                }
            }
<span class="nc" id="L185">        }</span>
<span class="nc bnc" id="L186" title="All 4 branches missed.">        if (lastChange == null || lastChange.stat == null) {</span>
<span class="nc" id="L187">            throw new KeeperException.NoNodeException(path);</span>
        }
<span class="nc" id="L189">        return lastChange;</span>
    }

    private ChangeRecord getOutstandingChange(String path) {
<span class="nc" id="L193">        synchronized (zks.outstandingChanges) {</span>
<span class="nc" id="L194">            return zks.outstandingChangesForPath.get(path);</span>
        }
    }

    protected void addChangeRecord(ChangeRecord c) {
<span class="nc" id="L199">        synchronized (zks.outstandingChanges) {</span>
<span class="nc" id="L200">            zks.outstandingChanges.add(c);</span>
<span class="nc" id="L201">            zks.outstandingChangesForPath.put(c.path, c);</span>
<span class="nc" id="L202">            ServerMetrics.getMetrics().OUTSTANDING_CHANGES_QUEUED.add(1);</span>
<span class="nc" id="L203">        }</span>
<span class="nc" id="L204">    }</span>

    /**
     * Grab current pending change records for each op in a multi-op.
     *
     * This is used inside MultiOp error code path to rollback in the event
     * of a failed multi-op.
     *
     * @param multiRequest
     * @return a map that contains previously existed records that probably need to be
     *         rolled back in any failure.
     */
    private Map&lt;String, ChangeRecord&gt; getPendingChanges(MultiOperationRecord multiRequest) {
<span class="nc" id="L217">        Map&lt;String, ChangeRecord&gt; pendingChangeRecords = new HashMap&lt;String, ChangeRecord&gt;();</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">        for (Op op : multiRequest) {</span>
<span class="nc" id="L220">            String path = op.getPath();</span>
<span class="nc" id="L221">            ChangeRecord cr = getOutstandingChange(path);</span>
            // only previously existing records need to be rolled back.
<span class="nc bnc" id="L223" title="All 2 branches missed.">            if (cr != null) {</span>
<span class="nc" id="L224">                pendingChangeRecords.put(path, cr);</span>
            }

            /*
             * ZOOKEEPER-1624 - We need to store for parent's ChangeRecord
             * of the parent node of a request. So that if this is a
             * sequential node creation request, rollbackPendingChanges()
             * can restore previous parent's ChangeRecord correctly.
             *
             * Otherwise, sequential node name generation will be incorrect
             * for a subsequent request.
             */
<span class="nc" id="L236">            int lastSlash = path.lastIndexOf('/');</span>
<span class="nc bnc" id="L237" title="All 4 branches missed.">            if (lastSlash == -1 || path.indexOf('\0') != -1) {</span>
<span class="nc" id="L238">                continue;</span>
            }
<span class="nc" id="L240">            String parentPath = path.substring(0, lastSlash);</span>
<span class="nc" id="L241">            ChangeRecord parentCr = getOutstandingChange(parentPath);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (parentCr != null) {</span>
<span class="nc" id="L243">                pendingChangeRecords.put(parentPath, parentCr);</span>
            }
<span class="nc" id="L245">        }</span>

<span class="nc" id="L247">        return pendingChangeRecords;</span>
    }

    /**
     * Rollback pending changes records from a failed multi-op.
     *
     * If a multi-op fails, we can't leave any invalid change records we created
     * around. We also need to restore their prior value (if any) if their prior
     * value is still valid.
     *
     * @param zxid
     * @param pendingChangeRecords
     */
    void rollbackPendingChanges(long zxid, Map&lt;String, ChangeRecord&gt; pendingChangeRecords) {
<span class="nc" id="L261">        synchronized (zks.outstandingChanges) {</span>
            // Grab a list iterator starting at the END of the list so we can iterate in reverse
<span class="nc" id="L263">            Iterator&lt;ChangeRecord&gt; iter = zks.outstandingChanges.descendingIterator();</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L265">                ChangeRecord c = iter.next();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">                if (c.zxid == zxid) {</span>
<span class="nc" id="L267">                    iter.remove();</span>
                    // Remove all outstanding changes for paths of this multi.
                    // Previous records will be added back later.
<span class="nc" id="L270">                    zks.outstandingChangesForPath.remove(c.path);</span>
                } else {
                    break;
                }
<span class="nc" id="L274">            }</span>

            // we don't need to roll back any records because there is nothing left.
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (zks.outstandingChanges.isEmpty()) {</span>
<span class="nc" id="L278">                return;</span>
            }

<span class="nc" id="L281">            long firstZxid = zks.outstandingChanges.peek().zxid;</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">            for (ChangeRecord c : pendingChangeRecords.values()) {</span>
                // Don't apply any prior change records less than firstZxid.
                // Note that previous outstanding requests might have been removed
                // once they are completed.
<span class="nc bnc" id="L287" title="All 2 branches missed.">                if (c.zxid &lt; firstZxid) {</span>
<span class="nc" id="L288">                    continue;</span>
                }

                // add previously existing records back.
<span class="nc" id="L292">                zks.outstandingChangesForPath.put(c.path, c);</span>
<span class="nc" id="L293">            }</span>
<span class="nc" id="L294">        }</span>
<span class="nc" id="L295">    }</span>

    /**
     * Performs basic validation of a path for a create request.
     * Throws if the path is not valid and returns the parent path.
     * @throws BadArgumentsException
     */
    private String validatePathForCreate(String path, long sessionId) throws BadArgumentsException {
<span class="nc" id="L303">        int lastSlash = path.lastIndexOf('/');</span>
<span class="nc bnc" id="L304" title="All 6 branches missed.">        if (lastSlash == -1 || path.indexOf('\0') != -1 || failCreate) {</span>
<span class="nc" id="L305">            LOG.info(&quot;Invalid path {} with session 0x{}&quot;, path, Long.toHexString(sessionId));</span>
<span class="nc" id="L306">            throw new KeeperException.BadArgumentsException(path);</span>
        }
<span class="nc" id="L308">        return path.substring(0, lastSlash);</span>
    }

    /**
     * This method will be called inside the ProcessRequestThread, which is a
     * singleton, so there will be a single thread calling this code.
     *
     * @param type
     * @param zxid
     * @param request
     * @param record
     */
    protected void pRequest2Txn(int type, long zxid, Request request, Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (request.getHdr() == null) {</span>
<span class="nc" id="L322">            request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,</span>
<span class="nc" id="L323">                    Time.currentWallTime(), type));</span>
        }

<span class="nc bnc" id="L326" title="All 10 branches missed.">        switch (type) {</span>
        case OpCode.create:
        case OpCode.create2:
        case OpCode.createTTL:
        case OpCode.createContainer: {
<span class="nc" id="L331">            pRequest2TxnCreate(type, request, record, deserialize);</span>
<span class="nc" id="L332">            break;</span>
        }
        case OpCode.deleteContainer: {
<span class="nc" id="L335">            String path = new String(request.request.array(), UTF_8);</span>
<span class="nc" id="L336">            String parentPath = getParentPathAndValidate(path);</span>
<span class="nc" id="L337">            ChangeRecord nodeRecord = getRecordForPath(path);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            if (nodeRecord.childCount &gt; 0) {</span>
<span class="nc" id="L339">                throw new KeeperException.NotEmptyException(path);</span>
            }
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (EphemeralType.get(nodeRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL) {</span>
<span class="nc" id="L342">                throw new KeeperException.BadVersionException(path);</span>
            }
<span class="nc" id="L344">            ChangeRecord parentRecord = getRecordForPath(parentPath);</span>
<span class="nc" id="L345">            request.setTxn(new DeleteTxn(path));</span>
<span class="nc" id="L346">            parentRecord = parentRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L347">            parentRecord.childCount--;</span>
<span class="nc" id="L348">            parentRecord.stat.setPzxid(request.getHdr().getZxid());</span>
<span class="nc" id="L349">            parentRecord.precalculatedDigest = precalculateDigest(</span>
                    DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);
<span class="nc" id="L351">            addChangeRecord(parentRecord);</span>

<span class="nc" id="L353">            nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null);</span>
<span class="nc" id="L354">            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);</span>
<span class="nc" id="L355">            setTxnDigest(request, nodeRecord.precalculatedDigest);</span>
<span class="nc" id="L356">            addChangeRecord(nodeRecord);</span>
<span class="nc" id="L357">            break;</span>
        }
        case OpCode.delete:
<span class="nc" id="L360">            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
<span class="nc" id="L361">            DeleteRequest deleteRequest = (DeleteRequest) record;</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">            if (deserialize) {</span>
<span class="nc" id="L363">                ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);</span>
            }
<span class="nc" id="L365">            String path = deleteRequest.getPath();</span>
<span class="nc" id="L366">            String parentPath = getParentPathAndValidate(path);</span>
<span class="nc" id="L367">            ChangeRecord parentRecord = getRecordForPath(parentPath);</span>
<span class="nc" id="L368">            zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo, path, null);</span>
<span class="nc" id="L369">            ChangeRecord nodeRecord = getRecordForPath(path);</span>
<span class="nc" id="L370">            checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">            if (nodeRecord.childCount &gt; 0) {</span>
<span class="nc" id="L372">                throw new KeeperException.NotEmptyException(path);</span>
            }
<span class="nc" id="L374">            request.setTxn(new DeleteTxn(path));</span>
<span class="nc" id="L375">            parentRecord = parentRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L376">            parentRecord.childCount--;</span>
<span class="nc" id="L377">            parentRecord.stat.setPzxid(request.getHdr().getZxid());</span>
<span class="nc" id="L378">            parentRecord.precalculatedDigest = precalculateDigest(</span>
                    DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);
<span class="nc" id="L380">            addChangeRecord(parentRecord);</span>

<span class="nc" id="L382">            nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null);</span>
<span class="nc" id="L383">            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);</span>
<span class="nc" id="L384">            setTxnDigest(request, nodeRecord.precalculatedDigest);</span>
<span class="nc" id="L385">            addChangeRecord(nodeRecord);</span>
<span class="nc" id="L386">            break;</span>
        case OpCode.setData:
<span class="nc" id="L388">            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
<span class="nc" id="L389">            SetDataRequest setDataRequest = (SetDataRequest) record;</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (deserialize) {</span>
<span class="nc" id="L391">                ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);</span>
            }
<span class="nc" id="L393">            path = setDataRequest.getPath();</span>
<span class="nc" id="L394">            validatePath(path, request.sessionId);</span>
<span class="nc" id="L395">            nodeRecord = getRecordForPath(path);</span>
<span class="nc" id="L396">            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, path, null);</span>
<span class="nc" id="L397">            zks.checkQuota(path, nodeRecord.data, setDataRequest.getData(), OpCode.setData);</span>
<span class="nc" id="L398">            int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);</span>
<span class="nc" id="L399">            request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));</span>
<span class="nc" id="L400">            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L401">            nodeRecord.stat.setVersion(newVersion);</span>
<span class="nc" id="L402">            nodeRecord.stat.setMtime(request.getHdr().getTime());</span>
<span class="nc" id="L403">            nodeRecord.stat.setMzxid(zxid);</span>
<span class="nc" id="L404">            nodeRecord.data = setDataRequest.getData();</span>
<span class="nc" id="L405">            nodeRecord.precalculatedDigest = precalculateDigest(</span>
                    DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);
<span class="nc" id="L407">            setTxnDigest(request, nodeRecord.precalculatedDigest);</span>
<span class="nc" id="L408">            addChangeRecord(nodeRecord);</span>
<span class="nc" id="L409">            break;</span>
        case OpCode.reconfig:
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (!zks.isReconfigEnabled()) {</span>
<span class="nc" id="L412">                LOG.error(&quot;Reconfig operation requested but reconfig feature is disabled.&quot;);</span>
<span class="nc" id="L413">                throw new KeeperException.ReconfigDisabledException();</span>
            }

<span class="nc bnc" id="L416" title="All 2 branches missed.">            if (ZooKeeperServer.skipACL) {</span>
<span class="nc" id="L417">                LOG.warn(&quot;skipACL is set, reconfig operation will skip ACL checks!&quot;);</span>
            }

<span class="nc" id="L420">            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
            LeaderZooKeeperServer lzks;
            try {
<span class="nc" id="L423">                lzks = (LeaderZooKeeperServer) zks;</span>
<span class="nc" id="L424">            } catch (ClassCastException e) {</span>
                // standalone mode - reconfiguration currently not supported
<span class="nc" id="L426">                throw new KeeperException.UnimplementedException();</span>
<span class="nc" id="L427">            }</span>
<span class="nc" id="L428">            QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();</span>
            // check that there's no reconfig in progress
<span class="nc bnc" id="L430" title="All 2 branches missed.">            if (lastSeenQV.getVersion() != lzks.self.getQuorumVerifier().getVersion()) {</span>
<span class="nc" id="L431">                throw new KeeperException.ReconfigInProgress();</span>
            }
<span class="nc" id="L433">            ReconfigRequest reconfigRequest = (ReconfigRequest) record;</span>
<span class="nc" id="L434">            long configId = reconfigRequest.getCurConfigId();</span>

<span class="nc bnc" id="L436" title="All 4 branches missed.">            if (configId != -1 &amp;&amp; configId != lzks.self.getLastSeenQuorumVerifier().getVersion()) {</span>
<span class="nc" id="L437">                String msg = &quot;Reconfiguration from version &quot;</span>
                             + configId
                             + &quot; failed -- last seen version is &quot;
<span class="nc" id="L440">                             + lzks.self.getLastSeenQuorumVerifier().getVersion();</span>
<span class="nc" id="L441">                throw new KeeperException.BadVersionException(msg);</span>
            }

<span class="nc" id="L444">            String newMembers = reconfigRequest.getNewMembers();</span>

<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (newMembers != null) { //non-incremental membership change</span>
<span class="nc" id="L447">                LOG.info(&quot;Non-incremental reconfig&quot;);</span>

                // Input may be delimited by either commas or newlines so convert to common newline separated format
<span class="nc" id="L450">                newMembers = newMembers.replaceAll(&quot;,&quot;, &quot;\n&quot;);</span>

                try {
<span class="nc" id="L453">                    Properties props = new Properties();</span>
<span class="nc" id="L454">                    props.load(new StringReader(newMembers));</span>
<span class="nc" id="L455">                    request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false, lastSeenQV.getOraclePath());</span>
<span class="nc" id="L456">                    request.qv.setVersion(request.getHdr().getZxid());</span>
<span class="nc" id="L457">                } catch (IOException | ConfigException e) {</span>
<span class="nc" id="L458">                    throw new KeeperException.BadArgumentsException(e.getMessage());</span>
<span class="nc" id="L459">                }</span>
            } else { //incremental change - must be a majority quorum system
<span class="nc" id="L461">                LOG.info(&quot;Incremental reconfig&quot;);</span>

<span class="nc" id="L463">                List&lt;String&gt; joiningServers = null;</span>
<span class="nc" id="L464">                String joiningServersString = reconfigRequest.getJoiningServers();</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                if (joiningServersString != null) {</span>
<span class="nc" id="L466">                    joiningServers = StringUtils.split(joiningServersString, &quot;,&quot;);</span>
                }

<span class="nc" id="L469">                List&lt;String&gt; leavingServers = null;</span>
<span class="nc" id="L470">                String leavingServersString = reconfigRequest.getLeavingServers();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                if (leavingServersString != null) {</span>
<span class="nc" id="L472">                    leavingServers = StringUtils.split(leavingServersString, &quot;,&quot;);</span>
                }

<span class="nc bnc" id="L475" title="All 4 branches missed.">                if (!(lastSeenQV instanceof QuorumMaj) &amp;&amp; !(lastSeenQV instanceof QuorumOracleMaj)) {</span>
<span class="nc" id="L476">                    String msg = &quot;Incremental reconfiguration requested but last configuration seen has a non-majority quorum system&quot;;</span>
<span class="nc" id="L477">                    LOG.warn(msg);</span>
<span class="nc" id="L478">                    throw new KeeperException.BadArgumentsException(msg);</span>
                }
<span class="nc" id="L480">                Map&lt;Long, QuorumServer&gt; nextServers = new HashMap&lt;Long, QuorumServer&gt;(lastSeenQV.getAllMembers());</span>
                try {
<span class="nc bnc" id="L482" title="All 2 branches missed.">                    if (leavingServers != null) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                        for (String leaving : leavingServers) {</span>
<span class="nc" id="L484">                            long sid = Long.parseLong(leaving);</span>
<span class="nc" id="L485">                            nextServers.remove(sid);</span>
<span class="nc" id="L486">                        }</span>
                    }
<span class="nc bnc" id="L488" title="All 2 branches missed.">                    if (joiningServers != null) {</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                        for (String joiner : joiningServers) {</span>
                            // joiner should have the following format: server.x = server_spec;client_spec
<span class="nc" id="L491">                            String[] parts = StringUtils.split(joiner, &quot;=&quot;).toArray(new String[0]);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                            if (parts.length != 2) {</span>
<span class="nc" id="L493">                                throw new KeeperException.BadArgumentsException(&quot;Wrong format of server string&quot;);</span>
                            }
                            // extract server id x from first part of joiner: server.x
<span class="nc" id="L496">                            Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));</span>
<span class="nc" id="L497">                            QuorumServer qs = new QuorumServer(sid, parts[1]);</span>
<span class="nc bnc" id="L498" title="All 6 branches missed.">                            if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {</span>
<span class="nc" id="L499">                                throw new KeeperException.BadArgumentsException(&quot;Wrong format of server string - each server should have 3 ports specified&quot;);</span>
                            }

                            // check duplication of addresses and ports
<span class="nc bnc" id="L503" title="All 2 branches missed.">                            for (QuorumServer nqs : nextServers.values()) {</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                                if (qs.id == nqs.id) {</span>
<span class="nc" id="L505">                                    continue;</span>
                                }
<span class="nc" id="L507">                                qs.checkAddressDuplicate(nqs);</span>
<span class="nc" id="L508">                            }</span>

<span class="nc" id="L510">                            nextServers.remove(qs.id);</span>
<span class="nc" id="L511">                            nextServers.put(qs.id, qs);</span>
<span class="nc" id="L512">                        }</span>
                    }
<span class="nc" id="L514">                } catch (ConfigException e) {</span>
<span class="nc" id="L515">                    throw new KeeperException.BadArgumentsException(&quot;Reconfiguration failed&quot;);</span>
<span class="nc" id="L516">                }</span>

<span class="nc bnc" id="L518" title="All 2 branches missed.">                if (lastSeenQV instanceof QuorumMaj) {</span>
<span class="nc" id="L519">                    request.qv = new QuorumMaj(nextServers);</span>
                } else {
<span class="nc" id="L521">                    request.qv = new QuorumOracleMaj(nextServers, lastSeenQV.getOraclePath());</span>
                }

<span class="nc" id="L524">                request.qv.setVersion(request.getHdr().getZxid());</span>
            }
<span class="nc bnc" id="L526" title="All 4 branches missed.">            if (QuorumPeerConfig.isStandaloneEnabled() &amp;&amp; request.qv.getVotingMembers().size() &lt; 2) {</span>
<span class="nc" id="L527">                String msg = &quot;Reconfig failed - new configuration must include at least 2 followers&quot;;</span>
<span class="nc" id="L528">                LOG.warn(msg);</span>
<span class="nc" id="L529">                throw new KeeperException.BadArgumentsException(msg);</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">            } else if (request.qv.getVotingMembers().size() &lt; 1) {</span>
<span class="nc" id="L531">                String msg = &quot;Reconfig failed - new configuration must include at least 1 follower&quot;;</span>
<span class="nc" id="L532">                LOG.warn(msg);</span>
<span class="nc" id="L533">                throw new KeeperException.BadArgumentsException(msg);</span>
            }

<span class="nc bnc" id="L536" title="All 2 branches missed.">            if (!lzks.getLeader().isQuorumSynced(request.qv)) {</span>
<span class="nc" id="L537">                String msg2 = &quot;Reconfig failed - there must be a connected and synced quorum in new configuration&quot;;</span>
<span class="nc" id="L538">                LOG.warn(msg2);</span>
<span class="nc" id="L539">                throw new KeeperException.NewConfigNoQuorum();</span>
            }

<span class="nc" id="L542">            nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);</span>
<span class="nc" id="L543">            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, null, null);</span>
<span class="nc" id="L544">            SetDataTxn setDataTxn = new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1);</span>
<span class="nc" id="L545">            request.setTxn(setDataTxn);</span>
<span class="nc" id="L546">            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L547">            nodeRecord.stat.setVersion(-1);</span>
<span class="nc" id="L548">            nodeRecord.stat.setMtime(request.getHdr().getTime());</span>
<span class="nc" id="L549">            nodeRecord.stat.setMzxid(zxid);</span>
<span class="nc" id="L550">            nodeRecord.data = setDataTxn.getData();</span>
            // Reconfig is currently a noop from digest computation
            // perspective since config node is not covered by the digests.
<span class="nc" id="L553">            nodeRecord.precalculatedDigest = precalculateDigest(</span>
                    DigestOpCode.NOOP, ZooDefs.CONFIG_NODE, nodeRecord.data, nodeRecord.stat);
<span class="nc" id="L555">            setTxnDigest(request, nodeRecord.precalculatedDigest);</span>
<span class="nc" id="L556">            addChangeRecord(nodeRecord);</span>

<span class="nc" id="L558">            break;</span>
        case OpCode.setACL:
<span class="nc" id="L560">            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
<span class="nc" id="L561">            SetACLRequest setAclRequest = (SetACLRequest) record;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">            if (deserialize) {</span>
<span class="nc" id="L563">                ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);</span>
            }
<span class="nc" id="L565">            path = setAclRequest.getPath();</span>
<span class="nc" id="L566">            validatePath(path, request.sessionId);</span>
<span class="nc" id="L567">            List&lt;ACL&gt; listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());</span>
<span class="nc" id="L568">            nodeRecord = getRecordForPath(path);</span>
<span class="nc" id="L569">            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo, path, listACL);</span>
<span class="nc" id="L570">            newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);</span>
<span class="nc" id="L571">            request.setTxn(new SetACLTxn(path, listACL, newVersion));</span>
<span class="nc" id="L572">            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L573">            nodeRecord.stat.setAversion(newVersion);</span>
<span class="nc" id="L574">            nodeRecord.precalculatedDigest = precalculateDigest(</span>
                    DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);
<span class="nc" id="L576">            setTxnDigest(request, nodeRecord.precalculatedDigest);</span>
<span class="nc" id="L577">            addChangeRecord(nodeRecord);</span>
<span class="nc" id="L578">            break;</span>
        case OpCode.createSession:
<span class="nc" id="L580">            request.request.rewind();</span>
<span class="nc" id="L581">            int to = request.request.getInt();</span>
<span class="nc" id="L582">            request.setTxn(new CreateSessionTxn(to));</span>
<span class="nc" id="L583">            request.request.rewind();</span>
            // only add the global session tracker but not to ZKDb
<span class="nc" id="L585">            zks.sessionTracker.trackSession(request.sessionId, to);</span>
<span class="nc" id="L586">            zks.setOwner(request.sessionId, request.getOwner());</span>
<span class="nc" id="L587">            break;</span>
        case OpCode.closeSession:
            // We don't want to do this check since the session expiration thread
            // queues up this operation without being the session owner.
            // this request is the last of the session so it should be ok
            //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
<span class="nc" id="L593">            long startTime = Time.currentElapsedTime();</span>
<span class="nc" id="L594">            synchronized (zks.outstandingChanges) {</span>
                // need to move getEphemerals into zks.outstandingChanges
                // synchronized block, otherwise there will be a race
                // condition with the on flying deleteNode txn, and we'll
                // delete the node again here, which is not correct
<span class="nc" id="L599">                Set&lt;String&gt; es = zks.getZKDatabase().getEphemerals(request.sessionId);</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                for (ChangeRecord c : zks.outstandingChanges) {</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">                    if (c.stat == null) {</span>
                        // Doing a delete
<span class="nc" id="L603">                        es.remove(c.path);</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">                    } else if (c.stat.getEphemeralOwner() == request.sessionId) {</span>
<span class="nc" id="L605">                        es.add(c.path);</span>
                    }
<span class="nc" id="L607">                }</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">                for (String path2Delete : es) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                    if (digestEnabled) {</span>
<span class="nc" id="L610">                        parentPath = getParentPathAndValidate(path2Delete);</span>
<span class="nc" id="L611">                        parentRecord = getRecordForPath(parentPath);</span>
<span class="nc" id="L612">                        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L613">                        parentRecord.stat.setPzxid(request.getHdr().getZxid());</span>
<span class="nc" id="L614">                        parentRecord.precalculatedDigest = precalculateDigest(</span>
                                DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);
<span class="nc" id="L616">                        addChangeRecord(parentRecord);</span>
                    }
<span class="nc" id="L618">                    nodeRecord = new ChangeRecord(</span>
<span class="nc" id="L619">                            request.getHdr().getZxid(), path2Delete, null, 0, null);</span>
<span class="nc" id="L620">                    nodeRecord.precalculatedDigest = precalculateDigest(</span>
                            DigestOpCode.REMOVE, path2Delete);
<span class="nc" id="L622">                    addChangeRecord(nodeRecord);</span>
<span class="nc" id="L623">                }</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                if (ZooKeeperServer.isCloseSessionTxnEnabled()) {</span>
<span class="nc" id="L625">                    request.setTxn(new CloseSessionTxn(new ArrayList&lt;String&gt;(es)));</span>
                }
<span class="nc" id="L627">                zks.sessionTracker.setSessionClosing(request.sessionId);</span>
<span class="nc" id="L628">            }</span>
<span class="nc" id="L629">            ServerMetrics.getMetrics().CLOSE_SESSION_PREP_TIME.add(Time.currentElapsedTime() - startTime);</span>
<span class="nc" id="L630">            break;</span>
        case OpCode.check:
<span class="nc" id="L632">            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
<span class="nc" id="L633">            CheckVersionRequest checkVersionRequest = (CheckVersionRequest) record;</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">            if (deserialize) {</span>
<span class="nc" id="L635">                ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);</span>
            }
<span class="nc" id="L637">            path = checkVersionRequest.getPath();</span>
<span class="nc" id="L638">            validatePath(path, request.sessionId);</span>
<span class="nc" id="L639">            nodeRecord = getRecordForPath(path);</span>
<span class="nc" id="L640">            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo, path, null);</span>
<span class="nc" id="L641">            request.setTxn(new CheckVersionTxn(</span>
                path,
<span class="nc" id="L643">                checkAndIncVersion(nodeRecord.stat.getVersion(), checkVersionRequest.getVersion(), path)));</span>
<span class="nc" id="L644">            break;</span>
        default:
<span class="nc" id="L646">            LOG.warn(&quot;unknown type {}&quot;, type);</span>
            break;
        }

        // If the txn is not going to mutate anything, like createSession,
        // we just set the current tree digest in it
<span class="nc bnc" id="L652" title="All 4 branches missed.">        if (request.getTxnDigest() == null &amp;&amp; digestEnabled) {</span>
<span class="nc" id="L653">            setTxnDigest(request);</span>
        }
<span class="nc" id="L655">    }</span>

    private void pRequest2TxnCreate(int type, Request request, Record record, boolean deserialize) throws IOException, KeeperException {
<span class="nc bnc" id="L658" title="All 2 branches missed.">        if (deserialize) {</span>
<span class="nc" id="L659">            ByteBufferInputStream.byteBuffer2Record(request.request, record);</span>
        }

        int flags;
        String path;
        List&lt;ACL&gt; acl;
        byte[] data;
        long ttl;
<span class="nc bnc" id="L667" title="All 2 branches missed.">        if (type == OpCode.createTTL) {</span>
<span class="nc" id="L668">            CreateTTLRequest createTtlRequest = (CreateTTLRequest) record;</span>
<span class="nc" id="L669">            flags = createTtlRequest.getFlags();</span>
<span class="nc" id="L670">            path = createTtlRequest.getPath();</span>
<span class="nc" id="L671">            acl = createTtlRequest.getAcl();</span>
<span class="nc" id="L672">            data = createTtlRequest.getData();</span>
<span class="nc" id="L673">            ttl = createTtlRequest.getTtl();</span>
<span class="nc" id="L674">        } else {</span>
<span class="nc" id="L675">            CreateRequest createRequest = (CreateRequest) record;</span>
<span class="nc" id="L676">            flags = createRequest.getFlags();</span>
<span class="nc" id="L677">            path = createRequest.getPath();</span>
<span class="nc" id="L678">            acl = createRequest.getAcl();</span>
<span class="nc" id="L679">            data = createRequest.getData();</span>
<span class="nc" id="L680">            ttl = -1;</span>
        }
<span class="nc" id="L682">        CreateMode createMode = CreateMode.fromFlag(flags);</span>
<span class="nc" id="L683">        validateCreateRequest(path, createMode, request, ttl);</span>
<span class="nc" id="L684">        String parentPath = validatePathForCreate(path, request.sessionId);</span>

<span class="nc" id="L686">        List&lt;ACL&gt; listACL = fixupACL(path, request.authInfo, acl);</span>
<span class="nc" id="L687">        ChangeRecord parentRecord = getRecordForPath(parentPath);</span>

<span class="nc" id="L689">        zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo, path, listACL);</span>
<span class="nc" id="L690">        int parentCVersion = parentRecord.stat.getCversion();</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (createMode.isSequential()) {</span>
<span class="nc" id="L692">            path = path + String.format(Locale.ENGLISH, &quot;%010d&quot;, parentCVersion);</span>
        }
<span class="nc" id="L694">        validatePath(path, request.sessionId);</span>
        try {
<span class="nc bnc" id="L696" title="All 2 branches missed.">            if (getRecordForPath(path) != null) {</span>
<span class="nc" id="L697">                throw new KeeperException.NodeExistsException(path);</span>
            }
<span class="nc" id="L699">        } catch (KeeperException.NoNodeException e) {</span>
            // ignore this one
<span class="nc" id="L701">        }</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">        boolean ephemeralParent = EphemeralType.get(parentRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL;</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">        if (ephemeralParent) {</span>
<span class="nc" id="L704">            throw new KeeperException.NoChildrenForEphemeralsException(path);</span>
        }
<span class="nc" id="L706">        int newCversion = parentRecord.stat.getCversion() + 1;</span>
<span class="nc" id="L707">        zks.checkQuota(path, null, data, OpCode.create);</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">        if (type == OpCode.createContainer) {</span>
<span class="nc" id="L709">            request.setTxn(new CreateContainerTxn(path, data, listACL, newCversion));</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        } else if (type == OpCode.createTTL) {</span>
<span class="nc" id="L711">            request.setTxn(new CreateTTLTxn(path, data, listACL, newCversion, ttl));</span>
        } else {
<span class="nc" id="L713">            request.setTxn(new CreateTxn(path, data, listACL, createMode.isEphemeral(), newCversion));</span>
        }

<span class="nc" id="L716">        TxnHeader hdr = request.getHdr();</span>
<span class="nc" id="L717">        long ephemeralOwner = 0;</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">        if (createMode.isContainer()) {</span>
<span class="nc" id="L719">            ephemeralOwner = EphemeralType.CONTAINER_EPHEMERAL_OWNER;</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">        } else if (createMode.isTTL()) {</span>
<span class="nc" id="L721">            ephemeralOwner = EphemeralType.TTL.toEphemeralOwner(ttl);</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">        } else if (createMode.isEphemeral()) {</span>
<span class="nc" id="L723">            ephemeralOwner = request.sessionId;</span>
        }
<span class="nc" id="L725">        StatPersisted s = DataTree.createStat(hdr.getZxid(), hdr.getTime(), ephemeralOwner);</span>
<span class="nc" id="L726">        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L727">        parentRecord.childCount++;</span>
<span class="nc" id="L728">        parentRecord.stat.setCversion(newCversion);</span>
<span class="nc" id="L729">        parentRecord.stat.setPzxid(request.getHdr().getZxid());</span>
<span class="nc" id="L730">        parentRecord.precalculatedDigest = precalculateDigest(</span>
                DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);
<span class="nc" id="L732">        addChangeRecord(parentRecord);</span>
<span class="nc" id="L733">        ChangeRecord nodeRecord = new ChangeRecord(</span>
<span class="nc" id="L734">                request.getHdr().getZxid(), path, s, 0, listACL);</span>
<span class="nc" id="L735">        nodeRecord.data = data;</span>
<span class="nc" id="L736">        nodeRecord.precalculatedDigest = precalculateDigest(</span>
                DigestOpCode.ADD, path, nodeRecord.data, s);
<span class="nc" id="L738">        setTxnDigest(request, nodeRecord.precalculatedDigest);</span>
<span class="nc" id="L739">        addChangeRecord(nodeRecord);</span>
<span class="nc" id="L740">    }</span>

    private void validatePath(String path, long sessionId) throws BadArgumentsException {
        try {
<span class="nc" id="L744">            PathUtils.validatePath(path);</span>
<span class="nc" id="L745">        } catch (IllegalArgumentException ie) {</span>
<span class="nc" id="L746">            LOG.info(&quot;Invalid path {} with session 0x{}, reason: {}&quot;, path, Long.toHexString(sessionId), ie.getMessage());</span>
<span class="nc" id="L747">            throw new BadArgumentsException(path);</span>
<span class="nc" id="L748">        }</span>
<span class="nc" id="L749">    }</span>

    private String getParentPathAndValidate(String path) throws BadArgumentsException {
<span class="nc" id="L752">        int lastSlash = path.lastIndexOf('/');</span>
<span class="nc bnc" id="L753" title="All 6 branches missed.">        if (lastSlash == -1 || path.indexOf('\0') != -1 || zks.getZKDatabase().isSpecialPath(path)) {</span>
<span class="nc" id="L754">            throw new BadArgumentsException(path);</span>
        }
<span class="nc" id="L756">        return path.substring(0, lastSlash);</span>
    }

    private static int checkAndIncVersion(int currentVersion, int expectedVersion, String path) throws KeeperException.BadVersionException {
<span class="nc bnc" id="L760" title="All 4 branches missed.">        if (expectedVersion != -1 &amp;&amp; expectedVersion != currentVersion) {</span>
<span class="nc" id="L761">            throw new KeeperException.BadVersionException(path);</span>
        }
<span class="nc" id="L763">        return currentVersion + 1;</span>
    }

    /**
     * This method will be called inside the ProcessRequestThread, which is a
     * singleton, so there will be a single thread calling this code.
     *
     * @param request
     */
    protected void pRequest(Request request) throws RequestProcessorException {
        // LOG.info(&quot;Prep&gt;&gt;&gt; cxid = &quot; + request.cxid + &quot; type = &quot; +
        // request.type + &quot; id = 0x&quot; + Long.toHexString(request.sessionId));
<span class="nc" id="L775">        request.setHdr(null);</span>
<span class="nc" id="L776">        request.setTxn(null);</span>

<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (!request.isThrottled()) {</span>
<span class="nc" id="L779">          pRequestHelper(request);</span>
        }

<span class="nc" id="L782">        request.zxid = zks.getZxid();</span>
<span class="nc" id="L783">        long timeFinishedPrepare = Time.currentElapsedTime();</span>
<span class="nc" id="L784">        ServerMetrics.getMetrics().PREP_PROCESS_TIME.add(timeFinishedPrepare - request.prepStartTime);</span>
<span class="nc" id="L785">        nextProcessor.processRequest(request);</span>
<span class="nc" id="L786">        ServerMetrics.getMetrics().PROPOSAL_PROCESS_TIME.add(Time.currentElapsedTime() - timeFinishedPrepare);</span>
<span class="nc" id="L787">    }</span>

    /**
     * This method is a helper to pRequest method
     *
     * @param request
     */
    private void pRequestHelper(Request request) throws RequestProcessorException {
        try {
<span class="nc bnc" id="L796" title="All 11 branches missed.">            switch (request.type) {</span>
            case OpCode.createContainer:
            case OpCode.create:
            case OpCode.create2:
<span class="nc" id="L800">                CreateRequest create2Request = new CreateRequest();</span>
<span class="nc" id="L801">                pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);</span>
<span class="nc" id="L802">                break;</span>
            case OpCode.createTTL:
<span class="nc" id="L804">                CreateTTLRequest createTtlRequest = new CreateTTLRequest();</span>
<span class="nc" id="L805">                pRequest2Txn(request.type, zks.getNextZxid(), request, createTtlRequest, true);</span>
<span class="nc" id="L806">                break;</span>
            case OpCode.deleteContainer:
            case OpCode.delete:
<span class="nc" id="L809">                DeleteRequest deleteRequest = new DeleteRequest();</span>
<span class="nc" id="L810">                pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, true);</span>
<span class="nc" id="L811">                break;</span>
            case OpCode.setData:
<span class="nc" id="L813">                SetDataRequest setDataRequest = new SetDataRequest();</span>
<span class="nc" id="L814">                pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, true);</span>
<span class="nc" id="L815">                break;</span>
            case OpCode.reconfig:
<span class="nc" id="L817">                ReconfigRequest reconfigRequest = new ReconfigRequest();</span>
<span class="nc" id="L818">                ByteBufferInputStream.byteBuffer2Record(request.request, reconfigRequest);</span>
<span class="nc" id="L819">                pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest, true);</span>
<span class="nc" id="L820">                break;</span>
            case OpCode.setACL:
<span class="nc" id="L822">                SetACLRequest setAclRequest = new SetACLRequest();</span>
<span class="nc" id="L823">                pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, true);</span>
<span class="nc" id="L824">                break;</span>
            case OpCode.check:
<span class="nc" id="L826">                CheckVersionRequest checkRequest = new CheckVersionRequest();</span>
<span class="nc" id="L827">                pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, true);</span>
<span class="nc" id="L828">                break;</span>
            case OpCode.multi:
<span class="nc" id="L830">                MultiOperationRecord multiRequest = new MultiOperationRecord();</span>
                try {
<span class="nc" id="L832">                    ByteBufferInputStream.byteBuffer2Record(request.request, multiRequest);</span>
<span class="nc" id="L833">                } catch (IOException e) {</span>
<span class="nc" id="L834">                    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(), Time.currentWallTime(), OpCode.multi));</span>
<span class="nc" id="L835">                    throw e;</span>
<span class="nc" id="L836">                }</span>
<span class="nc" id="L837">                List&lt;Txn&gt; txns = new ArrayList&lt;Txn&gt;();</span>
                //Each op in a multi-op must have the same zxid!
<span class="nc" id="L839">                long zxid = zks.getNextZxid();</span>
<span class="nc" id="L840">                KeeperException ke = null;</span>

                //Store off current pending change records in case we need to rollback
<span class="nc" id="L843">                Map&lt;String, ChangeRecord&gt; pendingChanges = getPendingChanges(multiRequest);</span>
<span class="nc" id="L844">                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,</span>
<span class="nc" id="L845">                        Time.currentWallTime(), request.type));</span>

<span class="nc bnc" id="L847" title="All 2 branches missed.">                for (Op op : multiRequest) {</span>
<span class="nc" id="L848">                    Record subrequest = op.toRequestRecord();</span>
                    int type;
                    Record txn;

                    /* If we've already failed one of the ops, don't bother
                     * trying the rest as we know it's going to fail and it
                     * would be confusing in the logfiles.
                     */
<span class="nc bnc" id="L856" title="All 2 branches missed.">                    if (ke != null) {</span>
<span class="nc" id="L857">                        type = OpCode.error;</span>
<span class="nc" id="L858">                        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());</span>
                    } else {
                        /* Prep the request and convert to a Txn */
                        try {
<span class="nc" id="L862">                            pRequest2Txn(op.getType(), zxid, request, subrequest, false);</span>
<span class="nc" id="L863">                            type = op.getType();</span>
<span class="nc" id="L864">                            txn = request.getTxn();</span>
<span class="nc" id="L865">                        } catch (KeeperException e) {</span>
<span class="nc" id="L866">                            ke = e;</span>
<span class="nc" id="L867">                            type = OpCode.error;</span>
<span class="nc" id="L868">                            txn = new ErrorTxn(e.code().intValue());</span>

<span class="nc bnc" id="L870" title="All 2 branches missed.">                            if (e.code().intValue() &gt; Code.APIERROR.intValue()) {</span>
<span class="nc" id="L871">                                LOG.info(&quot;Got user-level KeeperException when processing {} aborting&quot;</span>
                                         + &quot; remaining multi ops. Error Path:{} Error:{}&quot;,
<span class="nc" id="L873">                                         request.toString(),</span>
<span class="nc" id="L874">                                         e.getPath(),</span>
<span class="nc" id="L875">                                         e.getMessage());</span>
                            }

<span class="nc" id="L878">                            request.setException(e);</span>

                            /* Rollback change records from failed multi-op */
<span class="nc" id="L881">                            rollbackPendingChanges(zxid, pendingChanges);</span>
<span class="nc" id="L882">                        }</span>
                    }

                    // TODO: I don't want to have to serialize it here and then
                    //       immediately deserialize in next processor. But I'm
                    //       not sure how else to get the txn stored into our list.
<span class="nc" id="L888">                    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {</span>
<span class="nc" id="L889">                        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);</span>
<span class="nc" id="L890">                        txn.serialize(boa, &quot;request&quot;);</span>
<span class="nc" id="L891">                        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());</span>
<span class="nc" id="L892">                        txns.add(new Txn(type, bb.array()));</span>
                    }
<span class="nc" id="L894">                }</span>

<span class="nc" id="L896">                request.setTxn(new MultiTxn(txns));</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">                if (digestEnabled) {</span>
<span class="nc" id="L898">                    setTxnDigest(request);</span>
                }

                break;

            //create/close session don't require request record
            case OpCode.createSession:
            case OpCode.closeSession:
<span class="nc bnc" id="L906" title="All 2 branches missed.">                if (!request.isLocalSession()) {</span>
<span class="nc" id="L907">                    pRequest2Txn(request.type, zks.getNextZxid(), request, null, true);</span>
                }
                break;

            //All the rest don't need to create a Txn - just verify session
            case OpCode.sync:
            case OpCode.exists:
            case OpCode.getData:
            case OpCode.getACL:
            case OpCode.getChildren:
            case OpCode.getAllChildrenNumber:
            case OpCode.getChildren2:
            case OpCode.ping:
            case OpCode.setWatches:
            case OpCode.setWatches2:
            case OpCode.checkWatches:
            case OpCode.removeWatches:
            case OpCode.getEphemerals:
            case OpCode.multiRead:
            case OpCode.addWatch:
            case OpCode.whoAmI:
<span class="nc" id="L928">                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
<span class="nc" id="L929">                break;</span>
            default:
<span class="nc" id="L931">                LOG.warn(&quot;unknown type {}&quot;, request.type);</span>
                break;
            }
<span class="nc" id="L934">        } catch (KeeperException e) {</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">            if (request.getHdr() != null) {</span>
<span class="nc" id="L936">                request.getHdr().setType(OpCode.error);</span>
<span class="nc" id="L937">                request.setTxn(new ErrorTxn(e.code().intValue()));</span>
            }

<span class="nc bnc" id="L940" title="All 2 branches missed.">            if (e.code().intValue() &gt; Code.APIERROR.intValue()) {</span>
<span class="nc" id="L941">                LOG.info(</span>
                    &quot;Got user-level KeeperException when processing {} Error Path:{} Error:{}&quot;,
<span class="nc" id="L943">                    request.toString(),</span>
<span class="nc" id="L944">                    e.getPath(),</span>
<span class="nc" id="L945">                    e.getMessage());</span>
            }
<span class="nc" id="L947">            request.setException(e);</span>
<span class="nc" id="L948">        } catch (Exception e) {</span>
            // log at error level as we are returning a marshalling
            // error to the user
<span class="nc" id="L951">            LOG.error(&quot;Failed to process {}&quot;, request, e);</span>

<span class="nc" id="L953">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L954">            ByteBuffer bb = request.request;</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">            if (bb != null) {</span>
<span class="nc" id="L956">                bb.rewind();</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">                while (bb.hasRemaining()) {</span>
<span class="nc" id="L958">                    sb.append(Integer.toHexString(bb.get() &amp; 0xff));</span>
                }
            } else {
<span class="nc" id="L961">                sb.append(&quot;request buffer is null&quot;);</span>
            }

<span class="nc" id="L964">            LOG.error(&quot;Dumping request buffer: 0x{}&quot;, sb.toString());</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">            if (request.getHdr() != null) {</span>
<span class="nc" id="L966">                request.getHdr().setType(OpCode.error);</span>
<span class="nc" id="L967">                request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));</span>
            }
<span class="nc" id="L969">        }</span>
<span class="nc" id="L970">    }</span>

    private static List&lt;ACL&gt; removeDuplicates(final List&lt;ACL&gt; acls) {
<span class="nc bnc" id="L973" title="All 4 branches missed.">        if (acls == null || acls.isEmpty()) {</span>
<span class="nc" id="L974">            return Collections.emptyList();</span>
        }

        // This would be done better with a Set but ACL hashcode/equals do not
        // allow for null values
<span class="nc" id="L979">        final ArrayList&lt;ACL&gt; retval = new ArrayList&lt;&gt;(acls.size());</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">        for (final ACL acl : acls) {</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">            if (!retval.contains(acl)) {</span>
<span class="nc" id="L982">                retval.add(acl);</span>
            }
<span class="nc" id="L984">        }</span>
<span class="nc" id="L985">        return retval;</span>
    }

    private void validateCreateRequest(String path, CreateMode createMode, Request request, long ttl) throws KeeperException {
<span class="nc bnc" id="L989" title="All 4 branches missed.">        if (createMode.isTTL() &amp;&amp; !EphemeralType.extendedEphemeralTypesEnabled()) {</span>
<span class="nc" id="L990">            throw new KeeperException.UnimplementedException();</span>
        }
        try {
<span class="nc" id="L993">            EphemeralType.validateTTL(createMode, ttl);</span>
<span class="nc" id="L994">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L995">            throw new BadArgumentsException(path);</span>
<span class="nc" id="L996">        }</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">        if (createMode.isEphemeral()) {</span>
            // Exception is set when local session failed to upgrade
            // so we just need to report the error
<span class="nc bnc" id="L1000" title="All 2 branches missed.">            if (request.getException() != null) {</span>
<span class="nc" id="L1001">                throw request.getException();</span>
            }
<span class="nc" id="L1003">            zks.sessionTracker.checkGlobalSession(request.sessionId, request.getOwner());</span>
        } else {
<span class="nc" id="L1005">            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
        }
<span class="nc" id="L1007">    }</span>

    /**
     * This method checks out the acl making sure it isn't null or empty,
     * it has valid schemes and ids, and expanding any relative ids that
     * depend on the requestor's authentication information.
     *
     * @param authInfo list of ACL IDs associated with the client connection
     * @param acls list of ACLs being assigned to the node (create or setACL operation)
     * @return verified and expanded ACLs
     * @throws KeeperException.InvalidACLException
     */
    public static List&lt;ACL&gt; fixupACL(String path, List&lt;Id&gt; authInfo, List&lt;ACL&gt; acls) throws KeeperException.InvalidACLException {
        // check for well formed ACLs
        // This resolves https://issues.apache.org/jira/browse/ZOOKEEPER-1877
<span class="nc" id="L1022">        List&lt;ACL&gt; uniqacls = removeDuplicates(acls);</span>
<span class="nc bnc" id="L1023" title="All 4 branches missed.">        if (uniqacls == null || uniqacls.size() == 0) {</span>
<span class="nc" id="L1024">            throw new KeeperException.InvalidACLException(path);</span>
        }
<span class="nc" id="L1026">        List&lt;ACL&gt; rv = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">        for (ACL a : uniqacls) {</span>
<span class="nc" id="L1028">            LOG.debug(&quot;Processing ACL: {}&quot;, a);</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc" id="L1030">                throw new KeeperException.InvalidACLException(path);</span>
            }
<span class="nc" id="L1032">            Id id = a.getId();</span>
<span class="nc bnc" id="L1033" title="All 4 branches missed.">            if (id == null || id.getScheme() == null) {</span>
<span class="nc" id="L1034">                throw new KeeperException.InvalidACLException(path);</span>
            }
<span class="nc bnc" id="L1036" title="All 4 branches missed.">            if (id.getScheme().equals(&quot;world&quot;) &amp;&amp; id.getId().equals(&quot;anyone&quot;)) {</span>
<span class="nc" id="L1037">                rv.add(a);</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">            } else if (id.getScheme().equals(&quot;auth&quot;)) {</span>
                // This is the &quot;auth&quot; id, so we have to expand it to the
                // authenticated ids of the requestor
<span class="nc" id="L1041">                boolean authIdValid = false;</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">                for (Id cid : authInfo) {</span>
<span class="nc" id="L1043">                    ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">                    if (ap == null) {</span>
<span class="nc" id="L1045">                        LOG.error(&quot;Missing AuthenticationProvider for {}&quot;, cid.getScheme());</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                    } else if (ap.isAuthenticated()) {</span>
<span class="nc" id="L1047">                        authIdValid = true;</span>
<span class="nc" id="L1048">                        rv.add(new ACL(a.getPerms(), cid));</span>
                    }
<span class="nc" id="L1050">                }</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">                if (!authIdValid) {</span>
<span class="nc" id="L1052">                    throw new KeeperException.InvalidACLException(path);</span>
                }
<span class="nc" id="L1054">            } else {</span>
<span class="nc" id="L1055">                ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());</span>
<span class="nc bnc" id="L1056" title="All 4 branches missed.">                if (ap == null || !ap.isValid(id.getId())) {</span>
<span class="nc" id="L1057">                    throw new KeeperException.InvalidACLException(path);</span>
                }
<span class="nc" id="L1059">                rv.add(a);</span>
            }
<span class="nc" id="L1061">        }</span>
<span class="nc" id="L1062">        return rv;</span>
    }

    public void processRequest(Request request) {
<span class="nc" id="L1066">        request.prepQueueStartTime = Time.currentElapsedTime();</span>
<span class="nc" id="L1067">        submittedRequests.add(request);</span>
<span class="nc" id="L1068">        ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUED.add(1);</span>
<span class="nc" id="L1069">    }</span>

    public void shutdown() {
<span class="nc" id="L1072">        LOG.info(&quot;Shutting down&quot;);</span>
<span class="nc" id="L1073">        submittedRequests.clear();</span>
<span class="nc" id="L1074">        submittedRequests.add(Request.requestOfDeath);</span>
<span class="nc" id="L1075">        nextProcessor.shutdown();</span>
<span class="nc" id="L1076">    }</span>

    /**
     * Calculate the node digest and tree digest after the change.
     *
     * @param type the type of operations about the digest change
     * @param path the path of the node
     * @param data the data of the node
     * @param s the stat of the node
     *
     * @return PrecalculatedDigest the pair of node and tree digest
     */
    private PrecalculatedDigest precalculateDigest(DigestOpCode type, String path,
            byte[] data, StatPersisted s) throws KeeperException.NoNodeException {

<span class="nc bnc" id="L1091" title="All 2 branches missed.">        if (!digestEnabled) {</span>
<span class="nc" id="L1092">            return null;</span>
        }

        long prevNodeDigest;
        long newNodeDigest;

<span class="nc bnc" id="L1098" title="All 5 branches missed.">        switch (type) {</span>
            case ADD:
<span class="nc" id="L1100">                prevNodeDigest = 0;</span>
<span class="nc" id="L1101">                newNodeDigest = digestCalculator.calculateDigest(path, data, s);</span>
<span class="nc" id="L1102">                break;</span>
            case REMOVE:
<span class="nc" id="L1104">                prevNodeDigest = getRecordForPath(path).precalculatedDigest.nodeDigest;</span>
<span class="nc" id="L1105">                newNodeDigest = 0;</span>
<span class="nc" id="L1106">                break;</span>
            case UPDATE:
<span class="nc" id="L1108">                prevNodeDigest = getRecordForPath(path).precalculatedDigest.nodeDigest;</span>
<span class="nc" id="L1109">                newNodeDigest = digestCalculator.calculateDigest(path, data, s);</span>
<span class="nc" id="L1110">                break;</span>
            case NOOP:
<span class="nc" id="L1112">                newNodeDigest = prevNodeDigest = 0;</span>
<span class="nc" id="L1113">                break;</span>
            default:
<span class="nc" id="L1115">                return null;</span>
        }
<span class="nc" id="L1117">        long treeDigest = getCurrentTreeDigest() - prevNodeDigest + newNodeDigest;</span>
<span class="nc" id="L1118">        return new PrecalculatedDigest(newNodeDigest, treeDigest);</span>
    }

    private PrecalculatedDigest precalculateDigest(
            DigestOpCode type, String path) throws KeeperException.NoNodeException {
<span class="nc" id="L1123">        return precalculateDigest(type, path, null, null);</span>
    }

    /**
     * Query the current tree digest from DataTree or outstandingChanges list.
     *
     * @return current tree digest
     */
    private long getCurrentTreeDigest() {
        long digest;
<span class="nc" id="L1133">        synchronized (zks.outstandingChanges) {</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">            if (zks.outstandingChanges.isEmpty()) {</span>
<span class="nc" id="L1135">                digest = zks.getZKDatabase().getDataTree().getTreeDigest();</span>
<span class="nc" id="L1136">                LOG.debug(&quot;Digest got from data tree is: {}&quot;, digest);</span>
            } else {
<span class="nc" id="L1138">                digest = zks.outstandingChanges.peekLast().precalculatedDigest.treeDigest;</span>
<span class="nc" id="L1139">                LOG.debug(&quot;Digest got from outstandingChanges is: {}&quot;, digest);</span>
            }
<span class="nc" id="L1141">        }</span>
<span class="nc" id="L1142">        return digest;</span>
    }

    private void setTxnDigest(Request request) {
<span class="nc" id="L1146">        request.setTxnDigest(new TxnDigest(digestCalculator.getDigestVersion(), getCurrentTreeDigest()));</span>
<span class="nc" id="L1147">    }</span>

    private void setTxnDigest(Request request, PrecalculatedDigest preCalculatedDigest) {
<span class="nc bnc" id="L1150" title="All 2 branches missed.">        if (preCalculatedDigest == null) {</span>
<span class="nc" id="L1151">            return;</span>
        }
<span class="nc" id="L1153">        request.setTxnDigest(new TxnDigest(digestCalculator.getDigestVersion(), preCalculatedDigest.treeDigest));</span>
<span class="nc" id="L1154">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>