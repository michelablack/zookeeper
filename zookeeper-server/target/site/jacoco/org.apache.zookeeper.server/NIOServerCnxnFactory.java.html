<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NIOServerCnxnFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">NIOServerCnxnFactory.java</span></div><h1>NIOServerCnxnFactory.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * NIOServerCnxnFactory implements a multi-threaded ServerCnxnFactory using
 * NIO non-blocking socket calls. Communication between threads is handled via
 * queues.
 *
 *   - 1   accept thread, which accepts new connections and assigns to a
 *         selector thread
 *   - 1-N selector threads, each of which selects on 1/N of the connections.
 *         The reason the factory supports more than one selector thread is that
 *         with large numbers of connections, select() itself can become a
 *         performance bottleneck.
 *   - 0-M socket I/O worker threads, which perform basic socket reads and
 *         writes. If configured with 0 worker threads, the selector threads
 *         do the socket I/O directly.
 *   - 1   connection expiration thread, which closes idle connections; this is
 *         necessary to expire connections on which no session is established.
 *
 * Typical (default) thread counts are: on a 32 core machine, 1 accept thread,
 * 1 connection expiration thread, 4 selector threads, and 64 worker threads.
 */
public class NIOServerCnxnFactory extends ServerCnxnFactory {

<span class="nc" id="L66">    private static final Logger LOG = LoggerFactory.getLogger(NIOServerCnxnFactory.class);</span>

    /** Default sessionless connection timeout in ms: 10000 (10s) */
    public static final String ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT = &quot;zookeeper.nio.sessionlessCnxnTimeout&quot;;
    /**
     * With 500 connections to an observer with watchers firing on each, is
     * unable to exceed 1GigE rates with only 1 selector.
     * Defaults to using 2 selector threads with 8 cores and 4 with 32 cores.
     * Expressed as sqrt(numCores/2). Must have at least 1 selector thread.
     */
    public static final String ZOOKEEPER_NIO_NUM_SELECTOR_THREADS = &quot;zookeeper.nio.numSelectorThreads&quot;;
    /** Default: 2 * numCores */
    public static final String ZOOKEEPER_NIO_NUM_WORKER_THREADS = &quot;zookeeper.nio.numWorkerThreads&quot;;
    /** Default: 64kB */
    public static final String ZOOKEEPER_NIO_DIRECT_BUFFER_BYTES = &quot;zookeeper.nio.directBufferBytes&quot;;
    /** Default worker pool shutdown timeout in ms: 5000 (5s) */
    public static final String ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT = &quot;zookeeper.nio.shutdownTimeout&quot;;

    static {
<span class="nc" id="L85">        Thread.setDefaultUncaughtExceptionHandler((t, e) -&gt; LOG.error(&quot;Thread {} died&quot;, t, e));</span>

        /**
         * Value of 0 disables use of direct buffers and instead uses
         * gathered write call.
         *
         * Default to using 64k direct buffers.
         */
<span class="nc" id="L93">        directBufferBytes = Integer.getInteger(ZOOKEEPER_NIO_DIRECT_BUFFER_BYTES, 64 * 1024);</span>
    }

    /**
     * AbstractSelectThread is an abstract base class containing a few bits
     * of code shared by the AcceptThread (which selects on the listen socket)
     * and SelectorThread (which selects on client connections) classes.
     */
    private abstract class AbstractSelectThread extends ZooKeeperThread {

        protected final Selector selector;

<span class="nc" id="L105">        public AbstractSelectThread(String name) throws IOException {</span>
<span class="nc" id="L106">            super(name);</span>
            // Allows the JVM to shutdown even if this thread is still running.
<span class="nc" id="L108">            setDaemon(true);</span>
<span class="nc" id="L109">            this.selector = Selector.open();</span>
<span class="nc" id="L110">        }</span>

        public void wakeupSelector() {
<span class="nc" id="L113">            selector.wakeup();</span>
<span class="nc" id="L114">        }</span>

        /**
         * Close the selector. This should be called when the thread is about to
         * exit and no operation is going to be performed on the Selector or
         * SelectionKey
         */
        protected void closeSelector() {
            try {
<span class="nc" id="L123">                selector.close();</span>
<span class="nc" id="L124">            } catch (IOException e) {</span>
<span class="nc" id="L125">                LOG.warn(&quot;ignored exception during selector close.&quot;, e);</span>
<span class="nc" id="L126">            }</span>
<span class="nc" id="L127">        }</span>

        protected void cleanupSelectionKey(SelectionKey key) {
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (key != null) {</span>
                try {
<span class="nc" id="L132">                    key.cancel();</span>
<span class="nc" id="L133">                } catch (Exception ex) {</span>
<span class="nc" id="L134">                    LOG.debug(&quot;ignoring exception during selectionkey cancel&quot;, ex);</span>
<span class="nc" id="L135">                }</span>
            }
<span class="nc" id="L137">        }</span>

        protected void fastCloseSock(SocketChannel sc) {
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (sc != null) {</span>
                try {
                    // Hard close immediately, discarding buffers
<span class="nc" id="L143">                    sc.socket().setSoLinger(true, 0);</span>
<span class="nc" id="L144">                } catch (SocketException e) {</span>
<span class="nc" id="L145">                    LOG.warn(&quot;Unable to set socket linger to 0, socket close may stall in CLOSE_WAIT&quot;, e);</span>
<span class="nc" id="L146">                }</span>
<span class="nc" id="L147">                NIOServerCnxn.closeSock(sc);</span>
            }
<span class="nc" id="L149">        }</span>

    }

    /**
     * There is a single AcceptThread which accepts new connections and assigns
     * them to a SelectorThread using a simple round-robin scheme to spread
     * them across the SelectorThreads. It enforces maximum number of
     * connections per IP and attempts to cope with running out of file
     * descriptors by briefly sleeping before retrying.
     */
    private class AcceptThread extends AbstractSelectThread {

        private final ServerSocketChannel acceptSocket;
        private final SelectionKey acceptKey;
<span class="nc" id="L164">        private final RateLogger acceptErrorLogger = new RateLogger(LOG);</span>
        private final Collection&lt;SelectorThread&gt; selectorThreads;
        private Iterator&lt;SelectorThread&gt; selectorIterator;
<span class="nc" id="L167">        private volatile boolean reconfiguring = false;</span>

<span class="nc" id="L169">        public AcceptThread(ServerSocketChannel ss, InetSocketAddress addr, Set&lt;SelectorThread&gt; selectorThreads) throws IOException {</span>
<span class="nc" id="L170">            super(&quot;NIOServerCxnFactory.AcceptThread:&quot; + addr);</span>
<span class="nc" id="L171">            this.acceptSocket = ss;</span>
<span class="nc" id="L172">            this.acceptKey = acceptSocket.register(selector, SelectionKey.OP_ACCEPT);</span>
<span class="nc" id="L173">            this.selectorThreads = Collections.unmodifiableList(new ArrayList&lt;SelectorThread&gt;(selectorThreads));</span>
<span class="nc" id="L174">            selectorIterator = this.selectorThreads.iterator();</span>
<span class="nc" id="L175">        }</span>

        public void run() {
            try {
<span class="nc bnc" id="L179" title="All 4 branches missed.">                while (!stopped &amp;&amp; !acceptSocket.socket().isClosed()) {</span>
                    try {
<span class="nc" id="L181">                        select();</span>
<span class="nc" id="L182">                    } catch (RuntimeException e) {</span>
<span class="nc" id="L183">                        LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);</span>
<span class="nc" id="L184">                    } catch (Exception e) {</span>
<span class="nc" id="L185">                        LOG.warn(&quot;Ignoring unexpected exception&quot;, e);</span>
<span class="nc" id="L186">                    }</span>
                }
            } finally {
<span class="nc" id="L189">                closeSelector();</span>
                // This will wake up the selector threads, and tell the
                // worker thread pool to begin shutdown.
<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (!reconfiguring) {</span>
<span class="nc" id="L193">                    NIOServerCnxnFactory.this.stop();</span>
                }
<span class="nc" id="L195">                LOG.info(&quot;accept thread exitted run method&quot;);</span>
            }
<span class="nc" id="L197">        }</span>

        public void setReconfiguring() {
<span class="nc" id="L200">            reconfiguring = true;</span>
<span class="nc" id="L201">        }</span>

        private void select() {
            try {
<span class="nc" id="L205">                selector.select();</span>

<span class="nc" id="L207">                Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span>
<span class="nc bnc" id="L208" title="All 4 branches missed.">                while (!stopped &amp;&amp; selectedKeys.hasNext()) {</span>
<span class="nc" id="L209">                    SelectionKey key = selectedKeys.next();</span>
<span class="nc" id="L210">                    selectedKeys.remove();</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">                    if (!key.isValid()) {</span>
<span class="nc" id="L213">                        continue;</span>
                    }
<span class="nc bnc" id="L215" title="All 2 branches missed.">                    if (key.isAcceptable()) {</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                        if (!doAccept()) {</span>
                            // If unable to pull a new connection off the accept
                            // queue, pause accepting to give us time to free
                            // up file descriptors and so the accept thread
                            // doesn't spin in a tight loop.
<span class="nc" id="L221">                            pauseAccept(10);</span>
                        }
                    } else {
<span class="nc" id="L224">                        LOG.warn(&quot;Unexpected ops in accept select {}&quot;, key.readyOps());</span>
                    }
<span class="nc" id="L226">                }</span>
<span class="nc" id="L227">            } catch (IOException e) {</span>
<span class="nc" id="L228">                LOG.warn(&quot;Ignoring IOException while selecting&quot;, e);</span>
<span class="nc" id="L229">            }</span>
<span class="nc" id="L230">        }</span>

        /**
         * Mask off the listen socket interest ops and use select() to sleep
         * so that other threads can wake us up by calling wakeup() on the
         * selector.
         */
        private void pauseAccept(long millisecs) {
<span class="nc" id="L238">            acceptKey.interestOps(0);</span>
            try {
<span class="nc" id="L240">                selector.select(millisecs);</span>
<span class="nc" id="L241">            } catch (IOException e) {</span>
                // ignore
            } finally {
<span class="nc" id="L244">                acceptKey.interestOps(SelectionKey.OP_ACCEPT);</span>
            }
<span class="nc" id="L246">        }</span>

        /**
         * Accept new socket connections. Enforces maximum number of connections
         * per client IP address. Round-robin assigns to selector thread for
         * handling. Returns whether pulled a connection off the accept queue
         * or not. If encounters an error attempts to fast close the socket.
         *
         * @return whether was able to accept a connection or not
         */
        private boolean doAccept() {
<span class="nc" id="L257">            boolean accepted = false;</span>
<span class="nc" id="L258">            SocketChannel sc = null;</span>
            try {
<span class="nc" id="L260">                sc = acceptSocket.accept();</span>
<span class="nc" id="L261">                accepted = true;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                if (limitTotalNumberOfCnxns()) {</span>
<span class="nc" id="L263">                    throw new IOException(&quot;Too many connections max allowed is &quot; + maxCnxns);</span>
                }
<span class="nc" id="L265">                InetAddress ia = sc.socket().getInetAddress();</span>
<span class="nc" id="L266">                int cnxncount = getClientCnxnCount(ia);</span>

<span class="nc bnc" id="L268" title="All 4 branches missed.">                if (maxClientCnxns &gt; 0 &amp;&amp; cnxncount &gt;= maxClientCnxns) {</span>
<span class="nc" id="L269">                    throw new IOException(&quot;Too many connections from &quot; + ia + &quot; - max is &quot; + maxClientCnxns);</span>
                }

<span class="nc" id="L272">                LOG.debug(&quot;Accepted socket connection from {}&quot;, sc.socket().getRemoteSocketAddress());</span>

<span class="nc" id="L274">                sc.configureBlocking(false);</span>

                // Round-robin assign this connection to a selector thread
<span class="nc bnc" id="L277" title="All 2 branches missed.">                if (!selectorIterator.hasNext()) {</span>
<span class="nc" id="L278">                    selectorIterator = selectorThreads.iterator();</span>
                }
<span class="nc" id="L280">                SelectorThread selectorThread = selectorIterator.next();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">                if (!selectorThread.addAcceptedConnection(sc)) {</span>
<span class="nc" id="L282">                    throw new IOException(&quot;Unable to add connection to selector queue&quot;</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                                          + (stopped ? &quot; (shutdown in progress)&quot; : &quot;&quot;));</span>
                }
<span class="nc" id="L285">                acceptErrorLogger.flush();</span>
<span class="nc" id="L286">            } catch (IOException e) {</span>
                // accept, maxClientCnxns, configureBlocking
<span class="nc" id="L288">                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);</span>
<span class="nc" id="L289">                acceptErrorLogger.rateLimitLog(&quot;Error accepting new connection: &quot; + e.getMessage());</span>
<span class="nc" id="L290">                fastCloseSock(sc);</span>
<span class="nc" id="L291">            }</span>
<span class="nc" id="L292">            return accepted;</span>
        }

    }

    /**
     * The SelectorThread receives newly accepted connections from the
     * AcceptThread and is responsible for selecting for I/O readiness
     * across the connections. This thread is the only thread that performs
     * any non-threadsafe or potentially blocking calls on the selector
     * (registering new connections and reading/writing interest ops).
     *
     * Assignment of a connection to a SelectorThread is permanent and only
     * one SelectorThread will ever interact with the connection. There are
     * 1-N SelectorThreads, with connections evenly apportioned between the
     * SelectorThreads.
     *
     * If there is a worker thread pool, when a connection has I/O to perform
     * the SelectorThread removes it from selection by clearing its interest
     * ops and schedules the I/O for processing by a worker thread. When the
     * work is complete, the connection is placed on the ready queue to have
     * its interest ops restored and resume selection.
     *
     * If there is no worker thread pool, the SelectorThread performs the I/O
     * directly.
     */
    public class SelectorThread extends AbstractSelectThread {

        private final int id;
        private final Queue&lt;SocketChannel&gt; acceptedQueue;
        private final Queue&lt;SelectionKey&gt; updateQueue;

<span class="nc" id="L324">        public SelectorThread(int id) throws IOException {</span>
<span class="nc" id="L325">            super(&quot;NIOServerCxnFactory.SelectorThread-&quot; + id);</span>
<span class="nc" id="L326">            this.id = id;</span>
<span class="nc" id="L327">            acceptedQueue = new LinkedBlockingQueue&lt;SocketChannel&gt;();</span>
<span class="nc" id="L328">            updateQueue = new LinkedBlockingQueue&lt;SelectionKey&gt;();</span>
<span class="nc" id="L329">        }</span>

        /**
         * Place new accepted connection onto a queue for adding. Do this
         * so only the selector thread modifies what keys are registered
         * with the selector.
         */
        public boolean addAcceptedConnection(SocketChannel accepted) {
<span class="nc bnc" id="L337" title="All 4 branches missed.">            if (stopped || !acceptedQueue.offer(accepted)) {</span>
<span class="nc" id="L338">                return false;</span>
            }
<span class="nc" id="L340">            wakeupSelector();</span>
<span class="nc" id="L341">            return true;</span>
        }

        /**
         * Place interest op update requests onto a queue so that only the
         * selector thread modifies interest ops, because interest ops
         * reads/sets are potentially blocking operations if other select
         * operations are happening.
         */
        public boolean addInterestOpsUpdateRequest(SelectionKey sk) {
<span class="nc bnc" id="L351" title="All 4 branches missed.">            if (stopped || !updateQueue.offer(sk)) {</span>
<span class="nc" id="L352">                return false;</span>
            }
<span class="nc" id="L354">            wakeupSelector();</span>
<span class="nc" id="L355">            return true;</span>
        }

        /**
         * The main loop for the thread selects() on the connections and
         * dispatches ready I/O work requests, then registers all pending
         * newly accepted connections and updates any interest ops on the
         * queue.
         */
        public void run() {
            try {
<span class="nc bnc" id="L366" title="All 2 branches missed.">                while (!stopped) {</span>
                    try {
<span class="nc" id="L368">                        select();</span>
<span class="nc" id="L369">                        processAcceptedConnections();</span>
<span class="nc" id="L370">                        processInterestOpsUpdateRequests();</span>
<span class="nc" id="L371">                    } catch (RuntimeException e) {</span>
<span class="nc" id="L372">                        LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);</span>
<span class="nc" id="L373">                    } catch (Exception e) {</span>
<span class="nc" id="L374">                        LOG.warn(&quot;Ignoring unexpected exception&quot;, e);</span>
<span class="nc" id="L375">                    }</span>
                }

                // Close connections still pending on the selector. Any others
                // with in-flight work, let drain out of the work queue.
<span class="nc bnc" id="L380" title="All 2 branches missed.">                for (SelectionKey key : selector.keys()) {</span>
<span class="nc" id="L381">                    NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">                    if (cnxn.isSelectable()) {</span>
<span class="nc" id="L383">                        cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);</span>
                    }
<span class="nc" id="L385">                    cleanupSelectionKey(key);</span>
<span class="nc" id="L386">                }</span>
                SocketChannel accepted;
<span class="nc bnc" id="L388" title="All 2 branches missed.">                while ((accepted = acceptedQueue.poll()) != null) {</span>
<span class="nc" id="L389">                    fastCloseSock(accepted);</span>
                }
<span class="nc" id="L391">                updateQueue.clear();</span>
            } finally {
<span class="nc" id="L393">                closeSelector();</span>
                // This will wake up the accept thread and the other selector
                // threads, and tell the worker thread pool to begin shutdown.
<span class="nc" id="L396">                NIOServerCnxnFactory.this.stop();</span>
<span class="nc" id="L397">                LOG.info(&quot;selector thread exitted run method&quot;);</span>
            }
<span class="nc" id="L399">        }</span>

        private void select() {
            try {
<span class="nc" id="L403">                selector.select();</span>

<span class="nc" id="L405">                Set&lt;SelectionKey&gt; selected = selector.selectedKeys();</span>
<span class="nc" id="L406">                ArrayList&lt;SelectionKey&gt; selectedList = new ArrayList&lt;SelectionKey&gt;(selected);</span>
<span class="nc" id="L407">                Collections.shuffle(selectedList);</span>
<span class="nc" id="L408">                Iterator&lt;SelectionKey&gt; selectedKeys = selectedList.iterator();</span>
<span class="nc bnc" id="L409" title="All 4 branches missed.">                while (!stopped &amp;&amp; selectedKeys.hasNext()) {</span>
<span class="nc" id="L410">                    SelectionKey key = selectedKeys.next();</span>
<span class="nc" id="L411">                    selected.remove(key);</span>

<span class="nc bnc" id="L413" title="All 2 branches missed.">                    if (!key.isValid()) {</span>
<span class="nc" id="L414">                        cleanupSelectionKey(key);</span>
<span class="nc" id="L415">                        continue;</span>
                    }
<span class="nc bnc" id="L417" title="All 4 branches missed.">                    if (key.isReadable() || key.isWritable()) {</span>
<span class="nc" id="L418">                        handleIO(key);</span>
                    } else {
<span class="nc" id="L420">                        LOG.warn(&quot;Unexpected ops in select {}&quot;, key.readyOps());</span>
                    }
<span class="nc" id="L422">                }</span>
<span class="nc" id="L423">            } catch (IOException e) {</span>
<span class="nc" id="L424">                LOG.warn(&quot;Ignoring IOException while selecting&quot;, e);</span>
<span class="nc" id="L425">            }</span>
<span class="nc" id="L426">        }</span>

        /**
         * Schedule I/O for processing on the connection associated with
         * the given SelectionKey. If a worker thread pool is not being used,
         * I/O is run directly by this thread.
         */
        private void handleIO(SelectionKey key) {
<span class="nc" id="L434">            IOWorkRequest workRequest = new IOWorkRequest(this, key);</span>
<span class="nc" id="L435">            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span>

            // Stop selecting this key while processing on its
            // connection
<span class="nc" id="L439">            cnxn.disableSelectable();</span>
<span class="nc" id="L440">            key.interestOps(0);</span>
<span class="nc" id="L441">            touchCnxn(cnxn);</span>
<span class="nc" id="L442">            workerPool.schedule(workRequest);</span>
<span class="nc" id="L443">        }</span>

        /**
         * Iterate over the queue of accepted connections that have been
         * assigned to this thread but not yet placed on the selector.
         */
        private void processAcceptedConnections() {
            SocketChannel accepted;
<span class="nc bnc" id="L451" title="All 4 branches missed.">            while (!stopped &amp;&amp; (accepted = acceptedQueue.poll()) != null) {</span>
<span class="nc" id="L452">                SelectionKey key = null;</span>
                try {
<span class="nc" id="L454">                    key = accepted.register(selector, SelectionKey.OP_READ);</span>
<span class="nc" id="L455">                    NIOServerCnxn cnxn = createConnection(accepted, key, this);</span>
<span class="nc" id="L456">                    key.attach(cnxn);</span>
<span class="nc" id="L457">                    addCnxn(cnxn);</span>
<span class="nc" id="L458">                } catch (IOException e) {</span>
                    // register, createConnection
<span class="nc" id="L460">                    cleanupSelectionKey(key);</span>
<span class="nc" id="L461">                    fastCloseSock(accepted);</span>
<span class="nc" id="L462">                }</span>
<span class="nc" id="L463">            }</span>
<span class="nc" id="L464">        }</span>

        /**
         * Iterate over the queue of connections ready to resume selection,
         * and restore their interest ops selection mask.
         */
        private void processInterestOpsUpdateRequests() {
            SelectionKey key;
<span class="nc bnc" id="L472" title="All 4 branches missed.">            while (!stopped &amp;&amp; (key = updateQueue.poll()) != null) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                if (!key.isValid()) {</span>
<span class="nc" id="L474">                    cleanupSelectionKey(key);</span>
                }
<span class="nc" id="L476">                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">                if (cnxn.isSelectable()) {</span>
<span class="nc" id="L478">                    key.interestOps(cnxn.getInterestOps());</span>
                }
<span class="nc" id="L480">            }</span>
<span class="nc" id="L481">        }</span>

    }

    /**
     * IOWorkRequest is a small wrapper class to allow doIO() calls to be
     * run on a connection using a WorkerService.
     */
    private class IOWorkRequest extends WorkerService.WorkRequest {

        private final SelectorThread selectorThread;
        private final SelectionKey key;
        private final NIOServerCnxn cnxn;

<span class="nc" id="L495">        IOWorkRequest(SelectorThread selectorThread, SelectionKey key) {</span>
<span class="nc" id="L496">            this.selectorThread = selectorThread;</span>
<span class="nc" id="L497">            this.key = key;</span>
<span class="nc" id="L498">            this.cnxn = (NIOServerCnxn) key.attachment();</span>
<span class="nc" id="L499">        }</span>

        public void doWork() throws InterruptedException {
<span class="nc bnc" id="L502" title="All 2 branches missed.">            if (!key.isValid()) {</span>
<span class="nc" id="L503">                selectorThread.cleanupSelectionKey(key);</span>
<span class="nc" id="L504">                return;</span>
            }

<span class="nc bnc" id="L507" title="All 4 branches missed.">            if (key.isReadable() || key.isWritable()) {</span>
<span class="nc" id="L508">                cnxn.doIO(key);</span>

                // Check if we shutdown or doIO() closed this connection
<span class="nc bnc" id="L511" title="All 2 branches missed.">                if (stopped) {</span>
<span class="nc" id="L512">                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);</span>
<span class="nc" id="L513">                    return;</span>
                }
<span class="nc bnc" id="L515" title="All 2 branches missed.">                if (!key.isValid()) {</span>
<span class="nc" id="L516">                    selectorThread.cleanupSelectionKey(key);</span>
<span class="nc" id="L517">                    return;</span>
                }
<span class="nc" id="L519">                touchCnxn(cnxn);</span>
            }

            // Mark this connection as once again ready for selection
<span class="nc" id="L523">            cnxn.enableSelectable();</span>
            // Push an update request on the queue to resume selecting
            // on the current set of interest ops, which may have changed
            // as a result of the I/O operations we just performed.
<span class="nc bnc" id="L527" title="All 2 branches missed.">            if (!selectorThread.addInterestOpsUpdateRequest(key)) {</span>
<span class="nc" id="L528">                cnxn.close(ServerCnxn.DisconnectReason.CONNECTION_MODE_CHANGED);</span>
            }
<span class="nc" id="L530">        }</span>

        @Override
        public void cleanup() {
<span class="nc" id="L534">            cnxn.close(ServerCnxn.DisconnectReason.CLEAN_UP);</span>
<span class="nc" id="L535">        }</span>

    }

    /**
     * This thread is responsible for closing stale connections so that
     * connections on which no session is established are properly expired.
     */
    private class ConnectionExpirerThread extends ZooKeeperThread {

<span class="nc" id="L545">        ConnectionExpirerThread() {</span>
<span class="nc" id="L546">            super(&quot;ConnnectionExpirer&quot;);</span>
<span class="nc" id="L547">        }</span>

        public void run() {
            try {
<span class="nc bnc" id="L551" title="All 2 branches missed.">                while (!stopped) {</span>
<span class="nc" id="L552">                    long waitTime = cnxnExpiryQueue.getWaitTime();</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                    if (waitTime &gt; 0) {</span>
<span class="nc" id="L554">                        Thread.sleep(waitTime);</span>
<span class="nc" id="L555">                        continue;</span>
                    }
<span class="nc bnc" id="L557" title="All 2 branches missed.">                    for (NIOServerCnxn conn : cnxnExpiryQueue.poll()) {</span>
<span class="nc" id="L558">                        ServerMetrics.getMetrics().SESSIONLESS_CONNECTIONS_EXPIRED.add(1);</span>
<span class="nc" id="L559">                        conn.close(ServerCnxn.DisconnectReason.CONNECTION_EXPIRED);</span>
<span class="nc" id="L560">                    }</span>
<span class="nc" id="L561">                }</span>

<span class="nc" id="L563">            } catch (InterruptedException e) {</span>
<span class="nc" id="L564">                LOG.info(&quot;ConnnectionExpirerThread interrupted&quot;);</span>
<span class="nc" id="L565">            }</span>
<span class="nc" id="L566">        }</span>

    }

    ServerSocketChannel ss;

    /**
     * We use this buffer to do efficient socket I/O. Because I/O is handled
     * by the worker threads (or the selector threads directly, if no worker
     * thread pool is created), we can create a fixed set of these to be
     * shared by connections.
     */
<span class="nc" id="L578">    private static final ThreadLocal&lt;ByteBuffer&gt; directBuffer = new ThreadLocal&lt;ByteBuffer&gt;() {</span>
        @Override
        protected ByteBuffer initialValue() {
<span class="nc" id="L581">            return ByteBuffer.allocateDirect(directBufferBytes);</span>
        }
    };

    public static ByteBuffer getDirectBuffer() {
<span class="nc bnc" id="L586" title="All 2 branches missed.">        return directBufferBytes &gt; 0 ? directBuffer.get() : null;</span>
    }

    // ipMap is used to limit connections per IP
<span class="nc" id="L590">    private final ConcurrentHashMap&lt;InetAddress, Set&lt;NIOServerCnxn&gt;&gt; ipMap = new ConcurrentHashMap&lt;InetAddress, Set&lt;NIOServerCnxn&gt;&gt;();</span>

<span class="nc" id="L592">    protected int maxClientCnxns = 60;</span>
<span class="nc" id="L593">    int listenBacklog = -1;</span>

    int sessionlessCnxnTimeout;
    private ExpiryQueue&lt;NIOServerCnxn&gt; cnxnExpiryQueue;

    protected WorkerService workerPool;

    private static int directBufferBytes;
    private int numSelectorThreads;
    private int numWorkerThreads;
    private long workerShutdownTimeoutMS;

    /**
     * Construct a new server connection factory which will accept an unlimited number
     * of concurrent connections from each client (up to the file descriptor
     * limits of the operating system). startup(zks) must be called subsequently.
     */
<span class="nc" id="L610">    public NIOServerCnxnFactory() {</span>
<span class="nc" id="L611">    }</span>

<span class="nc" id="L613">    private volatile boolean stopped = true;</span>
    private ConnectionExpirerThread expirerThread;
    private AcceptThread acceptThread;
<span class="nc" id="L616">    private final Set&lt;SelectorThread&gt; selectorThreads = new HashSet&lt;SelectorThread&gt;();</span>

    @Override
    public void configure(InetSocketAddress addr, int maxcc, int backlog, boolean secure) throws IOException {
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (secure) {</span>
<span class="nc" id="L621">            throw new UnsupportedOperationException(&quot;SSL isn't supported in NIOServerCnxn&quot;);</span>
        }
<span class="nc" id="L623">        configureSaslLogin();</span>

<span class="nc" id="L625">        maxClientCnxns = maxcc;</span>
<span class="nc" id="L626">        initMaxCnxns();</span>
<span class="nc" id="L627">        sessionlessCnxnTimeout = Integer.getInteger(ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);</span>
        // We also use the sessionlessCnxnTimeout as expiring interval for
        // cnxnExpiryQueue. These don't need to be the same, but the expiring
        // interval passed into the ExpiryQueue() constructor below should be
        // less than or equal to the timeout.
<span class="nc" id="L632">        cnxnExpiryQueue = new ExpiryQueue&lt;NIOServerCnxn&gt;(sessionlessCnxnTimeout);</span>
<span class="nc" id="L633">        expirerThread = new ConnectionExpirerThread();</span>

<span class="nc" id="L635">        int numCores = Runtime.getRuntime().availableProcessors();</span>
        // 32 cores sweet spot seems to be 4 selector threads
<span class="nc" id="L637">        numSelectorThreads = Integer.getInteger(</span>
            ZOOKEEPER_NIO_NUM_SELECTOR_THREADS,
<span class="nc" id="L639">            Math.max((int) Math.sqrt((float) numCores / 2), 1));</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (numSelectorThreads &lt; 1) {</span>
<span class="nc" id="L641">            throw new IOException(&quot;numSelectorThreads must be at least 1&quot;);</span>
        }

<span class="nc" id="L644">        numWorkerThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);</span>
<span class="nc" id="L645">        workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);</span>

<span class="nc" id="L647">        String logMsg = &quot;Configuring NIO connection handler with &quot;</span>
            + (sessionlessCnxnTimeout / 1000) + &quot;s sessionless connection timeout, &quot;
            + numSelectorThreads + &quot; selector thread(s), &quot;
<span class="nc bnc" id="L650" title="All 2 branches missed.">            + (numWorkerThreads &gt; 0 ? numWorkerThreads : &quot;no&quot;) + &quot; worker threads, and &quot;</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">            + (directBufferBytes == 0 ? &quot;gathered writes.&quot; : (&quot;&quot; + (directBufferBytes / 1024) + &quot; kB direct buffers.&quot;));</span>
<span class="nc" id="L652">        LOG.info(logMsg);</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">        for (int i = 0; i &lt; numSelectorThreads; ++i) {</span>
<span class="nc" id="L654">            selectorThreads.add(new SelectorThread(i));</span>
        }

<span class="nc" id="L657">        listenBacklog = backlog;</span>
<span class="nc" id="L658">        this.ss = ServerSocketChannel.open();</span>
<span class="nc" id="L659">        ss.socket().setReuseAddress(true);</span>
<span class="nc" id="L660">        LOG.info(&quot;binding to port {}&quot;, addr);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (listenBacklog == -1) {</span>
<span class="nc" id="L662">            ss.socket().bind(addr);</span>
        } else {
<span class="nc" id="L664">            ss.socket().bind(addr, listenBacklog);</span>
        }
<span class="nc" id="L666">        ss.configureBlocking(false);</span>
<span class="nc" id="L667">        acceptThread = new AcceptThread(ss, addr, selectorThreads);</span>
<span class="nc" id="L668">    }</span>

    private void tryClose(ServerSocketChannel s) {
        try {
<span class="nc" id="L672">            s.close();</span>
<span class="nc" id="L673">        } catch (IOException sse) {</span>
<span class="nc" id="L674">            LOG.error(&quot;Error while closing server socket.&quot;, sse);</span>
<span class="nc" id="L675">        }</span>
<span class="nc" id="L676">    }</span>

    @Override
    public void reconfigure(InetSocketAddress addr) {
<span class="nc" id="L680">        ServerSocketChannel oldSS = ss;</span>
        try {
<span class="nc" id="L682">            acceptThread.setReconfiguring();</span>
<span class="nc" id="L683">            tryClose(oldSS);</span>
<span class="nc" id="L684">            acceptThread.wakeupSelector();</span>
            try {
<span class="nc" id="L686">                acceptThread.join();</span>
<span class="nc" id="L687">            } catch (InterruptedException e) {</span>
<span class="nc" id="L688">                LOG.error(&quot;Error joining old acceptThread when reconfiguring client port.&quot;, e);</span>
<span class="nc" id="L689">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L690">            }</span>
<span class="nc" id="L691">            this.ss = ServerSocketChannel.open();</span>
<span class="nc" id="L692">            ss.socket().setReuseAddress(true);</span>
<span class="nc" id="L693">            LOG.info(&quot;binding to port {}&quot;, addr);</span>
<span class="nc" id="L694">            ss.socket().bind(addr);</span>
<span class="nc" id="L695">            ss.configureBlocking(false);</span>
<span class="nc" id="L696">            acceptThread = new AcceptThread(ss, addr, selectorThreads);</span>
<span class="nc" id="L697">            acceptThread.start();</span>
<span class="nc" id="L698">        } catch (IOException e) {</span>
<span class="nc" id="L699">            LOG.error(&quot;Error reconfiguring client port to {}&quot;, addr, e);</span>
<span class="nc" id="L700">            tryClose(oldSS);</span>
<span class="nc" id="L701">        }</span>
<span class="nc" id="L702">    }</span>

    /** {@inheritDoc} */
    public int getMaxClientCnxnsPerHost() {
<span class="nc" id="L706">        return maxClientCnxns;</span>
    }

    /** {@inheritDoc} */
    public void setMaxClientCnxnsPerHost(int max) {
<span class="nc" id="L711">        maxClientCnxns = max;</span>
<span class="nc" id="L712">    }</span>

    /** {@inheritDoc} */
    public int getSocketListenBacklog() {
<span class="nc" id="L716">        return listenBacklog;</span>
    }

    @Override
    public void start() {
<span class="nc" id="L721">        stopped = false;</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">        if (workerPool == null) {</span>
<span class="nc" id="L723">            workerPool = new WorkerService(&quot;NIOWorker&quot;, numWorkerThreads, false);</span>
        }
<span class="nc bnc" id="L725" title="All 2 branches missed.">        for (SelectorThread thread : selectorThreads) {</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">            if (thread.getState() == Thread.State.NEW) {</span>
<span class="nc" id="L727">                thread.start();</span>
            }
<span class="nc" id="L729">        }</span>
        // ensure thread is started once and only once
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (acceptThread.getState() == Thread.State.NEW) {</span>
<span class="nc" id="L732">            acceptThread.start();</span>
        }
<span class="nc bnc" id="L734" title="All 2 branches missed.">        if (expirerThread.getState() == Thread.State.NEW) {</span>
<span class="nc" id="L735">            expirerThread.start();</span>
        }
<span class="nc" id="L737">    }</span>

    @Override
    public void startup(ZooKeeperServer zks, boolean startServer) throws IOException, InterruptedException {
<span class="nc" id="L741">        start();</span>
<span class="nc" id="L742">        setZooKeeperServer(zks);</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (startServer) {</span>
<span class="nc" id="L744">            zks.startdata();</span>
<span class="nc" id="L745">            zks.startup();</span>
        }
<span class="nc" id="L747">    }</span>

    @Override
    public InetSocketAddress getLocalAddress() {
<span class="nc" id="L751">        return (InetSocketAddress) ss.socket().getLocalSocketAddress();</span>
    }

    @Override
    public int getLocalPort() {
<span class="nc" id="L756">        return ss.socket().getLocalPort();</span>
    }

    /**
     * De-registers the connection from the various mappings maintained
     * by the factory.
     */
    public boolean removeCnxn(NIOServerCnxn cnxn) {
        // If the connection is not in the master list it's already been closed
<span class="nc bnc" id="L765" title="All 2 branches missed.">        if (!cnxns.remove(cnxn)) {</span>
<span class="nc" id="L766">            return false;</span>
        }
<span class="nc" id="L768">        cnxnExpiryQueue.remove(cnxn);</span>

<span class="nc" id="L770">        removeCnxnFromSessionMap(cnxn);</span>

<span class="nc" id="L772">        InetAddress addr = cnxn.getSocketAddress();</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">        if (addr != null) {</span>
<span class="nc" id="L774">            Set&lt;NIOServerCnxn&gt; set = ipMap.get(addr);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">            if (set != null) {</span>
<span class="nc" id="L776">                set.remove(cnxn);</span>
                // Note that we make no effort here to remove empty mappings
                // from ipMap.
            }
        }

        // unregister from JMX
<span class="nc" id="L783">        unregisterConnection(cnxn);</span>
<span class="nc" id="L784">        return true;</span>
    }

    /**
     * Add or update cnxn in our cnxnExpiryQueue
     * @param cnxn
     */
    public void touchCnxn(NIOServerCnxn cnxn) {
<span class="nc" id="L792">        cnxnExpiryQueue.update(cnxn, cnxn.getSessionTimeout());</span>
<span class="nc" id="L793">    }</span>

    private void addCnxn(NIOServerCnxn cnxn) throws IOException {
<span class="nc" id="L796">        InetAddress addr = cnxn.getSocketAddress();</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (addr == null) {</span>
<span class="nc" id="L798">            throw new IOException(&quot;Socket of &quot; + cnxn + &quot; has been closed&quot;);</span>
        }
<span class="nc" id="L800">        Set&lt;NIOServerCnxn&gt; set = ipMap.get(addr);</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">        if (set == null) {</span>
            // in general we will see 1 connection from each
            // host, setting the initial cap to 2 allows us
            // to minimize mem usage in the common case
            // of 1 entry --  we need to set the initial cap
            // to 2 to avoid rehash when the first entry is added
            // Construct a ConcurrentHashSet using a ConcurrentHashMap
<span class="nc" id="L808">            set = Collections.newSetFromMap(new ConcurrentHashMap&lt;NIOServerCnxn, Boolean&gt;(2));</span>
            // Put the new set in the map, but only if another thread
            // hasn't beaten us to it
<span class="nc" id="L811">            Set&lt;NIOServerCnxn&gt; existingSet = ipMap.putIfAbsent(addr, set);</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">            if (existingSet != null) {</span>
<span class="nc" id="L813">                set = existingSet;</span>
            }
        }
<span class="nc" id="L816">        set.add(cnxn);</span>

<span class="nc" id="L818">        cnxns.add(cnxn);</span>
<span class="nc" id="L819">        touchCnxn(cnxn);</span>
<span class="nc" id="L820">    }</span>

    protected NIOServerCnxn createConnection(SocketChannel sock, SelectionKey sk, SelectorThread selectorThread) throws IOException {
<span class="nc" id="L823">        return new NIOServerCnxn(zkServer, sock, sk, this, selectorThread);</span>
    }

    private int getClientCnxnCount(InetAddress cl) {
<span class="nc" id="L827">        Set&lt;NIOServerCnxn&gt; s = ipMap.get(cl);</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L829">            return 0;</span>
        }
<span class="nc" id="L831">        return s.size();</span>
    }

    /**
     * clear all the connections in the selector
     *
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void closeAll(ServerCnxn.DisconnectReason reason) {
        // clear all the connections on which we are selecting
<span class="nc bnc" id="L842" title="All 2 branches missed.">        for (ServerCnxn cnxn : cnxns) {</span>
            try {
                // This will remove the cnxn from cnxns
<span class="nc" id="L845">                cnxn.close(reason);</span>
<span class="nc" id="L846">            } catch (Exception e) {</span>
<span class="nc" id="L847">                LOG.warn(</span>
                    &quot;Ignoring exception closing cnxn session id 0x{}&quot;,
<span class="nc" id="L849">                    Long.toHexString(cnxn.getSessionId()),</span>
                    e);
<span class="nc" id="L851">            }</span>
<span class="nc" id="L852">        }</span>
<span class="nc" id="L853">    }</span>

    public void stop() {
<span class="nc" id="L856">        stopped = true;</span>

        // Stop queuing connection attempts
        try {
<span class="nc" id="L860">            ss.close();</span>
<span class="nc" id="L861">        } catch (IOException e) {</span>
<span class="nc" id="L862">            LOG.warn(&quot;Error closing listen socket&quot;, e);</span>
<span class="nc" id="L863">        }</span>

<span class="nc bnc" id="L865" title="All 2 branches missed.">        if (acceptThread != null) {</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">            if (acceptThread.isAlive()) {</span>
<span class="nc" id="L867">                acceptThread.wakeupSelector();</span>
            } else {
<span class="nc" id="L869">                acceptThread.closeSelector();</span>
            }
        }
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (expirerThread != null) {</span>
<span class="nc" id="L873">            expirerThread.interrupt();</span>
        }
<span class="nc bnc" id="L875" title="All 2 branches missed.">        for (SelectorThread thread : selectorThreads) {</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">            if (thread.isAlive()) {</span>
<span class="nc" id="L877">                thread.wakeupSelector();</span>
            } else {
<span class="nc" id="L879">                thread.closeSelector();</span>
            }
<span class="nc" id="L881">        }</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        if (workerPool != null) {</span>
<span class="nc" id="L883">            workerPool.stop();</span>
        }
<span class="nc" id="L885">    }</span>

    public void shutdown() {
        try {
            // close listen socket and signal selector threads to stop
<span class="nc" id="L890">            stop();</span>

            // wait for selector and worker threads to shutdown
<span class="nc" id="L893">            join();</span>

            // close all open connections
<span class="nc" id="L896">            closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);</span>

<span class="nc bnc" id="L898" title="All 2 branches missed.">            if (login != null) {</span>
<span class="nc" id="L899">                login.shutdown();</span>
            }
<span class="nc" id="L901">        } catch (InterruptedException e) {</span>
<span class="nc" id="L902">            LOG.warn(&quot;Ignoring interrupted exception during shutdown&quot;, e);</span>
<span class="nc" id="L903">        } catch (Exception e) {</span>
<span class="nc" id="L904">            LOG.warn(&quot;Ignoring unexpected exception during shutdown&quot;, e);</span>
<span class="nc" id="L905">        }</span>

<span class="nc bnc" id="L907" title="All 2 branches missed.">        if (zkServer != null) {</span>
<span class="nc" id="L908">            zkServer.shutdown();</span>
        }
<span class="nc" id="L910">    }</span>

    @Override
    public void join() throws InterruptedException {
<span class="nc bnc" id="L914" title="All 2 branches missed.">        if (acceptThread != null) {</span>
<span class="nc" id="L915">            acceptThread.join();</span>
        }
<span class="nc bnc" id="L917" title="All 2 branches missed.">        for (SelectorThread thread : selectorThreads) {</span>
<span class="nc" id="L918">            thread.join();</span>
<span class="nc" id="L919">        }</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">        if (workerPool != null) {</span>
<span class="nc" id="L921">            workerPool.join(workerShutdownTimeoutMS);</span>
        }
<span class="nc" id="L923">    }</span>

    @Override
    public Iterable&lt;ServerCnxn&gt; getConnections() {
<span class="nc" id="L927">        return cnxns;</span>
    }

    public void dumpConnections(PrintWriter pwriter) {
<span class="nc" id="L931">        pwriter.print(&quot;Connections &quot;);</span>
<span class="nc" id="L932">        cnxnExpiryQueue.dump(pwriter);</span>
<span class="nc" id="L933">    }</span>

    @Override
    public void resetAllConnectionStats() {
        // No need to synchronize since cnxns is backed by a ConcurrentHashMap
<span class="nc bnc" id="L938" title="All 2 branches missed.">        for (ServerCnxn c : cnxns) {</span>
<span class="nc" id="L939">            c.resetStats();</span>
<span class="nc" id="L940">        }</span>
<span class="nc" id="L941">    }</span>

    @Override
    public Iterable&lt;Map&lt;String, Object&gt;&gt; getAllConnectionInfo(boolean brief) {
<span class="nc" id="L945">        HashSet&lt;Map&lt;String, Object&gt;&gt; info = new HashSet&lt;Map&lt;String, Object&gt;&gt;();</span>
        // No need to synchronize since cnxns is backed by a ConcurrentHashMap
<span class="nc bnc" id="L947" title="All 2 branches missed.">        for (ServerCnxn c : cnxns) {</span>
<span class="nc" id="L948">            info.add(c.getConnectionInfo(brief));</span>
<span class="nc" id="L949">        }</span>
<span class="nc" id="L950">        return info;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>