<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NettyServerCnxn.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">NettyServerCnxn.java</span></div><h1>NettyServerCnxn.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import static java.nio.charset.StandardCharsets.UTF_8;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufUtil;
import io.netty.buffer.CompositeByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Writer;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.security.cert.Certificate;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.jute.BinaryInputArchive;
import org.apache.jute.Record;
import org.apache.zookeeper.ClientCnxn;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.data.Id;
import org.apache.zookeeper.data.Stat;
import org.apache.zookeeper.proto.ReplyHeader;
import org.apache.zookeeper.proto.WatcherEvent;
import org.apache.zookeeper.server.command.CommandExecutor;
import org.apache.zookeeper.server.command.FourLetterCommands;
import org.apache.zookeeper.server.command.NopCommand;
import org.apache.zookeeper.server.command.SetTraceMaskCommand;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class NettyServerCnxn extends ServerCnxn {

<span class="nc" id="L59">    private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxn.class);</span>
    private final Channel channel;
    private CompositeByteBuf queuedBuffer;
<span class="nc" id="L62">    private final AtomicBoolean throttled = new AtomicBoolean(false);</span>
    private ByteBuffer bb;
<span class="nc" id="L64">    private final ByteBuffer bbLen = ByteBuffer.allocate(4);</span>
    private long sessionId;
    private int sessionTimeout;
    private Certificate[] clientChain;
    private volatile boolean closingChannel;

    private final NettyServerCnxnFactory factory;
    private boolean initialized;

    public int readIssuedAfterReadComplete;

<span class="nc" id="L75">    private volatile HandshakeState handshakeState = HandshakeState.NONE;</span>

<span class="nc" id="L77">    public enum HandshakeState {</span>
<span class="nc" id="L78">        NONE,</span>
<span class="nc" id="L79">        STARTED,</span>
<span class="nc" id="L80">        FINISHED</span>
    }

    NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {
<span class="nc" id="L84">        super(zks);</span>
<span class="nc" id="L85">        this.channel = channel;</span>
<span class="nc" id="L86">        this.closingChannel = false;</span>
<span class="nc" id="L87">        this.factory = factory;</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (this.factory.login != null) {</span>
<span class="nc" id="L89">            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);</span>
        }
<span class="nc" id="L91">        InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();</span>
<span class="nc" id="L92">        addAuthInfo(new Id(&quot;ip&quot;, addr.getHostAddress()));</span>
<span class="nc" id="L93">    }</span>

    /**
     * Close the cnxn and remove it from the factory cnxns list.
     */
    @Override
    public void close(DisconnectReason reason) {
<span class="nc" id="L100">        disconnectReason = reason;</span>
<span class="nc" id="L101">        close();</span>
<span class="nc" id="L102">    }</span>

    public void close() {
<span class="nc" id="L105">        closingChannel = true;</span>

<span class="nc" id="L107">        LOG.debug(&quot;close called for session id: 0x{}&quot;, Long.toHexString(sessionId));</span>

<span class="nc" id="L109">        setStale();</span>

        // ZOOKEEPER-2743:
        // Always unregister connection upon close to prevent
        // connection bean leak under certain race conditions.
<span class="nc" id="L114">        factory.unregisterConnection(this);</span>

        // if this is not in cnxns then it's already closed
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (!factory.cnxns.remove(this)) {</span>
<span class="nc" id="L118">            LOG.debug(&quot;cnxns size:{}&quot;, factory.cnxns.size());</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">            if (channel.isOpen()) {</span>
<span class="nc" id="L120">                channel.close();</span>
            }
<span class="nc" id="L122">            return;</span>
        }

<span class="nc" id="L125">        LOG.debug(&quot;close in progress for session id: 0x{}&quot;, Long.toHexString(sessionId));</span>

<span class="nc" id="L127">        factory.removeCnxnFromSessionMap(this);</span>

<span class="nc" id="L129">        factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());</span>

<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (zkServer != null) {</span>
<span class="nc" id="L132">            zkServer.removeCnxn(this);</span>
        }

<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (channel.isOpen()) {</span>
            // Since we don't check on the futures created by write calls to the channel complete we need to make sure
            // that all writes have been completed before closing the channel or we risk data loss
            // See: http://lists.jboss.org/pipermail/netty-users/2009-August/001122.html
<span class="nc" id="L139">            channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {</span>
                @Override
                public void operationComplete(ChannelFuture future) {
<span class="nc" id="L142">                    future.channel().close().addListener(f -&gt; releaseQueuedBuffer());</span>
<span class="nc" id="L143">                }</span>
            });
        } else {
<span class="nc" id="L146">            ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);</span>
<span class="nc" id="L147">            channel.eventLoop().execute(this::releaseQueuedBuffer);</span>
        }
<span class="nc" id="L149">    }</span>

    @Override
    public long getSessionId() {
<span class="nc" id="L153">        return sessionId;</span>
    }

    @Override
    public int getSessionTimeout() {
<span class="nc" id="L158">        return sessionTimeout;</span>
    }

    @Override
    public void process(WatchedEvent event) {
<span class="nc" id="L163">        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L165">            ZooTrace.logTraceMessage(</span>
                LOG,
                ZooTrace.EVENT_DELIVERY_TRACE_MASK,
<span class="nc" id="L168">                &quot;Deliver event &quot; + event + &quot; to 0x&quot; + Long.toHexString(this.sessionId) + &quot; through &quot; + this);</span>
        }

        // Convert WatchedEvent to a type that can be sent over the wire
<span class="nc" id="L172">        WatcherEvent e = event.getWrapper();</span>

        try {
<span class="nc" id="L175">            int responseSize = sendResponse(h, e, &quot;notification&quot;);</span>
<span class="nc" id="L176">            ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);</span>
<span class="nc" id="L177">        } catch (IOException e1) {</span>
<span class="nc" id="L178">            LOG.debug(&quot;Problem sending to {}&quot;, getRemoteSocketAddress(), e1);</span>
<span class="nc" id="L179">            close();</span>
<span class="nc" id="L180">        }</span>
<span class="nc" id="L181">    }</span>

    @Override
    public int sendResponse(ReplyHeader h, Record r, String tag,
                             String cacheKey, Stat stat, int opCode) throws IOException {
        // cacheKey and stat are used in caching, which is not
        // implemented here. Implementation example can be found in NIOServerCnxn.
<span class="nc bnc" id="L188" title="All 4 branches missed.">        if (closingChannel || !channel.isOpen()) {</span>
<span class="nc" id="L189">            return 0;</span>
        }
<span class="nc" id="L191">        ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);</span>
<span class="nc" id="L192">        int responseSize = bb[0].getInt();</span>
<span class="nc" id="L193">        bb[0].rewind();</span>
<span class="nc" id="L194">        sendBuffer(bb);</span>
<span class="nc" id="L195">        decrOutstandingAndCheckThrottle(h);</span>
<span class="nc" id="L196">        return responseSize;</span>
    }

    @Override
    public void setSessionId(long sessionId) {
<span class="nc" id="L201">        this.sessionId = sessionId;</span>
<span class="nc" id="L202">        factory.addSession(sessionId, this);</span>
<span class="nc" id="L203">    }</span>

    // Use a single listener instance to reduce GC
<span class="nc" id="L206">    private final GenericFutureListener&lt;Future&lt;Void&gt;&gt; onSendBufferDoneListener = f -&gt; {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (f.isSuccess()) {</span>
<span class="nc" id="L208">            packetSent();</span>
        }
<span class="nc" id="L210">    };</span>

    @Override
    public void sendBuffer(ByteBuffer... buffers) {
<span class="nc bnc" id="L214" title="All 4 branches missed.">        if (buffers.length == 1 &amp;&amp; buffers[0] == ServerCnxnFactory.closeConn) {</span>
<span class="nc" id="L215">            close(DisconnectReason.CLIENT_CLOSED_CONNECTION);</span>
<span class="nc" id="L216">            return;</span>
        }
<span class="nc" id="L218">        channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);</span>
<span class="nc" id="L219">    }</span>

    /**
     * This class wraps the sendBuffer method of NIOServerCnxn. It is
     * responsible for chunking up the response to a client. Rather
     * than cons'ing up a response fully in memory, which may be large
     * for some commands, this class chunks up the result.
     */
<span class="nc" id="L227">    private class SendBufferWriter extends Writer {</span>

<span class="nc" id="L229">        private StringBuffer sb = new StringBuffer();</span>

        /**
         * Check if we are ready to send another chunk.
         * @param force force sending, even if not a full chunk
         */
        private void checkFlush(boolean force) {
<span class="nc bnc" id="L236" title="All 6 branches missed.">            if ((force &amp;&amp; sb.length() &gt; 0) || sb.length() &gt; 2048) {</span>
<span class="nc" id="L237">                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));</span>
                // clear our internal buffer
<span class="nc" id="L239">                sb.setLength(0);</span>
            }
<span class="nc" id="L241">        }</span>

        @Override
        public void close() throws IOException {
<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (sb == null) {</span>
<span class="nc" id="L246">                return;</span>
            }
<span class="nc" id="L248">            checkFlush(true);</span>
<span class="nc" id="L249">            sb = null; // clear out the ref to ensure no reuse</span>
<span class="nc" id="L250">        }</span>

        @Override
        public void flush() throws IOException {
<span class="nc" id="L254">            checkFlush(true);</span>
<span class="nc" id="L255">        }</span>

        @Override
        public void write(char[] cbuf, int off, int len) throws IOException {
<span class="nc" id="L259">            sb.append(cbuf, off, len);</span>
<span class="nc" id="L260">            checkFlush(false);</span>
<span class="nc" id="L261">        }</span>

    }

    /** Return if four letter word found and responded to, otw false **/
    private boolean checkFourLetterWord(final Channel channel, ByteBuf message, final int len) {
        // We take advantage of the limited size of the length to look
        // for cmds. They are all 4-bytes which fits inside of an int
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (!FourLetterCommands.isKnown(len)) {</span>
<span class="nc" id="L270">            return false;</span>
        }

<span class="nc" id="L273">        String cmd = FourLetterCommands.getCommandString(len);</span>

        // Stops automatic reads of incoming data on this channel. We don't
        // expect any more traffic from the client when processing a 4LW
        // so this shouldn't break anything.
<span class="nc" id="L278">        channel.config().setAutoRead(false);</span>
<span class="nc" id="L279">        packetReceived(4);</span>

<span class="nc" id="L281">        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));</span>

        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (!FourLetterCommands.isEnabled(cmd)) {</span>
<span class="nc" id="L285">            LOG.debug(&quot;Command {} is not executed because it is not in the whitelist.&quot;, cmd);</span>
<span class="nc" id="L286">            NopCommand nopCmd = new NopCommand(</span>
                pwriter,
                this,
                cmd + &quot; is not executed because it is not in the whitelist.&quot;);
<span class="nc" id="L290">            nopCmd.start();</span>
<span class="nc" id="L291">            return true;</span>
        }

<span class="nc" id="L294">        LOG.info(&quot;Processing {} command from {}&quot;, cmd, channel.remoteAddress());</span>

<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (len == FourLetterCommands.setTraceMaskCmd) {</span>
<span class="nc" id="L297">            ByteBuffer mask = ByteBuffer.allocate(8);</span>
<span class="nc" id="L298">            message.readBytes(mask);</span>
<span class="nc" id="L299">            mask.flip();</span>
<span class="nc" id="L300">            long traceMask = mask.getLong();</span>
<span class="nc" id="L301">            ZooTrace.setTextTraceLevel(traceMask);</span>
<span class="nc" id="L302">            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);</span>
<span class="nc" id="L303">            setMask.start();</span>
<span class="nc" id="L304">            return true;</span>
        } else {
<span class="nc" id="L306">            CommandExecutor commandExecutor = new CommandExecutor();</span>
<span class="nc" id="L307">            return commandExecutor.execute(this, pwriter, len, zkServer, factory);</span>
        }
    }

    /**
     * Helper that throws an IllegalStateException if the current thread is not
     * executing in the channel's event loop thread.
     * @param callerMethodName the name of the calling method to add to the exception message.
     */
    private void checkIsInEventLoop(String callerMethodName) {
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (!channel.eventLoop().inEventLoop()) {</span>
<span class="nc" id="L318">            throw new IllegalStateException(callerMethodName + &quot;() called from non-EventLoop thread&quot;);</span>
        }
<span class="nc" id="L320">    }</span>

    /**
     * Appends &lt;code&gt;buf&lt;/code&gt; to &lt;code&gt;queuedBuffer&lt;/code&gt;. Does not duplicate &lt;code&gt;buf&lt;/code&gt;
     * or call any flavor of {@link ByteBuf#retain()}. Caller must ensure that &lt;code&gt;buf&lt;/code&gt;
     * is not owned by anyone else, as this call transfers ownership of &lt;code&gt;buf&lt;/code&gt; to the
     * &lt;code&gt;queuedBuffer&lt;/code&gt;.
     *
     * This method should only be called from the event loop thread.
     * @param buf the buffer to append to the queue.
     */
    private void appendToQueuedBuffer(ByteBuf buf) {
<span class="nc" id="L332">        checkIsInEventLoop(&quot;appendToQueuedBuffer&quot;);</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (queuedBuffer.numComponents() == queuedBuffer.maxNumComponents()) {</span>
            // queuedBuffer has reached its component limit, so combine the existing components.
<span class="nc" id="L335">            queuedBuffer.consolidate();</span>
        }
<span class="nc" id="L337">        queuedBuffer.addComponent(true, buf);</span>
<span class="nc" id="L338">        ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());</span>
<span class="nc" id="L339">    }</span>

    /**
     * Process incoming message. This should only be called from the event
     * loop thread.
     * Note that this method does not call &lt;code&gt;buf.release()&lt;/code&gt;. The caller
     * is responsible for making sure the buf is released after this method
     * returns.
     * @param buf the message bytes to process.
     */
    void processMessage(ByteBuf buf) {
<span class="nc" id="L350">        checkIsInEventLoop(&quot;processMessage&quot;);</span>
<span class="nc" id="L351">        LOG.debug(&quot;0x{} queuedBuffer: {}&quot;, Long.toHexString(sessionId), queuedBuffer);</span>

<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L354">            LOG.trace(&quot;0x{} buf {}&quot;, Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));</span>
        }

<span class="nc bnc" id="L357" title="All 2 branches missed.">        if (throttled.get()) {</span>
<span class="nc" id="L358">            LOG.debug(&quot;Received message while throttled&quot;);</span>
            // we are throttled, so we need to queue
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (queuedBuffer == null) {</span>
<span class="nc" id="L361">                LOG.debug(&quot;allocating queue&quot;);</span>
<span class="nc" id="L362">                queuedBuffer = channel.alloc().compositeBuffer();</span>
            }
<span class="nc" id="L364">            appendToQueuedBuffer(buf.retainedDuplicate());</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L366">                LOG.trace(&quot;0x{} queuedBuffer {}&quot;, Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));</span>
            }
        } else {
<span class="nc" id="L369">            LOG.debug(&quot;not throttled&quot;);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            if (queuedBuffer != null) {</span>
<span class="nc" id="L371">                appendToQueuedBuffer(buf.retainedDuplicate());</span>
<span class="nc" id="L372">                processQueuedBuffer();</span>
            } else {
<span class="nc" id="L374">                receiveMessage(buf);</span>
                // Have to check !closingChannel, because an error in
                // receiveMessage() could have led to close() being called.
<span class="nc bnc" id="L377" title="All 4 branches missed.">                if (!closingChannel &amp;&amp; buf.isReadable()) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L379">                        LOG.trace(&quot;Before copy {}&quot;, buf);</span>
                    }

<span class="nc bnc" id="L382" title="All 2 branches missed.">                    if (queuedBuffer == null) {</span>
<span class="nc" id="L383">                        queuedBuffer = channel.alloc().compositeBuffer();</span>
                    }
<span class="nc" id="L385">                    appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">                    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L387">                        LOG.trace(&quot;Copy is {}&quot;, queuedBuffer);</span>
<span class="nc" id="L388">                        LOG.trace(&quot;0x{} queuedBuffer {}&quot;, Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));</span>
                    }
                }
            }
        }
<span class="nc" id="L393">    }</span>

    /**
     * Try to process previously queued message. This should only be called
     * from the event loop thread.
     */
    void processQueuedBuffer() {
<span class="nc" id="L400">        checkIsInEventLoop(&quot;processQueuedBuffer&quot;);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (queuedBuffer != null) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L403">                LOG.trace(&quot;processing queue 0x{} queuedBuffer {}&quot;, Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));</span>
            }
<span class="nc" id="L405">            receiveMessage(queuedBuffer);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (closingChannel) {</span>
                // close() could have been called if receiveMessage() failed
<span class="nc" id="L408">                LOG.debug(&quot;Processed queue - channel closed, dropping remaining bytes&quot;);</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            } else if (!queuedBuffer.isReadable()) {</span>
<span class="nc" id="L410">                LOG.debug(&quot;Processed queue - no bytes remaining&quot;);</span>
<span class="nc" id="L411">                releaseQueuedBuffer();</span>
            } else {
<span class="nc" id="L413">                LOG.debug(&quot;Processed queue - bytes remaining&quot;);</span>
                // Try to reduce memory consumption by freeing up buffer space
                // which is no longer needed.
<span class="nc" id="L416">                queuedBuffer.discardReadComponents();</span>
            }
        } else {
<span class="nc" id="L419">            LOG.debug(&quot;queue empty&quot;);</span>
        }
<span class="nc" id="L421">    }</span>

    /**
     * Clean up queued buffer once it's no longer needed. This should only be
     * called from the event loop thread.
     */
    private void releaseQueuedBuffer() {
<span class="nc" id="L428">        checkIsInEventLoop(&quot;releaseQueuedBuffer&quot;);</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (queuedBuffer != null) {</span>
<span class="nc" id="L430">            queuedBuffer.release();</span>
<span class="nc" id="L431">            queuedBuffer = null;</span>
        }
<span class="nc" id="L433">    }</span>

    /**
     * Receive a message, which can come from the queued buffer or from a new
     * buffer coming in over the channel. This should only be called from the
     * event loop thread.
     * Note that this method does not call &lt;code&gt;message.release()&lt;/code&gt;. The
     * caller is responsible for making sure the message is released after this
     * method returns.
     * @param message the message bytes to process.
     */
    private void receiveMessage(ByteBuf message) {
<span class="nc" id="L445">        checkIsInEventLoop(&quot;receiveMessage&quot;);</span>
        try {
<span class="nc bnc" id="L447" title="All 4 branches missed.">            while (message.isReadable() &amp;&amp; !throttled.get()) {</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                if (bb != null) {</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">                    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L450">                        LOG.trace(&quot;message readable {} bb len {} {}&quot;, message.readableBytes(), bb.remaining(), bb);</span>
<span class="nc" id="L451">                        ByteBuffer dat = bb.duplicate();</span>
<span class="nc" id="L452">                        dat.flip();</span>
<span class="nc" id="L453">                        LOG.trace(&quot;0x{} bb {}&quot;, Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));</span>
                    }

<span class="nc bnc" id="L456" title="All 2 branches missed.">                    if (bb.remaining() &gt; message.readableBytes()) {</span>
<span class="nc" id="L457">                        int newLimit = bb.position() + message.readableBytes();</span>
<span class="nc" id="L458">                        bb.limit(newLimit);</span>
                    }
<span class="nc" id="L460">                    message.readBytes(bb);</span>
<span class="nc" id="L461">                    bb.limit(bb.capacity());</span>

<span class="nc bnc" id="L463" title="All 2 branches missed.">                    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L464">                        LOG.trace(&quot;after readBytes message readable {} bb len {} {}&quot;, message.readableBytes(), bb.remaining(), bb);</span>
<span class="nc" id="L465">                        ByteBuffer dat = bb.duplicate();</span>
<span class="nc" id="L466">                        dat.flip();</span>
<span class="nc" id="L467">                        LOG.trace(&quot;after readbytes 0x{} bb {}&quot;,</span>
<span class="nc" id="L468">                                  Long.toHexString(sessionId),</span>
<span class="nc" id="L469">                                  ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));</span>
                    }
<span class="nc bnc" id="L471" title="All 2 branches missed.">                    if (bb.remaining() == 0) {</span>
<span class="nc" id="L472">                        bb.flip();</span>
<span class="nc" id="L473">                        packetReceived(4 + bb.remaining());</span>

<span class="nc" id="L475">                        ZooKeeperServer zks = this.zkServer;</span>
<span class="nc bnc" id="L476" title="All 4 branches missed.">                        if (zks == null || !zks.isRunning()) {</span>
<span class="nc" id="L477">                            throw new IOException(&quot;ZK down&quot;);</span>
                        }
<span class="nc bnc" id="L479" title="All 2 branches missed.">                        if (initialized) {</span>
                            // TODO: if zks.processPacket() is changed to take a ByteBuffer[],
                            // we could implement zero-copy queueing.
<span class="nc" id="L482">                            zks.processPacket(this, bb);</span>
                        } else {
<span class="nc" id="L484">                            LOG.debug(&quot;got conn req request from {}&quot;, getRemoteSocketAddress());</span>
<span class="nc" id="L485">                            zks.processConnectRequest(this, bb);</span>
<span class="nc" id="L486">                            initialized = true;</span>
                        }
<span class="nc" id="L488">                        bb = null;</span>
<span class="nc" id="L489">                    }</span>
                } else {
<span class="nc bnc" id="L491" title="All 2 branches missed.">                    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L492">                        LOG.trace(&quot;message readable {} bblenrem {}&quot;, message.readableBytes(), bbLen.remaining());</span>
<span class="nc" id="L493">                        ByteBuffer dat = bbLen.duplicate();</span>
<span class="nc" id="L494">                        dat.flip();</span>
<span class="nc" id="L495">                        LOG.trace(&quot;0x{} bbLen {}&quot;, Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));</span>
                    }

<span class="nc bnc" id="L498" title="All 2 branches missed.">                    if (message.readableBytes() &lt; bbLen.remaining()) {</span>
<span class="nc" id="L499">                        bbLen.limit(bbLen.position() + message.readableBytes());</span>
                    }
<span class="nc" id="L501">                    message.readBytes(bbLen);</span>
<span class="nc" id="L502">                    bbLen.limit(bbLen.capacity());</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">                    if (bbLen.remaining() == 0) {</span>
<span class="nc" id="L504">                        bbLen.flip();</span>

<span class="nc bnc" id="L506" title="All 2 branches missed.">                        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L507">                            LOG.trace(&quot;0x{} bbLen {}&quot;, Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));</span>
                        }
<span class="nc" id="L509">                        int len = bbLen.getInt();</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L511">                            LOG.trace(&quot;0x{} bbLen len is {}&quot;, Long.toHexString(sessionId), len);</span>
                        }

<span class="nc" id="L514">                        bbLen.clear();</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                        if (!initialized) {</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">                            if (checkFourLetterWord(channel, message, len)) {</span>
<span class="nc" id="L517">                                return;</span>
                            }
                        }
<span class="nc bnc" id="L520" title="All 4 branches missed.">                        if (len &lt; 0 || len &gt; BinaryInputArchive.maxBuffer) {</span>
<span class="nc" id="L521">                            throw new IOException(&quot;Len error &quot; + len);</span>
                        }
<span class="nc" id="L523">                        ZooKeeperServer zks = this.zkServer;</span>
<span class="nc bnc" id="L524" title="All 4 branches missed.">                        if (zks == null || !zks.isRunning()) {</span>
<span class="nc" id="L525">                            throw new IOException(&quot;ZK down&quot;);</span>
                        }
                        // checkRequestSize will throw IOException if request is rejected
<span class="nc" id="L528">                        zks.checkRequestSizeWhenReceivingMessage(len);</span>
<span class="nc" id="L529">                        bb = ByteBuffer.allocate(len);</span>
<span class="nc" id="L530">                    }</span>
                }
            }
<span class="nc" id="L533">        } catch (IOException e) {</span>
<span class="nc" id="L534">            LOG.warn(&quot;Closing connection to {}&quot;, getRemoteSocketAddress(), e);</span>
<span class="nc" id="L535">            close(DisconnectReason.IO_EXCEPTION);</span>
<span class="nc" id="L536">        } catch (ClientCnxnLimitException e) {</span>
            // Common case exception, print at debug level
<span class="nc" id="L538">            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);</span>

<span class="nc" id="L540">            LOG.debug(&quot;Closing connection to {}&quot;, getRemoteSocketAddress(), e);</span>
<span class="nc" id="L541">            close(DisconnectReason.CLIENT_RATE_LIMIT);</span>
<span class="nc" id="L542">        }</span>
<span class="nc" id="L543">    }</span>

    /**
     * An event that triggers a change in the channel's read setting.
     * Used for throttling. By using an enum we can treat the two values as
     * singletons and compare with ==.
     */
<span class="nc" id="L550">    enum ReadEvent {</span>
<span class="nc" id="L551">        DISABLE,</span>
<span class="nc" id="L552">        ENABLE</span>
    }

    /**
     * Note that the netty implementation ignores the &lt;code&gt;waitDisableRecv&lt;/code&gt;
     * parameter and is always asynchronous.
     * @param waitDisableRecv ignored by this implementation.
     */
    @Override
    public void disableRecv(boolean waitDisableRecv) {
<span class="nc bnc" id="L562" title="All 2 branches missed.">        if (throttled.compareAndSet(false, true)) {</span>
<span class="nc" id="L563">            LOG.debug(&quot;Throttling - disabling recv {}&quot;, this);</span>
<span class="nc" id="L564">            channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);</span>
        }
<span class="nc" id="L566">    }</span>

    @Override
    public void enableRecv() {
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (throttled.compareAndSet(true, false)) {</span>
<span class="nc" id="L571">            LOG.debug(&quot;Sending unthrottle event {}&quot;, this);</span>
<span class="nc" id="L572">            channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);</span>
        }
<span class="nc" id="L574">    }</span>

    @Override
    public void setSessionTimeout(int sessionTimeout) {
<span class="nc" id="L578">        this.sessionTimeout = sessionTimeout;</span>
<span class="nc" id="L579">    }</span>

    @Override
    public int getInterestOps() {
        // This might not be 100% right, but it's only used for printing
        // connection info in the netty implementation so it's probably ok.
<span class="nc bnc" id="L585" title="All 4 branches missed.">        if (channel == null || !channel.isOpen()) {</span>
<span class="nc" id="L586">            return 0;</span>
        }
<span class="nc" id="L588">        int interestOps = 0;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (!throttled.get()) {</span>
<span class="nc" id="L590">            interestOps |= SelectionKey.OP_READ;</span>
        }
<span class="nc bnc" id="L592" title="All 2 branches missed.">        if (!channel.isWritable()) {</span>
            // OP_READ means &quot;can read&quot;, but OP_WRITE means &quot;cannot write&quot;,
            // it's weird.
<span class="nc" id="L595">            interestOps |= SelectionKey.OP_WRITE;</span>
        }
<span class="nc" id="L597">        return interestOps;</span>
    }

    @Override
    public InetSocketAddress getRemoteSocketAddress() {
<span class="nc" id="L602">        return (InetSocketAddress) channel.remoteAddress();</span>
    }

    /** Send close connection packet to the client.
     */
    @Override
    public void sendCloseSession() {
<span class="nc" id="L609">        sendBuffer(ServerCnxnFactory.closeConn);</span>
<span class="nc" id="L610">    }</span>

    @Override
    protected ServerStats serverStats() {
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (zkServer == null) {</span>
<span class="nc" id="L615">            return null;</span>
        }
<span class="nc" id="L617">        return zkServer.serverStats();</span>
    }

    @Override
    public boolean isSecure() {
<span class="nc" id="L622">        return factory.secure;</span>
    }

    @Override
    public Certificate[] getClientCertificateChain() {
<span class="nc bnc" id="L627" title="All 2 branches missed.">        if (clientChain == null) {</span>
<span class="nc" id="L628">            return null;</span>
        }
<span class="nc" id="L630">        return Arrays.copyOf(clientChain, clientChain.length);</span>
    }

    @Override
    public void setClientCertificateChain(Certificate[] chain) {
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (chain == null) {</span>
<span class="nc" id="L636">            clientChain = null;</span>
        } else {
<span class="nc" id="L638">            clientChain = Arrays.copyOf(chain, chain.length);</span>
        }
<span class="nc" id="L640">    }</span>

    // For tests and NettyServerCnxnFactory only, thus package-private.
    Channel getChannel() {
<span class="nc" id="L644">        return channel;</span>
    }

    public int getQueuedReadableBytes() {
<span class="nc" id="L648">        checkIsInEventLoop(&quot;getQueuedReadableBytes&quot;);</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">        if (queuedBuffer != null) {</span>
<span class="nc" id="L650">            return queuedBuffer.readableBytes();</span>
        }
<span class="nc" id="L652">        return 0;</span>
    }

    public void setHandshakeState(HandshakeState state) {
<span class="nc" id="L656">        this.handshakeState = state;</span>
<span class="nc" id="L657">    }</span>

    public HandshakeState getHandshakeState() {
<span class="nc" id="L660">        return this.handshakeState;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>