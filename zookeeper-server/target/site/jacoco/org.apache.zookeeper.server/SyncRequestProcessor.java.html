<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SyncRequestProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">SyncRequestProcessor.java</span></div><h1>SyncRequestProcessor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import java.io.Flushable;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.Objects;
import java.util.Queue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import org.apache.zookeeper.common.Time;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This RequestProcessor logs requests to disk. It batches the requests to do
 * the io efficiently. The request is not passed to the next RequestProcessor
 * until its log has been synced to disk.
 *
 * SyncRequestProcessor is used in 3 different cases
 * 1. Leader - Sync request to disk and forward it to AckRequestProcessor which
 *             send ack back to itself.
 * 2. Follower - Sync request to disk and forward request to
 *             SendAckRequestProcessor which send the packets to leader.
 *             SendAckRequestProcessor is flushable which allow us to force
 *             push packets to leader.
 * 3. Observer - Sync committed request to disk (received as INFORM packet).
 *             It never send ack back to the leader, so the nextProcessor will
 *             be null. This change the semantic of txnlog on the observer
 *             since it only contains committed txns.
 */
public class SyncRequestProcessor extends ZooKeeperCriticalThread implements RequestProcessor {

<span class="nc" id="L54">    private static final Logger LOG = LoggerFactory.getLogger(SyncRequestProcessor.class);</span>

<span class="nc" id="L56">    private static final Request REQUEST_OF_DEATH = Request.requestOfDeath;</span>

    /** The number of log entries to log before starting a snapshot */
<span class="nc" id="L59">    private static int snapCount = ZooKeeperServer.getSnapCount();</span>

    /**
     * The total size of log entries before starting a snapshot
     */
<span class="nc" id="L64">    private static long snapSizeInBytes = ZooKeeperServer.getSnapSizeInBytes();</span>

    /**
     * Random numbers used to vary snapshot timing
     */
    private int randRoll;
    private long randSize;

<span class="nc" id="L72">    private final BlockingQueue&lt;Request&gt; queuedRequests = new LinkedBlockingQueue&lt;Request&gt;();</span>

<span class="nc" id="L74">    private final Semaphore snapThreadMutex = new Semaphore(1);</span>

    private final ZooKeeperServer zks;

    private final RequestProcessor nextProcessor;

    /**
     * Transactions that have been written and are waiting to be flushed to
     * disk. Basically this is the list of SyncItems whose callbacks will be
     * invoked after flush returns successfully.
     */
    private final Queue&lt;Request&gt; toFlush;
    private long lastFlushTime;

    public SyncRequestProcessor(ZooKeeperServer zks, RequestProcessor nextProcessor) {
<span class="nc" id="L89">        super(&quot;SyncThread:&quot; + zks.getServerId(), zks.getZooKeeperServerListener());</span>
<span class="nc" id="L90">        this.zks = zks;</span>
<span class="nc" id="L91">        this.nextProcessor = nextProcessor;</span>
<span class="nc" id="L92">        this.toFlush = new ArrayDeque&lt;&gt;(zks.getMaxBatchSize());</span>
<span class="nc" id="L93">    }</span>

    /**
     * used by tests to check for changing
     * snapcounts
     * @param count
     */
    public static void setSnapCount(int count) {
<span class="nc" id="L101">        snapCount = count;</span>
<span class="nc" id="L102">    }</span>

    /**
     * used by tests to get the snapcount
     * @return the snapcount
     */
    public static int getSnapCount() {
<span class="nc" id="L109">        return snapCount;</span>
    }

    private long getRemainingDelay() {
<span class="nc" id="L113">        long flushDelay = zks.getFlushDelay();</span>
<span class="nc" id="L114">        long duration = Time.currentElapsedTime() - lastFlushTime;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (duration &lt; flushDelay) {</span>
<span class="nc" id="L116">            return flushDelay - duration;</span>
        }
<span class="nc" id="L118">        return 0;</span>
    }

    /** If both flushDelay and maxMaxBatchSize are set (bigger than 0), flush
     * whenever either condition is hit. If only one or the other is
     * set, flush only when the relevant condition is hit.
     */
    private boolean shouldFlush() {
<span class="nc" id="L126">        long flushDelay = zks.getFlushDelay();</span>
<span class="nc" id="L127">        long maxBatchSize = zks.getMaxBatchSize();</span>
<span class="nc bnc" id="L128" title="All 4 branches missed.">        if ((flushDelay &gt; 0) &amp;&amp; (getRemainingDelay() == 0)) {</span>
<span class="nc" id="L129">            return true;</span>
        }
<span class="nc bnc" id="L131" title="All 4 branches missed.">        return (maxBatchSize &gt; 0) &amp;&amp; (toFlush.size() &gt;= maxBatchSize);</span>
    }

    /**
     * used by tests to check for changing
     * snapcounts
     * @param size
     */
    public static void setSnapSizeInBytes(long size) {
<span class="nc" id="L140">        snapSizeInBytes = size;</span>
<span class="nc" id="L141">    }</span>

    private boolean shouldSnapshot() {
<span class="nc" id="L144">        int logCount = zks.getZKDatabase().getTxnCount();</span>
<span class="nc" id="L145">        long logSize = zks.getZKDatabase().getTxnSize();</span>
<span class="nc bnc" id="L146" title="All 6 branches missed.">        return (logCount &gt; (snapCount / 2 + randRoll))</span>
               || (snapSizeInBytes &gt; 0 &amp;&amp; logSize &gt; (snapSizeInBytes / 2 + randSize));
    }

    private void resetSnapshotStats() {
<span class="nc" id="L151">        randRoll = ThreadLocalRandom.current().nextInt(snapCount / 2);</span>
<span class="nc" id="L152">        randSize = Math.abs(ThreadLocalRandom.current().nextLong() % (snapSizeInBytes / 2));</span>
<span class="nc" id="L153">    }</span>

    @Override
    public void run() {
        try {
            // we do this in an attempt to ensure that not all of the servers
            // in the ensemble take a snapshot at the same time
<span class="nc" id="L160">            resetSnapshotStats();</span>
<span class="nc" id="L161">            lastFlushTime = Time.currentElapsedTime();</span>
            while (true) {
<span class="nc" id="L163">                ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());</span>

<span class="nc" id="L165">                long pollTime = Math.min(zks.getMaxWriteQueuePollTime(), getRemainingDelay());</span>
<span class="nc" id="L166">                Request si = queuedRequests.poll(pollTime, TimeUnit.MILLISECONDS);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">                if (si == null) {</span>
                    /* We timed out looking for more writes to batch, go ahead and flush immediately */
<span class="nc" id="L169">                    flush();</span>
<span class="nc" id="L170">                    si = queuedRequests.take();</span>
                }

<span class="nc bnc" id="L173" title="All 2 branches missed.">                if (si == REQUEST_OF_DEATH) {</span>
<span class="nc" id="L174">                    break;</span>
                }

<span class="nc" id="L177">                long startProcessTime = Time.currentElapsedTime();</span>
<span class="nc" id="L178">                ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_TIME.add(startProcessTime - si.syncQueueStartTime);</span>

                // track the number of records written to the log
<span class="nc bnc" id="L181" title="All 4 branches missed.">                if (!si.isThrottled() &amp;&amp; zks.getZKDatabase().append(si)) {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                    if (shouldSnapshot()) {</span>
<span class="nc" id="L183">                        resetSnapshotStats();</span>
                        // roll the log
<span class="nc" id="L185">                        zks.getZKDatabase().rollLog();</span>
                        // take a snapshot
<span class="nc bnc" id="L187" title="All 2 branches missed.">                        if (!snapThreadMutex.tryAcquire()) {</span>
<span class="nc" id="L188">                            LOG.warn(&quot;Too busy to snap, skipping&quot;);</span>
                        } else {
<span class="nc" id="L190">                            new ZooKeeperThread(&quot;Snapshot Thread&quot;) {</span>
                                public void run() {
                                    try {
<span class="nc" id="L193">                                        zks.takeSnapshot();</span>
<span class="nc" id="L194">                                    } catch (Exception e) {</span>
<span class="nc" id="L195">                                        LOG.warn(&quot;Unexpected exception&quot;, e);</span>
                                    } finally {
<span class="nc" id="L197">                                        snapThreadMutex.release();</span>
                                    }
<span class="nc" id="L199">                                }</span>
<span class="nc" id="L200">                            }.start();</span>
                        }
                    }
<span class="nc bnc" id="L203" title="All 2 branches missed.">                } else if (toFlush.isEmpty()) {</span>
                    // optimization for read heavy workloads
                    // iff this is a read or a throttled request(which doesn't need to be written to the disk),
                    // and there are no pending flushes (writes), then just pass this to the next processor
<span class="nc bnc" id="L207" title="All 2 branches missed.">                    if (nextProcessor != null) {</span>
<span class="nc" id="L208">                        nextProcessor.processRequest(si);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                        if (nextProcessor instanceof Flushable) {</span>
<span class="nc" id="L210">                            ((Flushable) nextProcessor).flush();</span>
                        }
                    }
                    continue;
                }
<span class="nc" id="L215">                toFlush.add(si);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                if (shouldFlush()) {</span>
<span class="nc" id="L217">                    flush();</span>
                }
<span class="nc" id="L219">                ServerMetrics.getMetrics().SYNC_PROCESS_TIME.add(Time.currentElapsedTime() - startProcessTime);</span>
<span class="nc" id="L220">            }</span>
<span class="nc" id="L221">        } catch (Throwable t) {</span>
<span class="nc" id="L222">            handleException(this.getName(), t);</span>
<span class="nc" id="L223">        }</span>
<span class="nc" id="L224">        LOG.info(&quot;SyncRequestProcessor exited!&quot;);</span>
<span class="nc" id="L225">    }</span>

    private void flush() throws IOException, RequestProcessorException {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (this.toFlush.isEmpty()) {</span>
<span class="nc" id="L229">            return;</span>
        }

<span class="nc" id="L232">        ServerMetrics.getMetrics().BATCH_SIZE.add(toFlush.size());</span>

<span class="nc" id="L234">        long flushStartTime = Time.currentElapsedTime();</span>
<span class="nc" id="L235">        zks.getZKDatabase().commit();</span>
<span class="nc" id="L236">        ServerMetrics.getMetrics().SYNC_PROCESSOR_FLUSH_TIME.add(Time.currentElapsedTime() - flushStartTime);</span>

<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (this.nextProcessor == null) {</span>
<span class="nc" id="L239">            this.toFlush.clear();</span>
        } else {
<span class="nc bnc" id="L241" title="All 2 branches missed.">            while (!this.toFlush.isEmpty()) {</span>
<span class="nc" id="L242">                final Request i = this.toFlush.remove();</span>
<span class="nc" id="L243">                long latency = Time.currentElapsedTime() - i.syncQueueStartTime;</span>
<span class="nc" id="L244">                ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_AND_FLUSH_TIME.add(latency);</span>
<span class="nc" id="L245">                this.nextProcessor.processRequest(i);</span>
<span class="nc" id="L246">            }</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (this.nextProcessor instanceof Flushable) {</span>
<span class="nc" id="L248">                ((Flushable) this.nextProcessor).flush();</span>
            }
        }
<span class="nc" id="L251">        lastFlushTime = Time.currentElapsedTime();</span>
<span class="nc" id="L252">    }</span>

    public void shutdown() {
<span class="nc" id="L255">        LOG.info(&quot;Shutting down&quot;);</span>
<span class="nc" id="L256">        queuedRequests.add(REQUEST_OF_DEATH);</span>
        try {
<span class="nc" id="L258">            this.join();</span>
<span class="nc" id="L259">            this.flush();</span>
<span class="nc" id="L260">        } catch (InterruptedException e) {</span>
<span class="nc" id="L261">            LOG.warn(&quot;Interrupted while wating for {} to finish&quot;, this);</span>
<span class="nc" id="L262">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L263">        } catch (IOException e) {</span>
<span class="nc" id="L264">            LOG.warn(&quot;Got IO exception during shutdown&quot;);</span>
<span class="nc" id="L265">        } catch (RequestProcessorException e) {</span>
<span class="nc" id="L266">            LOG.warn(&quot;Got request processor exception during shutdown&quot;);</span>
<span class="nc" id="L267">        }</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (nextProcessor != null) {</span>
<span class="nc" id="L269">            nextProcessor.shutdown();</span>
        }
<span class="nc" id="L271">    }</span>

    public void processRequest(final Request request) {
<span class="nc" id="L274">        Objects.requireNonNull(request, &quot;Request cannot be null&quot;);</span>

<span class="nc" id="L276">        request.syncQueueStartTime = Time.currentElapsedTime();</span>
<span class="nc" id="L277">        queuedRequests.add(request);</span>
<span class="nc" id="L278">        ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUED.add(1);</span>
<span class="nc" id="L279">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>