<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ContainerManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">ContainerManager.java</span></div><h1>ContainerManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import static java.nio.charset.StandardCharsets.UTF_8;
import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import org.apache.zookeeper.ZooDefs;
import org.apache.zookeeper.common.Time;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Manages cleanup of container ZNodes. This class is meant to only
 * be run from the leader. There's no harm in running from followers/observers
 * but that will be extra work that's not needed. Once started, it periodically
 * checks container nodes that have a cversion &amp;gt; 0 and have no children. A
 * delete is attempted on the node. The result of the delete is unimportant.
 * If the proposal fails or the container node is not empty there's no harm.
 */
public class ContainerManager {

<span class="nc" id="L45">    private static final Logger LOG = LoggerFactory.getLogger(ContainerManager.class);</span>
    private final ZKDatabase zkDb;
    private final RequestProcessor requestProcessor;
    private final int checkIntervalMs;
    private final int maxPerMinute;
    private final long maxNeverUsedIntervalMs;
    private final Timer timer;
<span class="nc" id="L52">    private final AtomicReference&lt;TimerTask&gt; task = new AtomicReference&lt;TimerTask&gt;(null);</span>

    /**
     * @param zkDb the ZK database
     * @param requestProcessor request processer - used to inject delete
     *                         container requests
     * @param checkIntervalMs how often to check containers in milliseconds
     * @param maxPerMinute the max containers to delete per second - avoids
     *                     herding of container deletions
     */
    public ContainerManager(ZKDatabase zkDb, RequestProcessor requestProcessor, int checkIntervalMs, int maxPerMinute) {
<span class="nc" id="L63">        this(zkDb, requestProcessor, checkIntervalMs, maxPerMinute, 0);</span>
<span class="nc" id="L64">    }</span>

    /**
     * @param zkDb the ZK database
     * @param requestProcessor request processer - used to inject delete
     *                         container requests
     * @param checkIntervalMs how often to check containers in milliseconds
     * @param maxPerMinute the max containers to delete per second - avoids
     *                     herding of container deletions
     * @param maxNeverUsedIntervalMs the max time in milliseconds that a container that has never had
     *                                  any children is retained
     */
<span class="nc" id="L76">    public ContainerManager(ZKDatabase zkDb, RequestProcessor requestProcessor, int checkIntervalMs, int maxPerMinute, long maxNeverUsedIntervalMs) {</span>
<span class="nc" id="L77">        this.zkDb = zkDb;</span>
<span class="nc" id="L78">        this.requestProcessor = requestProcessor;</span>
<span class="nc" id="L79">        this.checkIntervalMs = checkIntervalMs;</span>
<span class="nc" id="L80">        this.maxPerMinute = maxPerMinute;</span>
<span class="nc" id="L81">        this.maxNeverUsedIntervalMs = maxNeverUsedIntervalMs;</span>
<span class="nc" id="L82">        timer = new Timer(&quot;ContainerManagerTask&quot;, true);</span>

<span class="nc" id="L84">        LOG.info(&quot;Using checkIntervalMs={} maxPerMinute={} maxNeverUsedIntervalMs={}&quot;, checkIntervalMs, maxPerMinute, maxNeverUsedIntervalMs);</span>
<span class="nc" id="L85">    }</span>

    /**
     * start/restart the timer the runs the check. Can safely be called
     * multiple times.
     */
    public void start() {
<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (task.get() == null) {</span>
<span class="nc" id="L93">            TimerTask timerTask = new TimerTask() {</span>
                @Override
                public void run() {
                    try {
<span class="nc" id="L97">                        checkContainers();</span>
<span class="nc" id="L98">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L99">                        Thread.currentThread().interrupt();</span>
<span class="nc" id="L100">                        LOG.info(&quot;interrupted&quot;);</span>
<span class="nc" id="L101">                        cancel();</span>
<span class="nc" id="L102">                    } catch (Throwable e) {</span>
<span class="nc" id="L103">                        LOG.error(&quot;Error checking containers&quot;, e);</span>
<span class="nc" id="L104">                    }</span>
<span class="nc" id="L105">                }</span>
            };
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (task.compareAndSet(null, timerTask)) {</span>
<span class="nc" id="L108">                timer.scheduleAtFixedRate(timerTask, checkIntervalMs, checkIntervalMs);</span>
            }
        }
<span class="nc" id="L111">    }</span>

    /**
     * stop the timer if necessary. Can safely be called multiple times.
     */
    public void stop() {
<span class="nc" id="L117">        TimerTask timerTask = task.getAndSet(null);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (timerTask != null) {</span>
<span class="nc" id="L119">            timerTask.cancel();</span>
        }
<span class="nc" id="L121">        timer.cancel();</span>
<span class="nc" id="L122">    }</span>

    /**
     * Manually check the containers. Not normally used directly
     */
    public void checkContainers() throws InterruptedException {
<span class="nc" id="L128">        long minIntervalMs = getMinIntervalMs();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        for (String containerPath : getCandidates()) {</span>
<span class="nc" id="L130">            long startMs = Time.currentElapsedTime();</span>

<span class="nc" id="L132">            ByteBuffer path = ByteBuffer.wrap(containerPath.getBytes(UTF_8));</span>
<span class="nc" id="L133">            Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, path, null);</span>
            try {
<span class="nc" id="L135">                LOG.info(&quot;Attempting to delete candidate container: {}&quot;, containerPath);</span>
<span class="nc" id="L136">                postDeleteRequest(request);</span>
<span class="nc" id="L137">            } catch (Exception e) {</span>
<span class="nc" id="L138">                LOG.error(&quot;Could not delete container: {}&quot;, containerPath, e);</span>
<span class="nc" id="L139">            }</span>

<span class="nc" id="L141">            long elapsedMs = Time.currentElapsedTime() - startMs;</span>
<span class="nc" id="L142">            long waitMs = minIntervalMs - elapsedMs;</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">            if (waitMs &gt; 0) {</span>
<span class="nc" id="L144">                Thread.sleep(waitMs);</span>
            }
<span class="nc" id="L146">        }</span>
<span class="nc" id="L147">    }</span>

    // VisibleForTesting
    protected void postDeleteRequest(Request request) throws RequestProcessor.RequestProcessorException {
<span class="nc" id="L151">        requestProcessor.processRequest(request);</span>
<span class="nc" id="L152">    }</span>

    // VisibleForTesting
    protected long getMinIntervalMs() {
<span class="nc" id="L156">        return TimeUnit.MINUTES.toMillis(1) / maxPerMinute;</span>
    }

    // VisibleForTesting
    protected Collection&lt;String&gt; getCandidates() {
<span class="nc" id="L161">        Set&lt;String&gt; candidates = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        for (String containerPath : zkDb.getDataTree().getContainers()) {</span>
<span class="nc" id="L163">            DataNode node = zkDb.getDataTree().getNode(containerPath);</span>
<span class="nc bnc" id="L164" title="All 4 branches missed.">            if ((node != null) &amp;&amp; node.getChildren().isEmpty()) {</span>
                /*
                    cversion &gt; 0: keep newly created containers from being deleted
                    before any children have been added. If you were to create the
                    container just before a container cleaning period the container
                    would be immediately be deleted.
                 */
<span class="nc bnc" id="L171" title="All 2 branches missed.">                if (node.stat.getCversion() &gt; 0) {</span>
<span class="nc" id="L172">                    candidates.add(containerPath);</span>
                } else {
                    /*
                        Users may not want unused containers to live indefinitely. Allow a system
                        property to be set that sets the max time for a cversion-0 container
                        to stay before being deleted
                     */
<span class="nc bnc" id="L179" title="All 4 branches missed.">                    if ((maxNeverUsedIntervalMs != 0) &amp;&amp; (getElapsed(node) &gt; maxNeverUsedIntervalMs)) {</span>
<span class="nc" id="L180">                        candidates.add(containerPath);</span>
                    }
                }
            }
<span class="nc" id="L184">        }</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        for (String ttlPath : zkDb.getDataTree().getTtls()) {</span>
<span class="nc" id="L186">            DataNode node = zkDb.getDataTree().getNode(ttlPath);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (node != null) {</span>
<span class="nc" id="L188">                Set&lt;String&gt; children = node.getChildren();</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (children.isEmpty()) {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                    if (EphemeralType.get(node.stat.getEphemeralOwner()) == EphemeralType.TTL) {</span>
<span class="nc" id="L191">                        long ttl = EphemeralType.TTL.getValue(node.stat.getEphemeralOwner());</span>
<span class="nc bnc" id="L192" title="All 4 branches missed.">                        if ((ttl != 0) &amp;&amp; (getElapsed(node) &gt; ttl)) {</span>
<span class="nc" id="L193">                            candidates.add(ttlPath);</span>
                        }
                    }
                }
            }
<span class="nc" id="L198">        }</span>
<span class="nc" id="L199">        return candidates;</span>
    }

    // VisibleForTesting
    protected long getElapsed(DataNode node) {
<span class="nc" id="L204">        return Time.currentWallTime() - node.stat.getMtime();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>