<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NIOServerCnxn.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">NIOServerCnxn.java</span></div><h1>NIOServerCnxn.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import static java.nio.charset.StandardCharsets.UTF_8;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Writer;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.security.cert.Certificate;
import java.util.Queue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.jute.BinaryInputArchive;
import org.apache.jute.Record;
import org.apache.zookeeper.ClientCnxn;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.ZooDefs;
import org.apache.zookeeper.data.Id;
import org.apache.zookeeper.data.Stat;
import org.apache.zookeeper.proto.ReplyHeader;
import org.apache.zookeeper.proto.WatcherEvent;
import org.apache.zookeeper.server.NIOServerCnxnFactory.SelectorThread;
import org.apache.zookeeper.server.command.CommandExecutor;
import org.apache.zookeeper.server.command.FourLetterCommands;
import org.apache.zookeeper.server.command.NopCommand;
import org.apache.zookeeper.server.command.SetTraceMaskCommand;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class handles communication with clients using NIO. There is one per
 * client, but only one thread doing the communication.
 */
public class NIOServerCnxn extends ServerCnxn {

<span class="nc" id="L59">    private static final Logger LOG = LoggerFactory.getLogger(NIOServerCnxn.class);</span>

    private final NIOServerCnxnFactory factory;

    private final SocketChannel sock;

    private final SelectorThread selectorThread;

    private final SelectionKey sk;

    private boolean initialized;

<span class="nc" id="L71">    private final ByteBuffer lenBuffer = ByteBuffer.allocate(4);</span>

<span class="nc" id="L73">    protected ByteBuffer incomingBuffer = lenBuffer;</span>

<span class="nc" id="L75">    private final Queue&lt;ByteBuffer&gt; outgoingBuffers = new LinkedBlockingQueue&lt;ByteBuffer&gt;();</span>

    private int sessionTimeout;

    /**
     * This is the id that uniquely identifies the session of a client. Once
     * this session is no longer active, the ephemeral nodes will go away.
     */
    private long sessionId;

    /**
     * Client socket option for TCP keepalive
     */
<span class="nc" id="L88">    private final boolean clientTcpKeepAlive = Boolean.getBoolean(&quot;zookeeper.clientTcpKeepAlive&quot;);</span>

    public NIOServerCnxn(ZooKeeperServer zk, SocketChannel sock, SelectionKey sk, NIOServerCnxnFactory factory, SelectorThread selectorThread) throws IOException {
<span class="nc" id="L91">        super(zk);</span>
<span class="nc" id="L92">        this.sock = sock;</span>
<span class="nc" id="L93">        this.sk = sk;</span>
<span class="nc" id="L94">        this.factory = factory;</span>
<span class="nc" id="L95">        this.selectorThread = selectorThread;</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (this.factory.login != null) {</span>
<span class="nc" id="L97">            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);</span>
        }
<span class="nc" id="L99">        sock.socket().setTcpNoDelay(true);</span>
        /* set socket linger to false, so that socket close does not block */
<span class="nc" id="L101">        sock.socket().setSoLinger(false, -1);</span>
<span class="nc" id="L102">        sock.socket().setKeepAlive(clientTcpKeepAlive);</span>
<span class="nc" id="L103">        InetAddress addr = ((InetSocketAddress) sock.socket().getRemoteSocketAddress()).getAddress();</span>
<span class="nc" id="L104">        addAuthInfo(new Id(&quot;ip&quot;, addr.getHostAddress()));</span>
<span class="nc" id="L105">        this.sessionTimeout = factory.sessionlessCnxnTimeout;</span>
<span class="nc" id="L106">    }</span>

    /* Send close connection packet to the client, doIO will eventually
     * close the underlying machinery (like socket, selectorkey, etc...)
     */
    public void sendCloseSession() {
<span class="nc" id="L112">        sendBuffer(ServerCnxnFactory.closeConn);</span>
<span class="nc" id="L113">    }</span>

    /**
     * send buffer without using the asynchronous
     * calls to selector and then close the socket
     * @param bb
     */
    void sendBufferSync(ByteBuffer bb) {
        try {
            /* configure socket to be blocking
             * so that we dont have to do write in
             * a tight while loop
             */
<span class="nc bnc" id="L126" title="All 2 branches missed.">            if (bb != ServerCnxnFactory.closeConn) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                if (sock.isOpen()) {</span>
<span class="nc" id="L128">                    sock.configureBlocking(true);</span>
<span class="nc" id="L129">                    sock.write(bb);</span>
                }
<span class="nc" id="L131">                packetSent();</span>
            }
<span class="nc" id="L133">        } catch (IOException ie) {</span>
<span class="nc" id="L134">            LOG.error(&quot;Error sending data synchronously &quot;, ie);</span>
<span class="nc" id="L135">        }</span>
<span class="nc" id="L136">    }</span>

    /**
     * sendBuffer pushes a byte buffer onto the outgoing buffer queue for
     * asynchronous writes.
     */
    public void sendBuffer(ByteBuffer... buffers) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L144">            LOG.trace(&quot;Add a buffer to outgoingBuffers, sk {} is valid: {}&quot;, sk, sk.isValid());</span>
        }

<span class="nc" id="L147">        synchronized (outgoingBuffers) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            for (ByteBuffer buffer : buffers) {</span>
<span class="nc" id="L149">                outgoingBuffers.add(buffer);</span>
            }
<span class="nc" id="L151">            outgoingBuffers.add(packetSentinel);</span>
<span class="nc" id="L152">        }</span>
<span class="nc" id="L153">        requestInterestOpsUpdate();</span>
<span class="nc" id="L154">    }</span>

    /**
     * When read on socket failed, this is typically because client closed the
     * connection. In most cases, the client does this when the server doesn't
     * respond within 2/3 of session timeout. This possibly indicates server
     * health/performance issue, so we need to log and keep track of stat
     *
     * @throws EndOfStreamException
     */
    private void handleFailedRead() throws EndOfStreamException {
<span class="nc" id="L165">        setStale();</span>
<span class="nc" id="L166">        ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);</span>
<span class="nc" id="L167">        throw new EndOfStreamException(&quot;Unable to read additional data from client,&quot;</span>
                                       + &quot; it probably closed the socket:&quot;
<span class="nc" id="L169">                                       + &quot; address = &quot; + sock.socket().getRemoteSocketAddress() + &quot;,&quot;</span>
<span class="nc" id="L170">                                       + &quot; session = 0x&quot; + Long.toHexString(sessionId),</span>
                                       DisconnectReason.UNABLE_TO_READ_FROM_CLIENT);
    }

    /** Read the request payload (everything following the length prefix) */
    private void readPayload() throws IOException, InterruptedException, ClientCnxnLimitException {
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (incomingBuffer.remaining() != 0) { // have we read length bytes?</span>
<span class="nc" id="L177">            int rc = sock.read(incomingBuffer); // sock is non-blocking, so ok</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if (rc &lt; 0) {</span>
<span class="nc" id="L179">                handleFailedRead();</span>
            }
        }

<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (incomingBuffer.remaining() == 0) { // have we read length bytes?</span>
<span class="nc" id="L184">            incomingBuffer.flip();</span>
<span class="nc" id="L185">            packetReceived(4 + incomingBuffer.remaining());</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (!initialized) {</span>
<span class="nc" id="L187">                readConnectRequest();</span>
            } else {
<span class="nc" id="L189">                readRequest();</span>
            }
<span class="nc" id="L191">            lenBuffer.clear();</span>
<span class="nc" id="L192">            incomingBuffer = lenBuffer;</span>
        }
<span class="nc" id="L194">    }</span>

    /**
     * This boolean tracks whether the connection is ready for selection or
     * not. A connection is marked as not ready for selection while it is
     * processing an IO request. The flag is used to gatekeep pushing interest
     * op updates onto the selector.
     */
<span class="nc" id="L202">    private final AtomicBoolean selectable = new AtomicBoolean(true);</span>

    public boolean isSelectable() {
<span class="nc bnc" id="L205" title="All 4 branches missed.">        return sk.isValid() &amp;&amp; selectable.get();</span>
    }

    public void disableSelectable() {
<span class="nc" id="L209">        selectable.set(false);</span>
<span class="nc" id="L210">    }</span>

    public void enableSelectable() {
<span class="nc" id="L213">        selectable.set(true);</span>
<span class="nc" id="L214">    }</span>

    private void requestInterestOpsUpdate() {
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (isSelectable()) {</span>
<span class="nc" id="L218">            selectorThread.addInterestOpsUpdateRequest(sk);</span>
        }
<span class="nc" id="L220">    }</span>

    void handleWrite(SelectionKey k) throws IOException {
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (outgoingBuffers.isEmpty()) {</span>
<span class="nc" id="L224">            return;</span>
        }

        /*
         * This is going to reset the buffer position to 0 and the
         * limit to the size of the buffer, so that we can fill it
         * with data from the non-direct buffers that we need to
         * send.
         */
<span class="nc" id="L233">        ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (directBuffer == null) {</span>
<span class="nc" id="L235">            ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];</span>
            // Use gathered write call. This updates the positions of the
            // byte buffers to reflect the bytes that were written out.
<span class="nc" id="L238">            sock.write(outgoingBuffers.toArray(bufferList));</span>

            // Remove the buffers that we have sent
            ByteBuffer bb;
<span class="nc bnc" id="L242" title="All 2 branches missed.">            while ((bb = outgoingBuffers.peek()) != null) {</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">                if (bb == ServerCnxnFactory.closeConn) {</span>
<span class="nc" id="L244">                    throw new CloseRequestException(&quot;close requested&quot;, DisconnectReason.CLIENT_CLOSED_CONNECTION);</span>
                }
<span class="nc bnc" id="L246" title="All 2 branches missed.">                if (bb == packetSentinel) {</span>
<span class="nc" id="L247">                    packetSent();</span>
                }
<span class="nc bnc" id="L249" title="All 2 branches missed.">                if (bb.remaining() &gt; 0) {</span>
<span class="nc" id="L250">                    break;</span>
                }
<span class="nc" id="L252">                outgoingBuffers.remove();</span>
            }
<span class="nc" id="L254">        } else {</span>
<span class="nc" id="L255">            directBuffer.clear();</span>

<span class="nc bnc" id="L257" title="All 2 branches missed.">            for (ByteBuffer b : outgoingBuffers) {</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">                if (directBuffer.remaining() &lt; b.remaining()) {</span>
                    /*
                     * When we call put later, if the directBuffer is to
                     * small to hold everything, nothing will be copied,
                     * so we've got to slice the buffer if it's too big.
                     */
<span class="nc" id="L264">                    b = (ByteBuffer) b.slice().limit(directBuffer.remaining());</span>
                }
                /*
                 * put() is going to modify the positions of both
                 * buffers, put we don't want to change the position of
                 * the source buffers (we'll do that after the send, if
                 * needed), so we save and reset the position after the
                 * copy
                 */
<span class="nc" id="L273">                int p = b.position();</span>
<span class="nc" id="L274">                directBuffer.put(b);</span>
<span class="nc" id="L275">                b.position(p);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                if (directBuffer.remaining() == 0) {</span>
<span class="nc" id="L277">                    break;</span>
                }
<span class="nc" id="L279">            }</span>
            /*
             * Do the flip: limit becomes position, position gets set to
             * 0. This sets us up for the write.
             */
<span class="nc" id="L284">            directBuffer.flip();</span>

<span class="nc" id="L286">            int sent = sock.write(directBuffer);</span>

            ByteBuffer bb;

            // Remove the buffers that we have sent
<span class="nc bnc" id="L291" title="All 2 branches missed.">            while ((bb = outgoingBuffers.peek()) != null) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                if (bb == ServerCnxnFactory.closeConn) {</span>
<span class="nc" id="L293">                    throw new CloseRequestException(&quot;close requested&quot;, DisconnectReason.CLIENT_CLOSED_CONNECTION);</span>
                }
<span class="nc bnc" id="L295" title="All 2 branches missed.">                if (bb == packetSentinel) {</span>
<span class="nc" id="L296">                    packetSent();</span>
                }
<span class="nc bnc" id="L298" title="All 2 branches missed.">                if (sent &lt; bb.remaining()) {</span>
                    /*
                     * We only partially sent this buffer, so we update
                     * the position and exit the loop.
                     */
<span class="nc" id="L303">                    bb.position(bb.position() + sent);</span>
<span class="nc" id="L304">                    break;</span>
                }
                /* We've sent the whole buffer, so drop the buffer */
<span class="nc" id="L307">                sent -= bb.remaining();</span>
<span class="nc" id="L308">                outgoingBuffers.remove();</span>
            }
        }
<span class="nc" id="L311">    }</span>

    /**
     * Only used in order to allow testing
     */
    protected boolean isSocketOpen() {
<span class="nc" id="L317">        return sock.isOpen();</span>
    }

    /**
     * Handles read/write IO on connection.
     */
    void doIO(SelectionKey k) throws InterruptedException {
        try {
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (!isSocketOpen()) {</span>
<span class="nc" id="L326">                LOG.warn(&quot;trying to do i/o on a null socket for session: 0x{}&quot;, Long.toHexString(sessionId));</span>

<span class="nc" id="L328">                return;</span>
            }
<span class="nc bnc" id="L330" title="All 2 branches missed.">            if (k.isReadable()) {</span>
<span class="nc" id="L331">                int rc = sock.read(incomingBuffer);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                if (rc &lt; 0) {</span>
<span class="nc" id="L333">                    handleFailedRead();</span>
                }
<span class="nc bnc" id="L335" title="All 2 branches missed.">                if (incomingBuffer.remaining() == 0) {</span>
                    boolean isPayload;
<span class="nc bnc" id="L337" title="All 2 branches missed.">                    if (incomingBuffer == lenBuffer) { // start of next request</span>
<span class="nc" id="L338">                        incomingBuffer.flip();</span>
<span class="nc" id="L339">                        isPayload = readLength(k);</span>
<span class="nc" id="L340">                        incomingBuffer.clear();</span>
                    } else {
                        // continuation
<span class="nc" id="L343">                        isPayload = true;</span>
                    }
<span class="nc bnc" id="L345" title="All 2 branches missed.">                    if (isPayload) { // not the case for 4letterword</span>
<span class="nc" id="L346">                        readPayload();</span>
                    } else {
                        // four letter words take care
                        // need not do anything else
<span class="nc" id="L350">                        return;</span>
                    }
                }
            }
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (k.isWritable()) {</span>
<span class="nc" id="L355">                handleWrite(k);</span>

<span class="nc bnc" id="L357" title="All 6 branches missed.">                if (!initialized &amp;&amp; !getReadInterest() &amp;&amp; !getWriteInterest()) {</span>
<span class="nc" id="L358">                    throw new CloseRequestException(&quot;responded to info probe&quot;, DisconnectReason.INFO_PROBE);</span>
                }
            }
<span class="nc" id="L361">        } catch (CancelledKeyException e) {</span>
<span class="nc" id="L362">            LOG.warn(&quot;CancelledKeyException causing close of session: 0x{}&quot;, Long.toHexString(sessionId));</span>

<span class="nc" id="L364">            LOG.debug(&quot;CancelledKeyException stack trace&quot;, e);</span>

<span class="nc" id="L366">            close(DisconnectReason.CANCELLED_KEY_EXCEPTION);</span>
<span class="nc" id="L367">        } catch (CloseRequestException e) {</span>
            // expecting close to log session closure
<span class="nc" id="L369">            close();</span>
<span class="nc" id="L370">        } catch (EndOfStreamException e) {</span>
<span class="nc" id="L371">            LOG.warn(&quot;Unexpected exception&quot;, e);</span>
            // expecting close to log session closure
<span class="nc" id="L373">            close(e.getReason());</span>
<span class="nc" id="L374">        } catch (ClientCnxnLimitException e) {</span>
            // Common case exception, print at debug level
<span class="nc" id="L376">            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);</span>
<span class="nc" id="L377">            LOG.warn(&quot;Closing session 0x{}&quot;, Long.toHexString(sessionId), e);</span>
<span class="nc" id="L378">            close(DisconnectReason.CLIENT_CNX_LIMIT);</span>
<span class="nc" id="L379">        } catch (IOException e) {</span>
<span class="nc" id="L380">            LOG.warn(&quot;Close of session 0x{}&quot;, Long.toHexString(sessionId), e);</span>
<span class="nc" id="L381">            close(DisconnectReason.IO_EXCEPTION);</span>
<span class="nc" id="L382">        }</span>
<span class="nc" id="L383">    }</span>

    protected void readRequest() throws IOException {
<span class="nc" id="L386">        zkServer.processPacket(this, incomingBuffer);</span>
<span class="nc" id="L387">    }</span>

    // returns whether we are interested in writing, which is determined
    // by whether we have any pending buffers on the output queue or not
    private boolean getWriteInterest() {
<span class="nc bnc" id="L392" title="All 2 branches missed.">        return !outgoingBuffers.isEmpty();</span>
    }

    // returns whether we are interested in taking new requests, which is
    // determined by whether we are currently throttled or not
    private boolean getReadInterest() {
<span class="nc bnc" id="L398" title="All 2 branches missed.">        return !throttled.get();</span>
    }

<span class="nc" id="L401">    private final AtomicBoolean throttled = new AtomicBoolean(false);</span>

    // Throttle acceptance of new requests. If this entailed a state change,
    // register an interest op update request with the selector.
    //
    // Don't support wait disable receive in NIO, ignore the parameter
    public void disableRecv(boolean waitDisableRecv) {
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (throttled.compareAndSet(false, true)) {</span>
<span class="nc" id="L409">            requestInterestOpsUpdate();</span>
        }
<span class="nc" id="L411">    }</span>

    // Disable throttling and resume acceptance of new requests. If this
    // entailed a state change, register an interest op update request with
    // the selector.
    public void enableRecv() {
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (throttled.compareAndSet(true, false)) {</span>
<span class="nc" id="L418">            requestInterestOpsUpdate();</span>
        }
<span class="nc" id="L420">    }</span>

    private void readConnectRequest() throws IOException, InterruptedException, ClientCnxnLimitException {
<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (!isZKServerRunning()) {</span>
<span class="nc" id="L424">            throw new IOException(&quot;ZooKeeperServer not running&quot;);</span>
        }
<span class="nc" id="L426">        zkServer.processConnectRequest(this, incomingBuffer);</span>
<span class="nc" id="L427">        initialized = true;</span>
<span class="nc" id="L428">    }</span>

    /**
     * This class wraps the sendBuffer method of NIOServerCnxn. It is
     * responsible for chunking up the response to a client. Rather
     * than cons'ing up a response fully in memory, which may be large
     * for some commands, this class chunks up the result.
     */
<span class="nc" id="L436">    private class SendBufferWriter extends Writer {</span>

<span class="nc" id="L438">        private StringBuffer sb = new StringBuffer();</span>

        /**
         * Check if we are ready to send another chunk.
         * @param force force sending, even if not a full chunk
         */
        private void checkFlush(boolean force) {
<span class="nc bnc" id="L445" title="All 6 branches missed.">            if ((force &amp;&amp; sb.length() &gt; 0) || sb.length() &gt; 2048) {</span>
<span class="nc" id="L446">                sendBufferSync(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));</span>
                // clear our internal buffer
<span class="nc" id="L448">                sb.setLength(0);</span>
            }
<span class="nc" id="L450">        }</span>

        @Override
        public void close() throws IOException {
<span class="nc bnc" id="L454" title="All 2 branches missed.">            if (sb == null) {</span>
<span class="nc" id="L455">                return;</span>
            }
<span class="nc" id="L457">            checkFlush(true);</span>
<span class="nc" id="L458">            sb = null; // clear out the ref to ensure no reuse</span>
<span class="nc" id="L459">        }</span>

        @Override
        public void flush() throws IOException {
<span class="nc" id="L463">            checkFlush(true);</span>
<span class="nc" id="L464">        }</span>

        @Override
        public void write(char[] cbuf, int off, int len) throws IOException {
<span class="nc" id="L468">            sb.append(cbuf, off, len);</span>
<span class="nc" id="L469">            checkFlush(false);</span>
<span class="nc" id="L470">        }</span>

    }
    /** Return if four letter word found and responded to, otw false **/
    private boolean checkFourLetterWord(final SelectionKey k, final int len) throws IOException {
        // We take advantage of the limited size of the length to look
        // for cmds. They are all 4-bytes which fits inside of an int
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (!FourLetterCommands.isKnown(len)) {</span>
<span class="nc" id="L478">            return false;</span>
        }

<span class="nc" id="L481">        String cmd = FourLetterCommands.getCommandString(len);</span>
<span class="nc" id="L482">        packetReceived(4);</span>

        /** cancel the selection key to remove the socket handling
         * from selector. This is to prevent netcat problem wherein
         * netcat immediately closes the sending side after sending the
         * commands and still keeps the receiving channel open.
         * The idea is to remove the selectionkey from the selector
         * so that the selector does not notice the closed read on the
         * socket channel and keep the socket alive to write the data to
         * and makes sure to close the socket after its done writing the data
         */
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (k != null) {</span>
            try {
<span class="nc" id="L495">                k.cancel();</span>
<span class="nc" id="L496">            } catch (Exception e) {</span>
<span class="nc" id="L497">                LOG.error(&quot;Error cancelling command selection key&quot;, e);</span>
<span class="nc" id="L498">            }</span>
        }

<span class="nc" id="L501">        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));</span>

        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (!FourLetterCommands.isEnabled(cmd)) {</span>
<span class="nc" id="L505">            LOG.debug(&quot;Command {} is not executed because it is not in the whitelist.&quot;, cmd);</span>
<span class="nc" id="L506">            NopCommand nopCmd = new NopCommand(</span>
                pwriter,
                this,
                cmd + &quot; is not executed because it is not in the whitelist.&quot;);
<span class="nc" id="L510">            nopCmd.start();</span>
<span class="nc" id="L511">            return true;</span>
        }

<span class="nc" id="L514">        LOG.info(&quot;Processing {} command from {}&quot;, cmd, sock.socket().getRemoteSocketAddress());</span>

<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (len == FourLetterCommands.setTraceMaskCmd) {</span>
<span class="nc" id="L517">            incomingBuffer = ByteBuffer.allocate(8);</span>
<span class="nc" id="L518">            int rc = sock.read(incomingBuffer);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if (rc &lt; 0) {</span>
<span class="nc" id="L520">                throw new IOException(&quot;Read error&quot;);</span>
            }
<span class="nc" id="L522">            incomingBuffer.flip();</span>
<span class="nc" id="L523">            long traceMask = incomingBuffer.getLong();</span>
<span class="nc" id="L524">            ZooTrace.setTextTraceLevel(traceMask);</span>
<span class="nc" id="L525">            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);</span>
<span class="nc" id="L526">            setMask.start();</span>
<span class="nc" id="L527">            return true;</span>
        } else {
<span class="nc" id="L529">            CommandExecutor commandExecutor = new CommandExecutor();</span>
<span class="nc" id="L530">            return commandExecutor.execute(this, pwriter, len, zkServer, factory);</span>
        }
    }

    /** Reads the first 4 bytes of lenBuffer, which could be true length or
     *  four letter word.
     *
     * @param k selection key
     * @return true if length read, otw false (wasn't really the length)
     * @throws IOException if buffer size exceeds maxBuffer size
     */
    private boolean readLength(SelectionKey k) throws IOException {
        // Read the length, now get the buffer
<span class="nc" id="L543">        int len = lenBuffer.getInt();</span>
<span class="nc bnc" id="L544" title="All 4 branches missed.">        if (!initialized &amp;&amp; checkFourLetterWord(sk, len)) {</span>
<span class="nc" id="L545">            return false;</span>
        }
<span class="nc bnc" id="L547" title="All 4 branches missed.">        if (len &lt; 0 || len &gt; BinaryInputArchive.maxBuffer) {</span>
<span class="nc" id="L548">            throw new IOException(&quot;Len error. &quot;</span>
<span class="nc" id="L549">                    + &quot;A message from &quot; +  this.getRemoteSocketAddress() + &quot; with advertised length of &quot; + len</span>
                    + &quot; is either a malformed message or too large to process&quot;
                    + &quot; (length is greater than jute.maxbuffer=&quot; + BinaryInputArchive.maxBuffer + &quot;)&quot;);
        }
<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (!isZKServerRunning()) {</span>
<span class="nc" id="L554">            throw new IOException(&quot;ZooKeeperServer not running&quot;);</span>
        }
        // checkRequestSize will throw IOException if request is rejected
<span class="nc" id="L557">        zkServer.checkRequestSizeWhenReceivingMessage(len);</span>
<span class="nc" id="L558">        incomingBuffer = ByteBuffer.allocate(len);</span>
<span class="nc" id="L559">        return true;</span>
    }

    /*
     * (non-Javadoc)
     *
     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionTimeout()
     */
    public int getSessionTimeout() {
<span class="nc" id="L568">        return sessionTimeout;</span>
    }

    /**
     * Used by &quot;dump&quot; 4-letter command to list all connection in
     * cnxnExpiryMap
     */
    @Override
    public String toString() {
<span class="nc" id="L577">        return &quot;ip: &quot; + sock.socket().getRemoteSocketAddress() + &quot; sessionId: 0x&quot; + Long.toHexString(sessionId);</span>
    }

    /**
     * Close the cnxn and remove it from the factory cnxns list.
     */
    @Override
    public void close(DisconnectReason reason) {
<span class="nc" id="L585">        disconnectReason = reason;</span>
<span class="nc" id="L586">        close();</span>
<span class="nc" id="L587">    }</span>

    private void close() {
<span class="nc" id="L590">        setStale();</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">        if (!factory.removeCnxn(this)) {</span>
<span class="nc" id="L592">            return;</span>
        }

<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (zkServer != null) {</span>
<span class="nc" id="L596">            zkServer.removeCnxn(this);</span>
        }

<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (sk != null) {</span>
            try {
                // need to cancel this selection key from the selector
<span class="nc" id="L602">                sk.cancel();</span>
<span class="nc" id="L603">            } catch (Exception e) {</span>
<span class="nc" id="L604">                LOG.debug(&quot;ignoring exception during selectionkey cancel&quot;, e);</span>
<span class="nc" id="L605">            }</span>
        }

<span class="nc" id="L608">        closeSock();</span>
<span class="nc" id="L609">    }</span>

    /**
     * Close resources associated with the sock of this cnxn.
     */
    private void closeSock() {
<span class="nc bnc" id="L615" title="All 2 branches missed.">        if (!sock.isOpen()) {</span>
<span class="nc" id="L616">            return;</span>
        }

<span class="nc" id="L619">        String logMsg = String.format(</span>
            &quot;Closed socket connection for client %s %s&quot;,
<span class="nc" id="L621">            sock.socket().getRemoteSocketAddress(),</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">            sessionId != 0</span>
<span class="nc" id="L623">                ? &quot;which had sessionid 0x&quot; + Long.toHexString(sessionId)</span>
<span class="nc" id="L624">                : &quot;(no session established for client)&quot;</span>
            );
<span class="nc" id="L626">        LOG.debug(logMsg);</span>

<span class="nc" id="L628">        closeSock(sock);</span>
<span class="nc" id="L629">    }</span>

    /**
     * Close resources associated with a sock.
     */
    public static void closeSock(SocketChannel sock) {
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (!sock.isOpen()) {</span>
<span class="nc" id="L636">            return;</span>
        }

        try {
            /*
             * The following sequence of code is stupid! You would think that
             * only sock.close() is needed, but alas, it doesn't work that way.
             * If you just do sock.close() there are cases where the socket
             * doesn't actually close...
             */
<span class="nc" id="L646">            sock.socket().shutdownOutput();</span>
<span class="nc" id="L647">        } catch (IOException e) {</span>
            // This is a relatively common exception that we can't avoid
<span class="nc" id="L649">            LOG.debug(&quot;ignoring exception during output shutdown&quot;, e);</span>
<span class="nc" id="L650">        }</span>
        try {
<span class="nc" id="L652">            sock.socket().shutdownInput();</span>
<span class="nc" id="L653">        } catch (IOException e) {</span>
            // This is a relatively common exception that we can't avoid
<span class="nc" id="L655">            LOG.debug(&quot;ignoring exception during input shutdown&quot;, e);</span>
<span class="nc" id="L656">        }</span>
        try {
<span class="nc" id="L658">            sock.socket().close();</span>
<span class="nc" id="L659">        } catch (IOException e) {</span>
<span class="nc" id="L660">            LOG.debug(&quot;ignoring exception during socket close&quot;, e);</span>
<span class="nc" id="L661">        }</span>
        try {
<span class="nc" id="L663">            sock.close();</span>
<span class="nc" id="L664">        } catch (IOException e) {</span>
<span class="nc" id="L665">            LOG.debug(&quot;ignoring exception during socketchannel close&quot;, e);</span>
<span class="nc" id="L666">        }</span>
<span class="nc" id="L667">    }</span>

<span class="nc" id="L669">    private static final ByteBuffer packetSentinel = ByteBuffer.allocate(0);</span>

    @Override
    public int sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat, int opCode) {
<span class="nc" id="L673">        int responseSize = 0;</span>
        try {
<span class="nc" id="L675">            ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);</span>
<span class="nc" id="L676">            responseSize = bb[0].getInt();</span>
<span class="nc" id="L677">            bb[0].rewind();</span>
<span class="nc" id="L678">            sendBuffer(bb);</span>
<span class="nc" id="L679">            decrOutstandingAndCheckThrottle(h);</span>
<span class="nc" id="L680">        } catch (Exception e) {</span>
<span class="nc" id="L681">            LOG.warn(&quot;Unexpected exception. Destruction averted.&quot;, e);</span>
<span class="nc" id="L682">        }</span>
<span class="nc" id="L683">        return responseSize;</span>
    }

    /*
     * (non-Javadoc)
     *
     * @see org.apache.zookeeper.server.ServerCnxnIface#process(org.apache.zookeeper.proto.WatcherEvent)
     */
    @Override
    public void process(WatchedEvent event) {
<span class="nc" id="L693">        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L695">            ZooTrace.logTraceMessage(</span>
                LOG,
                ZooTrace.EVENT_DELIVERY_TRACE_MASK,
<span class="nc" id="L698">                &quot;Deliver event &quot; + event + &quot; to 0x&quot; + Long.toHexString(this.sessionId) + &quot; through &quot; + this);</span>
        }

        // Convert WatchedEvent to a type that can be sent over the wire
<span class="nc" id="L702">        WatcherEvent e = event.getWrapper();</span>

        // The last parameter OpCode here is used to select the response cache.
        // Passing OpCode.error (with a value of -1) means we don't care, as we don't need
        // response cache on delivering watcher events.
<span class="nc" id="L707">        int responseSize = sendResponse(h, e, &quot;notification&quot;, null, null, ZooDefs.OpCode.error);</span>
<span class="nc" id="L708">        ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);</span>
<span class="nc" id="L709">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionId()
     */
    @Override
    public long getSessionId() {
<span class="nc" id="L718">        return sessionId;</span>
    }

    @Override
    public void setSessionId(long sessionId) {
<span class="nc" id="L723">        this.sessionId = sessionId;</span>
<span class="nc" id="L724">        factory.addSession(sessionId, this);</span>
<span class="nc" id="L725">    }</span>

    @Override
    public void setSessionTimeout(int sessionTimeout) {
<span class="nc" id="L729">        this.sessionTimeout = sessionTimeout;</span>
<span class="nc" id="L730">        factory.touchCnxn(this);</span>
<span class="nc" id="L731">    }</span>

    @Override
    public int getInterestOps() {
<span class="nc bnc" id="L735" title="All 2 branches missed.">        if (!isSelectable()) {</span>
<span class="nc" id="L736">            return 0;</span>
        }
<span class="nc" id="L738">        int interestOps = 0;</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (getReadInterest()) {</span>
<span class="nc" id="L740">            interestOps |= SelectionKey.OP_READ;</span>
        }
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (getWriteInterest()) {</span>
<span class="nc" id="L743">            interestOps |= SelectionKey.OP_WRITE;</span>
        }
<span class="nc" id="L745">        return interestOps;</span>
    }

    @Override
    public InetSocketAddress getRemoteSocketAddress() {
<span class="nc bnc" id="L750" title="All 2 branches missed.">        if (!sock.isOpen()) {</span>
<span class="nc" id="L751">            return null;</span>
        }
<span class="nc" id="L753">        return (InetSocketAddress) sock.socket().getRemoteSocketAddress();</span>
    }

    public InetAddress getSocketAddress() {
<span class="nc bnc" id="L757" title="All 2 branches missed.">        if (!sock.isOpen()) {</span>
<span class="nc" id="L758">            return null;</span>
        }
<span class="nc" id="L760">        return sock.socket().getInetAddress();</span>
    }

    @Override
    protected ServerStats serverStats() {
<span class="nc bnc" id="L765" title="All 2 branches missed.">        if (zkServer == null) {</span>
<span class="nc" id="L766">            return null;</span>
        }
<span class="nc" id="L768">        return zkServer.serverStats();</span>
    }

    @Override
    public boolean isSecure() {
<span class="nc" id="L773">        return false;</span>
    }

    @Override
    public Certificate[] getClientCertificateChain() {
<span class="nc" id="L778">        throw new UnsupportedOperationException(&quot;SSL is unsupported in NIOServerCnxn&quot;);</span>
    }

    @Override
    public void setClientCertificateChain(Certificate[] chain) {
<span class="nc" id="L783">        throw new UnsupportedOperationException(&quot;SSL is unsupported in NIOServerCnxn&quot;);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>