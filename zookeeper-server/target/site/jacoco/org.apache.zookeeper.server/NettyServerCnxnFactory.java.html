<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NettyServerCnxnFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">NettyServerCnxnFactory.java</span></div><h1>NettyServerCnxnFactory.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelDuplexHandler;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.ChannelGroupFuture;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.handler.ssl.OptionalSslHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslHandler;
import io.netty.util.AttributeKey;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.concurrent.DefaultEventExecutor;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLPeerUnverifiedException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.X509KeyManager;
import javax.net.ssl.X509TrustManager;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.common.ClientX509Util;
import org.apache.zookeeper.common.NettyUtils;
import org.apache.zookeeper.common.SSLContextAndOptions;
import org.apache.zookeeper.common.X509Exception;
import org.apache.zookeeper.common.X509Exception.SSLContextException;
import org.apache.zookeeper.server.NettyServerCnxn.HandshakeState;
import org.apache.zookeeper.server.auth.ProviderRegistry;
import org.apache.zookeeper.server.auth.X509AuthenticationProvider;
import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class NettyServerCnxnFactory extends ServerCnxnFactory {

<span class="nc" id="L82">    private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxnFactory.class);</span>

    /**
     * Allow client-server sockets to accept both SSL and plaintext connections
     */
    public static final String PORT_UNIFICATION_KEY = &quot;zookeeper.client.portUnification&quot;;
    private final boolean shouldUsePortUnification;

    /**
     * The first byte in TLS protocol is the content type of the subsequent record.
     * Handshakes use value 22 (0x16) so the first byte offered on any TCP connection
     * attempting to establish a TLS connection will be this value.
     * https://tools.ietf.org/html/rfc8446#page-79
     */
    private static final byte TLS_HANDSHAKE_RECORD_TYPE = 0x16;

<span class="nc" id="L98">    private final AtomicInteger outstandingHandshake = new AtomicInteger();</span>
    public static final String OUTSTANDING_HANDSHAKE_LIMIT = &quot;zookeeper.netty.server.outstandingHandshake.limit&quot;;
    private int outstandingHandshakeLimit;
    private boolean handshakeThrottlingEnabled;

    public void setOutstandingHandshakeLimit(int limit) {
<span class="nc" id="L104">        outstandingHandshakeLimit = limit;</span>
<span class="nc bnc" id="L105" title="All 6 branches missed.">        handshakeThrottlingEnabled = (secure || shouldUsePortUnification) &amp;&amp; outstandingHandshakeLimit &gt; 0;</span>
<span class="nc" id="L106">        LOG.info(&quot;handshakeThrottlingEnabled = {}, {} = {}&quot;,</span>
<span class="nc" id="L107">                handshakeThrottlingEnabled, OUTSTANDING_HANDSHAKE_LIMIT, outstandingHandshakeLimit);</span>
<span class="nc" id="L108">    }</span>

    private final ServerBootstrap bootstrap;
    private Channel parentChannel;
<span class="nc" id="L112">    private final ChannelGroup allChannels = new DefaultChannelGroup(&quot;zkServerCnxns&quot;, new DefaultEventExecutor());</span>
<span class="nc" id="L113">    private final Map&lt;InetAddress, AtomicInteger&gt; ipMap = new ConcurrentHashMap&lt;&gt;();</span>
    private InetSocketAddress localAddress;
<span class="nc" id="L115">    private int maxClientCnxns = 60;</span>
<span class="nc" id="L116">    int listenBacklog = -1;</span>
    private final ClientX509Util x509Util;

    public static final String NETTY_ADVANCED_FLOW_CONTROL = &quot;zookeeper.netty.advancedFlowControl.enabled&quot;;
<span class="nc" id="L120">    private boolean advancedFlowControlEnabled = false;</span>

<span class="nc" id="L122">    private static final AttributeKey&lt;NettyServerCnxn&gt; CONNECTION_ATTRIBUTE = AttributeKey.valueOf(&quot;NettyServerCnxn&quot;);</span>

<span class="nc" id="L124">    private static final AtomicReference&lt;ByteBufAllocator&gt; TEST_ALLOCATOR = new AtomicReference&lt;&gt;(null);</span>

    /**
     * A handler that detects whether the client would like to use
     * TLS or not and responds in kind. The first bytes are examined
     * for the static TLS headers to make the determination and
     * placed back in the stream with the correct ChannelHandler
     * instantiated.
     */
    class DualModeSslHandler extends OptionalSslHandler {

<span class="nc" id="L135">        DualModeSslHandler(SslContext sslContext) {</span>
<span class="nc" id="L136">            super(sslContext);</span>
<span class="nc" id="L137">        }</span>

        @Override
        protected void decode(ChannelHandlerContext context, ByteBuf in, List&lt;Object&gt; out) throws Exception {
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (in.readableBytes() &gt;= 5) {</span>
<span class="nc" id="L142">                super.decode(context, in, out);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">            } else if (in.readableBytes() &gt; 0) {</span>
                // It requires 5 bytes to detect a proper ssl connection. In the
                // case that the server receives fewer, check if we can fail to plaintext.
                // This will occur when for any four letter work commands.
<span class="nc bnc" id="L147" title="All 2 branches missed.">                if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {</span>
<span class="nc" id="L148">                    LOG.debug(&quot;first byte {} does not match TLS handshake, failing to plaintext&quot;, in.getByte(0));</span>
<span class="nc" id="L149">                    handleNonSsl(context);</span>
                }
            }
<span class="nc" id="L152">        }</span>

        /**
         * pulled directly from OptionalSslHandler to allow for access
         * @param context
         */
        private void handleNonSsl(ChannelHandlerContext context) {
<span class="nc" id="L159">            ChannelHandler handler = this.newNonSslHandler(context);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">            if (handler != null) {</span>
<span class="nc" id="L161">                context.pipeline().replace(this, this.newNonSslHandlerName(), handler);</span>
            } else {
<span class="nc" id="L163">                context.pipeline().remove(this);</span>
            }
<span class="nc" id="L165">        }</span>

        @Override
        protected SslHandler newSslHandler(ChannelHandlerContext context, SslContext sslContext) {
<span class="nc" id="L169">            NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());</span>
<span class="nc" id="L170">            LOG.debug(&quot;creating ssl handler for session {}&quot;, cnxn.getSessionId());</span>
<span class="nc" id="L171">            SslHandler handler = super.newSslHandler(context, sslContext);</span>
<span class="nc" id="L172">            Future&lt;Channel&gt; handshakeFuture = handler.handshakeFuture();</span>
<span class="nc" id="L173">            handshakeFuture.addListener(new CertificateVerifier(handler, cnxn));</span>
<span class="nc" id="L174">            return handler;</span>
        }

        @Override
        protected ChannelHandler newNonSslHandler(ChannelHandlerContext context) {
<span class="nc" id="L179">            NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());</span>
<span class="nc" id="L180">            LOG.debug(&quot;creating plaintext handler for session {}&quot;, cnxn.getSessionId());</span>
            // Mark handshake finished if it's a insecure cnxn
<span class="nc" id="L182">            updateHandshakeCountIfStarted(cnxn);</span>
<span class="nc" id="L183">            allChannels.add(context.channel());</span>
<span class="nc" id="L184">            addCnxn(cnxn);</span>
<span class="nc" id="L185">            return super.newNonSslHandler(context);</span>
        }

    }

    private void updateHandshakeCountIfStarted(NettyServerCnxn cnxn) {
<span class="nc bnc" id="L191" title="All 4 branches missed.">        if (cnxn != null &amp;&amp; cnxn.getHandshakeState() == HandshakeState.STARTED) {</span>
<span class="nc" id="L192">            cnxn.setHandshakeState(HandshakeState.FINISHED);</span>
<span class="nc" id="L193">            outstandingHandshake.addAndGet(-1);</span>
        }
<span class="nc" id="L195">    }</span>

    /**
     * This is an inner class since we need to extend ChannelDuplexHandler, but
     * NettyServerCnxnFactory already extends ServerCnxnFactory. By making it inner
     * this class gets access to the member variables and methods.
     */
    @Sharable
<span class="nc" id="L203">    class CnxnChannelHandler extends ChannelDuplexHandler {</span>

        @Override
        public void channelActive(ChannelHandlerContext ctx) throws Exception {
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L208">                LOG.trace(&quot;Channel active {}&quot;, ctx.channel());</span>
            }

<span class="nc" id="L211">            final Channel channel = ctx.channel();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (limitTotalNumberOfCnxns()) {</span>
<span class="nc" id="L213">                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);</span>
<span class="nc" id="L214">                channel.close();</span>
<span class="nc" id="L215">                return;</span>
            }
<span class="nc" id="L217">            InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();</span>
<span class="nc bnc" id="L218" title="All 4 branches missed.">            if (maxClientCnxns &gt; 0 &amp;&amp; getClientCnxnCount(addr) &gt;= maxClientCnxns) {</span>
<span class="nc" id="L219">                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);</span>
<span class="nc" id="L220">                LOG.warn(&quot;Too many connections from {} - max is {}&quot;, addr, maxClientCnxns);</span>
<span class="nc" id="L221">                channel.close();</span>
<span class="nc" id="L222">                return;</span>
            }

<span class="nc" id="L225">            NettyServerCnxn cnxn = new NettyServerCnxn(channel, zkServer, NettyServerCnxnFactory.this);</span>
<span class="nc" id="L226">            ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);</span>

            // Check the zkServer assigned to the cnxn is still running,
            // close it before starting the heavy TLS handshake
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (!cnxn.isZKServerRunning()) {</span>
<span class="nc" id="L231">                LOG.warn(&quot;Zookeeper server is not running, close the connection before starting the TLS handshake&quot;);</span>
<span class="nc" id="L232">                ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);</span>
<span class="nc" id="L233">                channel.close();</span>
<span class="nc" id="L234">                return;</span>
            }

<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (handshakeThrottlingEnabled) {</span>
                // Favor to check and throttling even in dual mode which
                // accepts both secure and insecure connections, since
                // it's more efficient than throttling when we know it's
                // a secure connection in DualModeSslHandler.
                //
                // From benchmark, this reduced around 15% reconnect time.
<span class="nc" id="L244">                int outstandingHandshakesNum = outstandingHandshake.addAndGet(1);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                if (outstandingHandshakesNum &gt; outstandingHandshakeLimit) {</span>
<span class="nc" id="L246">                    outstandingHandshake.addAndGet(-1);</span>
<span class="nc" id="L247">                    channel.close();</span>
<span class="nc" id="L248">                    ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED.add(1);</span>
                } else {
<span class="nc" id="L250">                    cnxn.setHandshakeState(HandshakeState.STARTED);</span>
                }
            }

<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (secure) {</span>
<span class="nc" id="L255">                SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);</span>
<span class="nc" id="L256">                Future&lt;Channel&gt; handshakeFuture = sslHandler.handshakeFuture();</span>
<span class="nc" id="L257">                handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            } else if (!shouldUsePortUnification) {</span>
<span class="nc" id="L259">                allChannels.add(ctx.channel());</span>
<span class="nc" id="L260">                addCnxn(cnxn);</span>
            }
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (ctx.channel().pipeline().get(SslHandler.class) == null) {</span>
<span class="nc" id="L263">                SocketAddress remoteAddress = cnxn.getChannel().remoteAddress();</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                if (remoteAddress != null</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">                        &amp;&amp; !((InetSocketAddress) remoteAddress).getAddress().isLoopbackAddress()) {</span>
<span class="nc" id="L266">                    LOG.trace(&quot;NettyChannelHandler channelActive: remote={} local={}&quot;, remoteAddress, cnxn.getChannel().localAddress());</span>
<span class="nc" id="L267">                    zkServer.serverStats().incrementNonMTLSRemoteConnCount();</span>
                } else {
<span class="nc" id="L269">                    zkServer.serverStats().incrementNonMTLSLocalConnCount();</span>
                }
            }
<span class="nc" id="L272">        }</span>

        @Override
        public void channelInactive(ChannelHandlerContext ctx) throws Exception {
<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L277">                LOG.trace(&quot;Channel inactive {}&quot;, ctx.channel());</span>
            }

<span class="nc" id="L280">            allChannels.remove(ctx.channel());</span>
<span class="nc" id="L281">            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (cnxn != null) {</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L284">                    LOG.trace(&quot;Channel inactive caused close {}&quot;, cnxn);</span>
                }
<span class="nc" id="L286">                updateHandshakeCountIfStarted(cnxn);</span>
<span class="nc" id="L287">                cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_DISCONNECTED);</span>
            }
<span class="nc" id="L289">        }</span>

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
<span class="nc" id="L293">            LOG.warn(&quot;Exception caught&quot;, cause);</span>
<span class="nc" id="L294">            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (cnxn != null) {</span>
<span class="nc" id="L296">                LOG.debug(&quot;Closing {}&quot;, cnxn);</span>
<span class="nc" id="L297">                updateHandshakeCountIfStarted(cnxn);</span>
<span class="nc" id="L298">                cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);</span>
            }
<span class="nc" id="L300">        }</span>

        @Override
        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
            try {
<span class="nc bnc" id="L305" title="All 2 branches missed.">                if (evt == NettyServerCnxn.ReadEvent.ENABLE) {</span>
<span class="nc" id="L306">                    LOG.debug(&quot;Received ReadEvent.ENABLE&quot;);</span>
<span class="nc" id="L307">                    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();</span>
                    // TODO: Not sure if cnxn can be null here. It becomes null if channelInactive()
                    // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run
                    // after either of those. Check for null just to be safe ...
<span class="nc bnc" id="L311" title="All 2 branches missed.">                    if (cnxn != null) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                        if (cnxn.getQueuedReadableBytes() &gt; 0) {</span>
<span class="nc" id="L313">                            cnxn.processQueuedBuffer();</span>
<span class="nc bnc" id="L314" title="All 4 branches missed.">                            if (advancedFlowControlEnabled &amp;&amp; cnxn.getQueuedReadableBytes() == 0) {</span>
                                // trigger a read if we have consumed all
                                // backlog
<span class="nc" id="L317">                                ctx.read();</span>
<span class="nc" id="L318">                                LOG.debug(&quot;Issued a read after queuedBuffer drained&quot;);</span>
                            }
                        }
                    }
<span class="nc bnc" id="L322" title="All 2 branches missed.">                    if (!advancedFlowControlEnabled) {</span>
<span class="nc" id="L323">                        ctx.channel().config().setAutoRead(true);</span>
                    }
<span class="nc bnc" id="L325" title="All 2 branches missed.">                } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {</span>
<span class="nc" id="L326">                    LOG.debug(&quot;Received ReadEvent.DISABLE&quot;);</span>
<span class="nc" id="L327">                    ctx.channel().config().setAutoRead(false);</span>
                }
            } finally {
<span class="nc" id="L330">                ReferenceCountUtil.release(evt);</span>
            }
<span class="nc" id="L332">        }</span>

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            try {
<span class="nc bnc" id="L337" title="All 2 branches missed.">                if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L338">                    LOG.trace(&quot;message received called {}&quot;, msg);</span>
                }
                try {
<span class="nc" id="L341">                    LOG.debug(&quot;New message {} from {}&quot;, msg, ctx.channel());</span>
<span class="nc" id="L342">                    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                    if (cnxn == null) {</span>
<span class="nc" id="L344">                        LOG.error(&quot;channelRead() on a closed or closing NettyServerCnxn&quot;);</span>
                    } else {
<span class="nc" id="L346">                        cnxn.processMessage((ByteBuf) msg);</span>
                    }
<span class="nc" id="L348">                } catch (Exception ex) {</span>
<span class="nc" id="L349">                    LOG.error(&quot;Unexpected exception in receive&quot;, ex);</span>
<span class="nc" id="L350">                    throw ex;</span>
<span class="nc" id="L351">                }</span>
            } finally {
<span class="nc" id="L353">                ReferenceCountUtil.release(msg);</span>
            }
<span class="nc" id="L355">        }</span>

        @Override
        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (advancedFlowControlEnabled) {</span>
<span class="nc" id="L360">                NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();</span>
<span class="nc bnc" id="L361" title="All 6 branches missed.">                if (cnxn != null &amp;&amp; cnxn.getQueuedReadableBytes() == 0 &amp;&amp; cnxn.readIssuedAfterReadComplete == 0) {</span>
<span class="nc" id="L362">                    ctx.read();</span>
<span class="nc" id="L363">                    LOG.debug(&quot;Issued a read since we do not have anything to consume after channelReadComplete&quot;);</span>
                }
            }

<span class="nc" id="L367">            ctx.fireChannelReadComplete();</span>
<span class="nc" id="L368">        }</span>

        // Use a single listener instance to reduce GC
        // Note: this listener is only added when LOG.isTraceEnabled() is true,
        // so it should not do any work other than trace logging.
<span class="nc" id="L373">        private final GenericFutureListener&lt;Future&lt;Void&gt;&gt; onWriteCompletedTracer = (f) -&gt; {</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L375">                LOG.trace(&quot;write success: {}&quot;, f.isSuccess());</span>
            }
<span class="nc" id="L377">        };</span>

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
<span class="nc bnc" id="L381" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L382">                promise.addListener(onWriteCompletedTracer);</span>
            }
<span class="nc" id="L384">            super.write(ctx, msg, promise);</span>
<span class="nc" id="L385">        }</span>

    }

    final class CertificateVerifier implements GenericFutureListener&lt;Future&lt;Channel&gt;&gt; {

        private final SslHandler sslHandler;
        private final NettyServerCnxn cnxn;

<span class="nc" id="L394">        CertificateVerifier(SslHandler sslHandler, NettyServerCnxn cnxn) {</span>
<span class="nc" id="L395">            this.sslHandler = sslHandler;</span>
<span class="nc" id="L396">            this.cnxn = cnxn;</span>
<span class="nc" id="L397">        }</span>

        /**
         * Only allow the connection to stay open if certificate passes auth
         */
        public void operationComplete(Future&lt;Channel&gt; future) {
<span class="nc" id="L403">            updateHandshakeCountIfStarted(cnxn);</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (future.isSuccess()) {</span>
<span class="nc" id="L406">                LOG.debug(&quot;Successful handshake with session 0x{}&quot;, Long.toHexString(cnxn.getSessionId()));</span>
<span class="nc" id="L407">                SSLEngine eng = sslHandler.engine();</span>
                // Don't try to verify certificate if we didn't ask client to present one
<span class="nc bnc" id="L409" title="All 4 branches missed.">                if (eng.getNeedClientAuth() || eng.getWantClientAuth()) {</span>
<span class="nc" id="L410">                    SSLSession session = eng.getSession();</span>
                    try {
<span class="nc" id="L412">                        cnxn.setClientCertificateChain(session.getPeerCertificates());</span>
<span class="nc" id="L413">                    } catch (SSLPeerUnverifiedException e) {</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">                        if (eng.getNeedClientAuth()) {</span>
                            // Certificate was requested but not present
<span class="nc" id="L416">                            LOG.error(&quot;Error getting peer certificates&quot;, e);</span>
<span class="nc" id="L417">                            cnxn.close();</span>
<span class="nc" id="L418">                            return;</span>
                        } else {
                            // Certificate was requested but was optional
                            // TODO: what auth info should we set on the connection?
<span class="nc" id="L422">                            final Channel futureChannel = future.getNow();</span>
<span class="nc" id="L423">                            allChannels.add(Objects.requireNonNull(futureChannel));</span>
<span class="nc" id="L424">                            addCnxn(cnxn);</span>
<span class="nc" id="L425">                            return;</span>
                        }
<span class="nc" id="L427">                    } catch (Exception e) {</span>
<span class="nc" id="L428">                        LOG.error(&quot;Error getting peer certificates&quot;, e);</span>
<span class="nc" id="L429">                        cnxn.close();</span>
<span class="nc" id="L430">                        return;</span>
<span class="nc" id="L431">                    }</span>

<span class="nc" id="L433">                    String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), &quot;x509&quot;);</span>

<span class="nc" id="L435">                    X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);</span>

<span class="nc bnc" id="L437" title="All 2 branches missed.">                    if (authProvider == null) {</span>
<span class="nc" id="L438">                        LOG.error(&quot;X509 Auth provider not found: {}&quot;, authProviderProp);</span>
<span class="nc" id="L439">                        cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);</span>
<span class="nc" id="L440">                        return;</span>
                    }

<span class="nc" id="L443">                    KeeperException.Code code = authProvider.handleAuthentication(cnxn, null);</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                    if (KeeperException.Code.OK != code) {</span>
<span class="nc" id="L445">                        zkServer.serverStats().incrementAuthFailedCount();</span>
<span class="nc" id="L446">                        LOG.error(&quot;Authentication failed for session 0x{}&quot;, Long.toHexString(cnxn.getSessionId()));</span>
<span class="nc" id="L447">                        cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);</span>
<span class="nc" id="L448">                        return;</span>
                    }
                }

<span class="nc" id="L452">                final Channel futureChannel = future.getNow();</span>
<span class="nc" id="L453">                allChannels.add(Objects.requireNonNull(futureChannel));</span>
<span class="nc" id="L454">                addCnxn(cnxn);</span>
<span class="nc" id="L455">            } else {</span>
<span class="nc" id="L456">                zkServer.serverStats().incrementAuthFailedCount();</span>
<span class="nc" id="L457">                LOG.error(&quot;Unsuccessful handshake with session 0x{}&quot;, Long.toHexString(cnxn.getSessionId()));</span>
<span class="nc" id="L458">                ServerMetrics.getMetrics().UNSUCCESSFUL_HANDSHAKE.add(1);</span>
<span class="nc" id="L459">                cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);</span>
            }
<span class="nc" id="L461">        }</span>

    }

    @Sharable
<span class="nc" id="L466">    static class ReadIssuedTrackingHandler extends ChannelDuplexHandler {</span>

        @Override
        public void read(ChannelHandlerContext ctx) throws Exception {
<span class="nc" id="L470">            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (cnxn != null) {</span>
<span class="nc" id="L472">                cnxn.readIssuedAfterReadComplete++;</span>
            }

<span class="nc" id="L475">            ctx.read();</span>
<span class="nc" id="L476">        }</span>

        @Override
        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
<span class="nc" id="L480">            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (cnxn != null) {</span>
<span class="nc" id="L482">                cnxn.readIssuedAfterReadComplete = 0;</span>
            }

<span class="nc" id="L485">            ctx.fireChannelReadComplete();</span>
<span class="nc" id="L486">        }</span>

    }

<span class="nc" id="L490">    CnxnChannelHandler channelHandler = new CnxnChannelHandler();</span>
<span class="nc" id="L491">    ReadIssuedTrackingHandler readIssuedTrackingHandler = new ReadIssuedTrackingHandler();</span>

    private ServerBootstrap configureBootstrapAllocator(ServerBootstrap bootstrap) {
<span class="nc" id="L494">        ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">        if (testAllocator != null) {</span>
<span class="nc" id="L496">            return bootstrap.option(ChannelOption.ALLOCATOR, testAllocator)</span>
<span class="nc" id="L497">                            .childOption(ChannelOption.ALLOCATOR, testAllocator);</span>
        } else {
<span class="nc" id="L499">            return bootstrap;</span>
        }
    }

<span class="nc" id="L503">    NettyServerCnxnFactory() {</span>
<span class="nc" id="L504">        x509Util = new ClientX509Util();</span>

<span class="nc" id="L506">        boolean usePortUnification = Boolean.getBoolean(PORT_UNIFICATION_KEY);</span>
<span class="nc" id="L507">        LOG.info(&quot;{}={}&quot;, PORT_UNIFICATION_KEY, usePortUnification);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (usePortUnification) {</span>
            try {
<span class="nc" id="L510">                QuorumPeerConfig.configureSSLAuth();</span>
<span class="nc" id="L511">            } catch (QuorumPeerConfig.ConfigException e) {</span>
<span class="nc" id="L512">                LOG.error(&quot;unable to set up SslAuthProvider, turning off client port unification&quot;, e);</span>
<span class="nc" id="L513">                usePortUnification = false;</span>
<span class="nc" id="L514">            }</span>
        }
<span class="nc" id="L516">        this.shouldUsePortUnification = usePortUnification;</span>

<span class="nc" id="L518">        this.advancedFlowControlEnabled = Boolean.getBoolean(NETTY_ADVANCED_FLOW_CONTROL);</span>
<span class="nc" id="L519">        LOG.info(&quot;{} = {}&quot;, NETTY_ADVANCED_FLOW_CONTROL, this.advancedFlowControlEnabled);</span>

<span class="nc" id="L521">        setOutstandingHandshakeLimit(Integer.getInteger(OUTSTANDING_HANDSHAKE_LIMIT, -1));</span>

<span class="nc" id="L523">        EventLoopGroup bossGroup = NettyUtils.newNioOrEpollEventLoopGroup(NettyUtils.getClientReachableLocalInetAddressCount());</span>
<span class="nc" id="L524">        EventLoopGroup workerGroup = NettyUtils.newNioOrEpollEventLoopGroup();</span>
<span class="nc" id="L525">        ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workerGroup)</span>
<span class="nc" id="L526">                                                         .channel(NettyUtils.nioOrEpollServerSocketChannel())</span>
                                                         // parent channel options
<span class="nc" id="L528">                                                         .option(ChannelOption.SO_REUSEADDR, true)</span>
                                                         // child channels options
<span class="nc" id="L530">                                                         .childOption(ChannelOption.TCP_NODELAY, true)</span>
<span class="nc" id="L531">                                                         .childOption(ChannelOption.SO_LINGER, -1)</span>
<span class="nc" id="L532">                                                         .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {</span>
                                                             @Override
                                                             protected void initChannel(SocketChannel ch) throws Exception {
<span class="nc" id="L535">                                                                 ChannelPipeline pipeline = ch.pipeline();</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                                                                 if (advancedFlowControlEnabled) {</span>
<span class="nc" id="L537">                                                                     pipeline.addLast(readIssuedTrackingHandler);</span>
                                                                 }
<span class="nc bnc" id="L539" title="All 2 branches missed.">                                                                 if (secure) {</span>
<span class="nc" id="L540">                                                                     initSSL(pipeline, false);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                                                                 } else if (shouldUsePortUnification) {</span>
<span class="nc" id="L542">                                                                     initSSL(pipeline, true);</span>
                                                                 }
<span class="nc" id="L544">                                                                 pipeline.addLast(&quot;servercnxnfactory&quot;, channelHandler);</span>
<span class="nc" id="L545">                                                             }</span>
                                                         });
<span class="nc" id="L547">        this.bootstrap = configureBootstrapAllocator(bootstrap);</span>
<span class="nc" id="L548">        this.bootstrap.validate();</span>
<span class="nc" id="L549">    }</span>

    private synchronized void initSSL(ChannelPipeline p, boolean supportPlaintext) throws X509Exception, KeyManagementException, NoSuchAlgorithmException {
<span class="nc" id="L552">        String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty());</span>
        SslContext nettySslContext;
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (authProviderProp == null) {</span>
<span class="nc" id="L555">            SSLContextAndOptions sslContextAndOptions = x509Util.getDefaultSSLContextAndOptions();</span>
<span class="nc" id="L556">            nettySslContext = sslContextAndOptions.createNettyJdkSslContext(sslContextAndOptions.getSSLContext(), false);</span>
<span class="nc" id="L557">        } else {</span>
<span class="nc" id="L558">            SSLContext sslContext = SSLContext.getInstance(ClientX509Util.DEFAULT_PROTOCOL);</span>
<span class="nc" id="L559">            X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(</span>
<span class="nc" id="L560">                System.getProperty(x509Util.getSslAuthProviderProperty(), &quot;x509&quot;));</span>

<span class="nc bnc" id="L562" title="All 2 branches missed.">            if (authProvider == null) {</span>
<span class="nc" id="L563">                LOG.error(&quot;Auth provider not found: {}&quot;, authProviderProp);</span>
<span class="nc" id="L564">                throw new SSLContextException(&quot;Could not create SSLContext with specified auth provider: &quot; + authProviderProp);</span>
            }

<span class="nc" id="L567">            sslContext.init(new X509KeyManager[]{authProvider.getKeyManager()}, new X509TrustManager[]{authProvider.getTrustManager()}, null);</span>
<span class="nc" id="L568">            nettySslContext = x509Util.getDefaultSSLContextAndOptions().createNettyJdkSslContext(sslContext, false);</span>
        }

<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (supportPlaintext) {</span>
<span class="nc" id="L572">            p.addLast(&quot;ssl&quot;, new DualModeSslHandler(nettySslContext));</span>
<span class="nc" id="L573">            LOG.debug(&quot;dual mode SSL handler added for channel: {}&quot;, p.channel());</span>
        } else {
<span class="nc" id="L575">            p.addLast(&quot;ssl&quot;, nettySslContext.newHandler(p.channel().alloc()));</span>
<span class="nc" id="L576">            LOG.debug(&quot;SSL handler added for channel: {}&quot;, p.channel());</span>
        }
<span class="nc" id="L578">    }</span>

    @Override
    public void closeAll(ServerCnxn.DisconnectReason reason) {
<span class="nc" id="L582">        LOG.debug(&quot;closeAll()&quot;);</span>

        // clear all the connections on which we are selecting
<span class="nc" id="L585">        int length = cnxns.size();</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">        for (ServerCnxn cnxn : cnxns) {</span>
            try {
                // This will remove the cnxn from cnxns
<span class="nc" id="L589">                cnxn.close(reason);</span>
<span class="nc" id="L590">            } catch (Exception e) {</span>
<span class="nc" id="L591">                LOG.warn(&quot;Ignoring exception closing cnxn sessionid 0x{}&quot;, Long.toHexString(cnxn.getSessionId()), e);</span>
<span class="nc" id="L592">            }</span>
<span class="nc" id="L593">        }</span>

<span class="nc" id="L595">        LOG.debug(&quot;allChannels size: {} cnxns size: {}&quot;, allChannels.size(), length);</span>
<span class="nc" id="L596">    }</span>

    @Override
    public void configure(InetSocketAddress addr, int maxClientCnxns, int backlog, boolean secure) throws IOException {
<span class="nc" id="L600">        configureSaslLogin();</span>
<span class="nc" id="L601">        initMaxCnxns();</span>
<span class="nc" id="L602">        localAddress = addr;</span>
<span class="nc" id="L603">        this.maxClientCnxns = maxClientCnxns;</span>
<span class="nc" id="L604">        this.secure = secure;</span>
<span class="nc" id="L605">        this.listenBacklog = backlog;</span>
<span class="nc" id="L606">        LOG.info(&quot;configure {} secure: {} on addr {}&quot;, this, secure, addr);</span>
<span class="nc" id="L607">    }</span>

    /** {@inheritDoc} */
    public int getMaxClientCnxnsPerHost() {
<span class="nc" id="L611">        return maxClientCnxns;</span>
    }

    /** {@inheritDoc} */
    public void setMaxClientCnxnsPerHost(int max) {
<span class="nc" id="L616">        maxClientCnxns = max;</span>
<span class="nc" id="L617">    }</span>

    /** {@inheritDoc} */
    public int getSocketListenBacklog() {
<span class="nc" id="L621">        return listenBacklog;</span>
    }

    @Override
    public int getLocalPort() {
<span class="nc" id="L626">        return localAddress.getPort();</span>
    }

    private boolean killed; // use synchronized(this) to access
    @Override
    public void join() throws InterruptedException {
<span class="nc" id="L632">        synchronized (this) {</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">            while (!killed) {</span>
<span class="nc" id="L634">                wait();</span>
            }
<span class="nc" id="L636">        }</span>
<span class="nc" id="L637">    }</span>

    @Override
    public void shutdown() {
<span class="nc" id="L641">        synchronized (this) {</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (killed) {</span>
<span class="nc" id="L643">                LOG.info(&quot;already shutdown {}&quot;, localAddress);</span>
<span class="nc" id="L644">                return;</span>
            }
<span class="nc" id="L646">        }</span>
<span class="nc" id="L647">        LOG.info(&quot;shutdown called {}&quot;, localAddress);</span>

<span class="nc" id="L649">        x509Util.close();</span>

<span class="nc bnc" id="L651" title="All 2 branches missed.">        if (login != null) {</span>
<span class="nc" id="L652">            login.shutdown();</span>
        }

<span class="nc" id="L655">        final EventLoopGroup bossGroup = bootstrap.config().group();</span>
<span class="nc" id="L656">        final EventLoopGroup workerGroup = bootstrap.config().childGroup();</span>
        // null if factory never started
<span class="nc bnc" id="L658" title="All 2 branches missed.">        if (parentChannel != null) {</span>
<span class="nc" id="L659">            ChannelFuture parentCloseFuture = parentChannel.close();</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">            if (bossGroup != null) {</span>
<span class="nc" id="L661">                parentCloseFuture.addListener(future -&gt; {</span>
<span class="nc" id="L662">                    bossGroup.shutdownGracefully();</span>
<span class="nc" id="L663">                });</span>
            }
<span class="nc" id="L665">            closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);</span>
<span class="nc" id="L666">            ChannelGroupFuture allChannelsCloseFuture = allChannels.close();</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (workerGroup != null) {</span>
<span class="nc" id="L668">                allChannelsCloseFuture.addListener(future -&gt; {</span>
<span class="nc" id="L669">                    workerGroup.shutdownGracefully();</span>
<span class="nc" id="L670">                });</span>
            }
<span class="nc" id="L672">        } else {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">            if (bossGroup != null) {</span>
<span class="nc" id="L674">                bossGroup.shutdownGracefully();</span>
            }
<span class="nc bnc" id="L676" title="All 2 branches missed.">            if (workerGroup != null) {</span>
<span class="nc" id="L677">                workerGroup.shutdownGracefully();</span>
            }
        }

<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (zkServer != null) {</span>
<span class="nc" id="L682">            zkServer.shutdown();</span>
        }
<span class="nc" id="L684">        synchronized (this) {</span>
<span class="nc" id="L685">            killed = true;</span>
<span class="nc" id="L686">            notifyAll();</span>
<span class="nc" id="L687">        }</span>
<span class="nc" id="L688">    }</span>

    @Override
    public void start() {
<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (listenBacklog != -1) {</span>
<span class="nc" id="L693">            bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog);</span>
        }
<span class="nc" id="L695">        LOG.info(&quot;binding to port {}&quot;, localAddress);</span>
<span class="nc" id="L696">        parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();</span>
        // Port changes after bind() if the original port was 0, update
        // localAddress to get the real port.
<span class="nc" id="L699">        localAddress = (InetSocketAddress) parentChannel.localAddress();</span>
<span class="nc" id="L700">        LOG.info(&quot;bound to port {}&quot;, getLocalPort());</span>
<span class="nc" id="L701">    }</span>

    public void reconfigure(InetSocketAddress addr) {
<span class="nc" id="L704">        LOG.info(&quot;binding to port {}, {}&quot;, addr, localAddress);</span>
<span class="nc bnc" id="L705" title="All 4 branches missed.">        if (addr != null &amp;&amp; localAddress != null) {</span>
<span class="nc bnc" id="L706" title="All 4 branches missed.">            if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress()</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                    &amp;&amp; localAddress.getAddress().isAnyLocalAddress()</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">                    &amp;&amp; addr.getPort() == localAddress.getPort())) {</span>
<span class="nc" id="L709">                 LOG.info(&quot;address is the same, skip rebinding&quot;);</span>
<span class="nc" id="L710">                 return;</span>
            }
        }

<span class="nc" id="L714">        Channel oldChannel = parentChannel;</span>
        try {
<span class="nc" id="L716">            parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();</span>
            // Port changes after bind() if the original port was 0, update
            // localAddress to get the real port.
<span class="nc" id="L719">            localAddress = (InetSocketAddress) parentChannel.localAddress();</span>
<span class="nc" id="L720">            LOG.info(&quot;bound to port {}&quot;, getLocalPort());</span>
<span class="nc" id="L721">        } catch (Exception e) {</span>
<span class="nc" id="L722">            LOG.error(&quot;Error while reconfiguring&quot;, e);</span>
        } finally {
<span class="nc" id="L724">            oldChannel.close();</span>
        }
<span class="nc" id="L726">    }</span>

    @Override
    public void startup(ZooKeeperServer zks, boolean startServer) throws IOException, InterruptedException {
<span class="nc" id="L730">        start();</span>
<span class="nc" id="L731">        setZooKeeperServer(zks);</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">        if (startServer) {</span>
<span class="nc" id="L733">            zks.startdata();</span>
<span class="nc" id="L734">            zks.startup();</span>
        }
<span class="nc" id="L736">    }</span>

    @Override
    public Iterable&lt;ServerCnxn&gt; getConnections() {
<span class="nc" id="L740">        return cnxns;</span>
    }

    @Override
    public InetSocketAddress getLocalAddress() {
<span class="nc" id="L745">        return localAddress;</span>
    }

    private void addCnxn(final NettyServerCnxn cnxn) {
<span class="nc" id="L749">        cnxns.add(cnxn);</span>
<span class="nc" id="L750">        InetAddress addr = ((InetSocketAddress) cnxn.getChannel().remoteAddress()).getAddress();</span>

<span class="nc" id="L752">        ipMap.compute(addr, (a, cnxnCount) -&gt; {</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">            if (cnxnCount == null) {</span>
<span class="nc" id="L754">                cnxnCount = new AtomicInteger();</span>
            }
<span class="nc" id="L756">            cnxnCount.incrementAndGet();</span>
<span class="nc" id="L757">            return cnxnCount;</span>
        });
<span class="nc" id="L759">    }</span>

    void removeCnxnFromIpMap(NettyServerCnxn cnxn, InetAddress remoteAddress) {
<span class="nc" id="L762">        ipMap.compute(remoteAddress, (addr, cnxnCount) -&gt; {</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">            if (cnxnCount == null) {</span>
<span class="nc" id="L764">                LOG.error(&quot;Unexpected remote address {} when removing cnxn {}&quot;, remoteAddress, cnxn);</span>
<span class="nc" id="L765">                return null;</span>
            }
<span class="nc" id="L767">            final int newValue = cnxnCount.decrementAndGet();</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">            return newValue == 0 ? null : cnxnCount;</span>
        });
<span class="nc" id="L770">    }</span>

    private int getClientCnxnCount(final InetAddress addr) {
<span class="nc" id="L773">        final AtomicInteger count = ipMap.get(addr);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">        return count == null ? 0 : count.get();</span>
    }

    @Override
    public void resetAllConnectionStats() {
        // No need to synchronize since cnxns is backed by a ConcurrentHashMap
<span class="nc bnc" id="L780" title="All 2 branches missed.">        for (ServerCnxn c : cnxns) {</span>
<span class="nc" id="L781">            c.resetStats();</span>
<span class="nc" id="L782">        }</span>
<span class="nc" id="L783">    }</span>

    @Override
    public Iterable&lt;Map&lt;String, Object&gt;&gt; getAllConnectionInfo(boolean brief) {
<span class="nc" id="L787">        Set&lt;Map&lt;String, Object&gt;&gt; info = new HashSet&lt;Map&lt;String, Object&gt;&gt;();</span>
        // No need to synchronize since cnxns is backed by a ConcurrentHashMap
<span class="nc bnc" id="L789" title="All 2 branches missed.">        for (ServerCnxn c : cnxns) {</span>
<span class="nc" id="L790">            info.add(c.getConnectionInfo(brief));</span>
<span class="nc" id="L791">        }</span>
<span class="nc" id="L792">        return info;</span>
    }

    /**
     * Sets the test ByteBufAllocator. This allocator will be used by all
     * future instances of this class.
     * It is not recommended to use this method outside of testing.
     * @param allocator the ByteBufAllocator to use for all netty buffer
     *                  allocations.
     */
    static void setTestAllocator(ByteBufAllocator allocator) {
<span class="nc" id="L803">        TEST_ALLOCATOR.set(allocator);</span>
<span class="nc" id="L804">    }</span>

    /**
     * Clears the test ByteBufAllocator. The default allocator will be used
     * by all future instances of this class.
     * It is not recommended to use this method outside of testing.
     */
    static void clearTestAllocator() {
<span class="nc" id="L812">        TEST_ALLOCATOR.set(null);</span>
<span class="nc" id="L813">    }</span>

    // VisibleForTest
    public void setAdvancedFlowControlEnabled(boolean advancedFlowControlEnabled) {
<span class="nc" id="L817">        this.advancedFlowControlEnabled = advancedFlowControlEnabled;</span>
<span class="nc" id="L818">    }</span>

    // VisibleForTest
    public void setSecure(boolean secure) {
<span class="nc" id="L822">        this.secure = secure;</span>
<span class="nc" id="L823">    }</span>

    // VisibleForTest
    public Channel getParentChannel() {
<span class="nc" id="L827">        return parentChannel;</span>
    }

    public int getOutstandingHandshakeNum() {
<span class="nc" id="L831">        return outstandingHandshake.get();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>