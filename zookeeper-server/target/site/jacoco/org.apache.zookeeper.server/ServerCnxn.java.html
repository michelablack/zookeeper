<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ServerCnxn.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">ServerCnxn.java</span></div><h1>ServerCnxn.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import org.apache.jute.BinaryOutputArchive;
import org.apache.jute.Record;
import org.apache.zookeeper.Quotas;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.OpCode;
import org.apache.zookeeper.data.Id;
import org.apache.zookeeper.data.Stat;
import org.apache.zookeeper.metrics.Counter;
import org.apache.zookeeper.proto.ReplyHeader;
import org.apache.zookeeper.proto.RequestHeader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Interface to a Server connection - represents a connection from a client
 * to the server.
 */
public abstract class ServerCnxn implements Stats, Watcher {

    // This is just an arbitrary object to represent requests issued by
    // (aka owned by) this class
<span class="nc" id="L60">    public static final Object me = new Object();</span>
<span class="nc" id="L61">    private static final Logger LOG = LoggerFactory.getLogger(ServerCnxn.class);</span>

<span class="nc" id="L63">    private Set&lt;Id&gt; authInfo = Collections.newSetFromMap(new ConcurrentHashMap&lt;Id, Boolean&gt;());</span>

<span class="nc" id="L65">    private static final byte[] fourBytes = new byte[4];</span>

    /**
     * If the client is of old version, we don't send r-o mode info to it.
     * The reason is that if we would, old C client doesn't read it, which
     * results in TCP RST packet, i.e. &quot;connection reset by peer&quot;.
     */
<span class="nc" id="L72">    boolean isOldClient = true;</span>

<span class="nc" id="L74">    AtomicLong outstandingCount = new AtomicLong();</span>

    /** The ZooKeeperServer for this connection. May be null if the server
     * is not currently serving requests (for example if the server is not
     * an active quorum participant.
     */
    final ZooKeeperServer zkServer;

<span class="nc" id="L82">    public enum DisconnectReason {</span>
<span class="nc" id="L83">        UNKNOWN(&quot;unknown&quot;),</span>
<span class="nc" id="L84">        SERVER_SHUTDOWN(&quot;server_shutdown&quot;),</span>
<span class="nc" id="L85">        CLOSE_ALL_CONNECTIONS_FORCED(&quot;close_all_connections_forced&quot;),</span>
<span class="nc" id="L86">        CONNECTION_CLOSE_FORCED(&quot;connection_close_forced&quot;),</span>
<span class="nc" id="L87">        CONNECTION_EXPIRED(&quot;connection_expired&quot;),</span>
<span class="nc" id="L88">        CLIENT_CLOSED_CONNECTION(&quot;client_closed_connection&quot;),</span>
<span class="nc" id="L89">        CLIENT_CLOSED_SESSION(&quot;client_closed_session&quot;),</span>
<span class="nc" id="L90">        UNABLE_TO_READ_FROM_CLIENT(&quot;unable_to_read_from_client&quot;),</span>
<span class="nc" id="L91">        NOT_READ_ONLY_CLIENT(&quot;not_read_only_client&quot;),</span>
<span class="nc" id="L92">        CLIENT_ZXID_AHEAD(&quot;client_zxid_ahead&quot;),</span>
<span class="nc" id="L93">        INFO_PROBE(&quot;info_probe&quot;),</span>
<span class="nc" id="L94">        CLIENT_RECONNECT(&quot;client_reconnect&quot;),</span>
<span class="nc" id="L95">        CANCELLED_KEY_EXCEPTION(&quot;cancelled_key_exception&quot;),</span>
<span class="nc" id="L96">        IO_EXCEPTION(&quot;io_exception&quot;),</span>
<span class="nc" id="L97">        IO_EXCEPTION_IN_SESSION_INIT(&quot;io_exception_in_session_init&quot;),</span>
<span class="nc" id="L98">        BUFFER_UNDERFLOW_EXCEPTION(&quot;buffer_underflow_exception&quot;),</span>
<span class="nc" id="L99">        SASL_AUTH_FAILURE(&quot;sasl_auth_failure&quot;),</span>
<span class="nc" id="L100">        RESET_COMMAND(&quot;reset_command&quot;),</span>
<span class="nc" id="L101">        CLOSE_CONNECTION_COMMAND(&quot;close_connection_command&quot;),</span>
<span class="nc" id="L102">        CLEAN_UP(&quot;clean_up&quot;),</span>
<span class="nc" id="L103">        CONNECTION_MODE_CHANGED(&quot;connection_mode_changed&quot;),</span>
<span class="nc" id="L104">        RENEW_GLOBAL_SESSION_IN_RO_MODE(&quot;renew a global session in readonly mode&quot;),</span>
        // Below reasons are NettyServerCnxnFactory only
<span class="nc" id="L106">        CHANNEL_DISCONNECTED(&quot;channel disconnected&quot;),</span>
<span class="nc" id="L107">        CHANNEL_CLOSED_EXCEPTION(&quot;channel_closed_exception&quot;),</span>
<span class="nc" id="L108">        AUTH_PROVIDER_NOT_FOUND(&quot;auth provider not found&quot;),</span>
<span class="nc" id="L109">        FAILED_HANDSHAKE(&quot;Unsuccessful handshake&quot;),</span>
<span class="nc" id="L110">        CLIENT_RATE_LIMIT(&quot;Client hits rate limiting threshold&quot;),</span>
<span class="nc" id="L111">        CLIENT_CNX_LIMIT(&quot;Client hits connection limiting threshold&quot;);</span>

        String disconnectReason;

<span class="nc" id="L115">        DisconnectReason(String reason) {</span>
<span class="nc" id="L116">            this.disconnectReason = reason;</span>
<span class="nc" id="L117">        }</span>

        public String toDisconnectReasonString() {
<span class="nc" id="L120">            return disconnectReason;</span>
        }
    }

<span class="nc" id="L124">    public ServerCnxn(final ZooKeeperServer zkServer) {</span>
<span class="nc" id="L125">        this.zkServer = zkServer;</span>
<span class="nc" id="L126">    }</span>

    /**
     * Flag that indicates that this connection is known to be closed/closing
     * and from which we can optionally ignore outstanding requests as part
     * of request throttling. This flag may be false when a connection is
     * actually closed (false negative), but should never be true with
     * a connection is still alive (false positive).
     */
<span class="nc" id="L135">    private volatile boolean stale = false;</span>

    /**
     * Flag that indicates that a request for this connection was previously
     * dropped as part of request throttling and therefore all future requests
     * must also be dropped to ensure ordering guarantees.
     */
<span class="nc" id="L142">    private volatile boolean invalid = false;</span>

    abstract int getSessionTimeout();

    public void incrOutstandingAndCheckThrottle(RequestHeader h) {
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (h.getXid() &lt;= 0) {</span>
<span class="nc" id="L148">            return;</span>
        }
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (zkServer.shouldThrottle(outstandingCount.incrementAndGet())) {</span>
<span class="nc" id="L151">            disableRecv(false);</span>
        }
<span class="nc" id="L153">    }</span>

    // will be called from zkServer.processPacket
    public void decrOutstandingAndCheckThrottle(ReplyHeader h) {
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (h.getXid() &lt;= 0) {</span>
<span class="nc" id="L158">            return;</span>
        }
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (!zkServer.shouldThrottle(outstandingCount.decrementAndGet())) {</span>
<span class="nc" id="L161">            enableRecv();</span>
        }
<span class="nc" id="L163">    }</span>

    public abstract void close(DisconnectReason reason);

    /**
     * Serializes a ZooKeeper response and enqueues it for sending.
     *
     * Serializes client response parts and enqueues them into outgoing queue.
     *
     * If both cache key and last modified zxid are provided, the serialized
     * response is ca—Åhed under the provided key, the last modified zxid is
     * stored along with the value. A cache entry is invalidated if the
     * provided last modified zxid is more recent than the stored one.
     *
     * Attention: this function is not thread safe, due to caching not being
     * thread safe.
     *
     * @param h reply header
     * @param r reply payload, can be null
     * @param tag Jute serialization tag, can be null
     * @param cacheKey Key for caching the serialized payload. A null value prevents caching.
     * @param stat Stat information for the the reply payload, used for cache invalidation.
     *             A value of 0 prevents caching.
     * @param opCode The op code appertains to the corresponding request of the response,
     *               used to decide which cache (e.g. read response cache,
     *               list of children response cache, ...) object to look up to when applicable.
     */
    public abstract int sendResponse(ReplyHeader h, Record r, String tag,
                                      String cacheKey, Stat stat, int opCode) throws IOException;

    public int sendResponse(ReplyHeader h, Record r, String tag) throws IOException {
<span class="nc" id="L194">        return sendResponse(h, r, tag, null, null, -1);</span>
    }

    protected byte[] serializeRecord(Record record) throws IOException {
<span class="nc" id="L198">        ByteArrayOutputStream baos = new ByteArrayOutputStream(ZooKeeperServer.intBufferStartingSizeBytes);</span>
<span class="nc" id="L199">        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);</span>
<span class="nc" id="L200">        bos.writeRecord(record, null);</span>
<span class="nc" id="L201">        return baos.toByteArray();</span>
    }

    protected ByteBuffer[] serialize(ReplyHeader h, Record r, String tag,
                                     String cacheKey, Stat stat, int opCode) throws IOException {
<span class="nc" id="L206">        byte[] header = serializeRecord(h);</span>
<span class="nc" id="L207">        byte[] data = null;</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (r != null) {</span>
<span class="nc" id="L209">            ResponseCache cache = null;</span>
<span class="nc" id="L210">            Counter cacheHit = null, cacheMiss = null;</span>
<span class="nc bnc" id="L211" title="All 3 branches missed.">            switch (opCode) {</span>
                case OpCode.getData : {
<span class="nc" id="L213">                    cache = zkServer.getReadResponseCache();</span>
<span class="nc" id="L214">                    cacheHit = ServerMetrics.getMetrics().RESPONSE_PACKET_CACHE_HITS;</span>
<span class="nc" id="L215">                    cacheMiss = ServerMetrics.getMetrics().RESPONSE_PACKET_CACHE_MISSING;</span>
<span class="nc" id="L216">                    break;</span>
                }
                case OpCode.getChildren2 : {
<span class="nc" id="L219">                    cache = zkServer.getGetChildrenResponseCache();</span>
<span class="nc" id="L220">                    cacheHit = ServerMetrics.getMetrics().RESPONSE_PACKET_GET_CHILDREN_CACHE_HITS;</span>
<span class="nc" id="L221">                    cacheMiss = ServerMetrics.getMetrics().RESPONSE_PACKET_GET_CHILDREN_CACHE_MISSING;</span>
<span class="nc" id="L222">                    break;</span>
                }
                default:
                    // op codes where response cache is not supported.
            }

<span class="nc bnc" id="L228" title="All 8 branches missed.">            if (cache != null &amp;&amp; stat != null &amp;&amp; cacheKey != null &amp;&amp; !cacheKey.endsWith(Quotas.statNode)) {</span>
                // Use cache to get serialized data.
                //
                // NB: Tag is ignored both during cache lookup and serialization,
                // since is is not used in read responses, which are being cached.
<span class="nc" id="L233">                data = cache.get(cacheKey, stat);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                if (data == null) {</span>
                    // Cache miss, serialize the response and put it in cache.
<span class="nc" id="L236">                    data = serializeRecord(r);</span>
<span class="nc" id="L237">                    cache.put(cacheKey, data, stat);</span>
<span class="nc" id="L238">                    cacheMiss.add(1);</span>
                } else {
<span class="nc" id="L240">                    cacheHit.add(1);</span>
                }
            } else {
<span class="nc" id="L243">                data = serializeRecord(r);</span>
            }
        }
<span class="nc bnc" id="L246" title="All 2 branches missed.">        int dataLength = data == null ? 0 : data.length;</span>
<span class="nc" id="L247">        int packetLength = header.length + dataLength;</span>
<span class="nc" id="L248">        ServerStats serverStats = serverStats();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (serverStats != null) {</span>
<span class="nc" id="L250">            serverStats.updateClientResponseSize(packetLength);</span>
        }
<span class="nc" id="L252">        ByteBuffer lengthBuffer = ByteBuffer.allocate(4).putInt(packetLength);</span>
<span class="nc" id="L253">        lengthBuffer.rewind();</span>

<span class="nc bnc" id="L255" title="All 2 branches missed.">        int bufferLen = data != null ? 3 : 2;</span>
<span class="nc" id="L256">        ByteBuffer[] buffers = new ByteBuffer[bufferLen];</span>

<span class="nc" id="L258">        buffers[0] = lengthBuffer;</span>
<span class="nc" id="L259">        buffers[1] = ByteBuffer.wrap(header);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (data != null) {</span>
<span class="nc" id="L261">            buffers[2] = ByteBuffer.wrap(data);</span>
        }
<span class="nc" id="L263">        return buffers;</span>
    }

    /* notify the client the session is closing and close/cleanup socket */
    public abstract void sendCloseSession();

    public abstract void process(WatchedEvent event);

    public abstract long getSessionId();

    abstract void setSessionId(long sessionId);

    /** auth info for the cnxn, returns an unmodifyable list */
    public List&lt;Id&gt; getAuthInfo() {
<span class="nc" id="L277">        return Collections.unmodifiableList(new ArrayList&lt;&gt;(authInfo));</span>
    }

    public void addAuthInfo(Id id) {
<span class="nc" id="L281">        authInfo.add(id);</span>
<span class="nc" id="L282">    }</span>

    public boolean removeAuthInfo(Id id) {
<span class="nc" id="L285">        return authInfo.remove(id);</span>
    }

    abstract void sendBuffer(ByteBuffer... buffers);

    abstract void enableRecv();

    void disableRecv() {
<span class="nc" id="L293">        disableRecv(true);</span>
<span class="nc" id="L294">    }</span>

    abstract void disableRecv(boolean waitDisableRecv);

    abstract void setSessionTimeout(int sessionTimeout);

<span class="nc" id="L300">    protected ZooKeeperSaslServer zooKeeperSaslServer = null;</span>

    public static class CloseRequestException extends IOException {

        private static final long serialVersionUID = -7854505709816442681L;
        private DisconnectReason reason;

        public CloseRequestException(String msg, DisconnectReason reason) {
<span class="nc" id="L308">            super(msg);</span>
<span class="nc" id="L309">            this.reason = reason;</span>
<span class="nc" id="L310">        }</span>
        public DisconnectReason getReason() {
<span class="nc" id="L312">            return reason;</span>
        }

    }

    protected static class EndOfStreamException extends IOException {

        private static final long serialVersionUID = -8255690282104294178L;
        private DisconnectReason reason;

        public EndOfStreamException(String msg, DisconnectReason reason) {
<span class="nc" id="L323">            super(msg);</span>
<span class="nc" id="L324">            this.reason = reason;</span>
<span class="nc" id="L325">        }</span>

        public String toString() {
<span class="nc" id="L328">            return &quot;EndOfStreamException: &quot; + getMessage();</span>
        }
        public DisconnectReason getReason() {
<span class="nc" id="L331">            return reason;</span>
        }

    }

    public boolean isStale() {
<span class="nc" id="L337">        return stale;</span>
    }

    public void setStale() {
<span class="nc" id="L341">        stale = true;</span>
<span class="nc" id="L342">    }</span>

    public boolean isInvalid() {
<span class="nc" id="L345">        return invalid;</span>
    }

    public void setInvalid() {
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (!invalid) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (!stale) {</span>
<span class="nc" id="L351">                sendCloseSession();</span>
            }
<span class="nc" id="L353">            invalid = true;</span>
        }
<span class="nc" id="L355">    }</span>

    protected void packetReceived(long bytes) {
<span class="nc" id="L358">        incrPacketsReceived();</span>
<span class="nc" id="L359">        ServerStats serverStats = serverStats();</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (serverStats != null) {</span>
<span class="nc" id="L361">            serverStats().incrementPacketsReceived();</span>
        }
<span class="nc" id="L363">        ServerMetrics.getMetrics().BYTES_RECEIVED_COUNT.add(bytes);</span>
<span class="nc" id="L364">    }</span>

    protected void packetSent() {
<span class="nc" id="L367">        incrPacketsSent();</span>
<span class="nc" id="L368">        ServerStats serverStats = serverStats();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (serverStats != null) {</span>
<span class="nc" id="L370">            serverStats.incrementPacketsSent();</span>
        }
<span class="nc" id="L372">    }</span>

    protected abstract ServerStats serverStats();

<span class="nc" id="L376">    protected final Date established = new Date();</span>

<span class="nc" id="L378">    protected final AtomicLong packetsReceived = new AtomicLong();</span>
<span class="nc" id="L379">    protected final AtomicLong packetsSent = new AtomicLong();</span>

    protected long minLatency;
    protected long maxLatency;
    protected String lastOp;
    protected long lastCxid;
    protected long lastZxid;
    protected long lastResponseTime;
    protected long lastLatency;

    protected long count;
    protected long totalLatency;
    protected long requestsProcessedCount;
<span class="nc" id="L392">    protected DisconnectReason disconnectReason = DisconnectReason.UNKNOWN;</span>

    public synchronized void resetStats() {
<span class="nc" id="L395">        disconnectReason = DisconnectReason.RESET_COMMAND;</span>
<span class="nc" id="L396">        packetsReceived.set(0);</span>
<span class="nc" id="L397">        packetsSent.set(0);</span>
<span class="nc" id="L398">        minLatency = Long.MAX_VALUE;</span>
<span class="nc" id="L399">        maxLatency = 0;</span>
<span class="nc" id="L400">        lastOp = &quot;NA&quot;;</span>
<span class="nc" id="L401">        lastCxid = -1;</span>
<span class="nc" id="L402">        lastZxid = -1;</span>
<span class="nc" id="L403">        lastResponseTime = 0;</span>
<span class="nc" id="L404">        lastLatency = 0;</span>

<span class="nc" id="L406">        count = 0;</span>
<span class="nc" id="L407">        totalLatency = 0;</span>
<span class="nc" id="L408">    }</span>

    protected long incrPacketsReceived() {
<span class="nc" id="L411">        return packetsReceived.incrementAndGet();</span>
    }

    protected long incrPacketsSent() {
<span class="nc" id="L415">        return packetsSent.incrementAndGet();</span>
    }

    protected synchronized void updateStatsForResponse(long cxid, long zxid, String op, long start, long end) {
        // don't overwrite with &quot;special&quot; xids - we're interested
        // in the clients last real operation
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (cxid &gt;= 0) {</span>
<span class="nc" id="L422">            lastCxid = cxid;</span>
        }
<span class="nc" id="L424">        lastZxid = zxid;</span>
<span class="nc" id="L425">        lastOp = op;</span>
<span class="nc" id="L426">        lastResponseTime = end;</span>
<span class="nc" id="L427">        long elapsed = end - start;</span>
<span class="nc" id="L428">        lastLatency = elapsed;</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (elapsed &lt; minLatency) {</span>
<span class="nc" id="L430">            minLatency = elapsed;</span>
        }
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (elapsed &gt; maxLatency) {</span>
<span class="nc" id="L433">            maxLatency = elapsed;</span>
        }
<span class="nc" id="L435">        count++;</span>
<span class="nc" id="L436">        totalLatency += elapsed;</span>
<span class="nc" id="L437">    }</span>

    public Date getEstablished() {
<span class="nc" id="L440">        return (Date) established.clone();</span>
    }

    public long getOutstandingRequests() {
<span class="nc" id="L444">        return outstandingCount.longValue();</span>
    }

    public long getPacketsReceived() {
<span class="nc" id="L448">        return packetsReceived.longValue();</span>
    }

    public long getPacketsSent() {
<span class="nc" id="L452">        return packetsSent.longValue();</span>
    }

    public synchronized long getMinLatency() {
<span class="nc bnc" id="L456" title="All 2 branches missed.">        return minLatency == Long.MAX_VALUE ? 0 : minLatency;</span>
    }

    public synchronized long getAvgLatency() {
<span class="nc bnc" id="L460" title="All 2 branches missed.">        return count == 0 ? 0 : totalLatency / count;</span>
    }

    public synchronized long getMaxLatency() {
<span class="nc" id="L464">        return maxLatency;</span>
    }

    public synchronized String getLastOperation() {
<span class="nc" id="L468">        return lastOp;</span>
    }

    public synchronized long getLastCxid() {
<span class="nc" id="L472">        return lastCxid;</span>
    }

    public synchronized long getLastZxid() {
<span class="nc" id="L476">        return lastZxid;</span>
    }

    public synchronized long getLastResponseTime() {
<span class="nc" id="L480">        return lastResponseTime;</span>
    }

    public synchronized long getLastLatency() {
<span class="nc" id="L484">        return lastLatency;</span>
    }

    /**
     * Prints detailed stats information for the connection.
     *
     * @see #dumpConnectionInfo(PrintWriter, boolean) for brief stats
     */
    @Override
    public String toString() {
<span class="nc" id="L494">        StringWriter sw = new StringWriter();</span>
<span class="nc" id="L495">        PrintWriter pwriter = new PrintWriter(sw);</span>
<span class="nc" id="L496">        dumpConnectionInfo(pwriter, false);</span>
<span class="nc" id="L497">        pwriter.flush();</span>
<span class="nc" id="L498">        pwriter.close();</span>
<span class="nc" id="L499">        return sw.toString();</span>
    }

    public abstract InetSocketAddress getRemoteSocketAddress();
    public abstract int getInterestOps();
    public abstract boolean isSecure();
    public abstract Certificate[] getClientCertificateChain();
    public abstract void setClientCertificateChain(Certificate[] chain);

    /**
     * Print information about the connection.
     * @param brief iff true prints brief details, otw full detail
     */
    public synchronized void dumpConnectionInfo(PrintWriter pwriter, boolean brief) {
<span class="nc" id="L513">        pwriter.print(&quot; &quot;);</span>
<span class="nc" id="L514">        pwriter.print(getRemoteSocketAddress());</span>
<span class="nc" id="L515">        pwriter.print(&quot;[&quot;);</span>
<span class="nc" id="L516">        int interestOps = getInterestOps();</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">        pwriter.print(interestOps == 0 ? &quot;0&quot; : Integer.toHexString(interestOps));</span>
<span class="nc" id="L518">        pwriter.print(&quot;](queued=&quot;);</span>
<span class="nc" id="L519">        pwriter.print(getOutstandingRequests());</span>
<span class="nc" id="L520">        pwriter.print(&quot;,recved=&quot;);</span>
<span class="nc" id="L521">        pwriter.print(getPacketsReceived());</span>
<span class="nc" id="L522">        pwriter.print(&quot;,sent=&quot;);</span>
<span class="nc" id="L523">        pwriter.print(getPacketsSent());</span>

<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (!brief) {</span>
<span class="nc" id="L526">            long sessionId = getSessionId();</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">            if (sessionId != 0) {</span>
<span class="nc" id="L528">                pwriter.print(&quot;,sid=0x&quot;);</span>
<span class="nc" id="L529">                pwriter.print(Long.toHexString(sessionId));</span>
<span class="nc" id="L530">                pwriter.print(&quot;,lop=&quot;);</span>
<span class="nc" id="L531">                pwriter.print(getLastOperation());</span>
<span class="nc" id="L532">                pwriter.print(&quot;,est=&quot;);</span>
<span class="nc" id="L533">                pwriter.print(getEstablished().getTime());</span>
<span class="nc" id="L534">                pwriter.print(&quot;,to=&quot;);</span>
<span class="nc" id="L535">                pwriter.print(getSessionTimeout());</span>
<span class="nc" id="L536">                long lastCxid = getLastCxid();</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                if (lastCxid &gt;= 0) {</span>
<span class="nc" id="L538">                    pwriter.print(&quot;,lcxid=0x&quot;);</span>
<span class="nc" id="L539">                    pwriter.print(Long.toHexString(lastCxid));</span>
                }
<span class="nc" id="L541">                pwriter.print(&quot;,lzxid=0x&quot;);</span>
<span class="nc" id="L542">                pwriter.print(Long.toHexString(getLastZxid()));</span>
<span class="nc" id="L543">                pwriter.print(&quot;,lresp=&quot;);</span>
<span class="nc" id="L544">                pwriter.print(getLastResponseTime());</span>
<span class="nc" id="L545">                pwriter.print(&quot;,llat=&quot;);</span>
<span class="nc" id="L546">                pwriter.print(getLastLatency());</span>
<span class="nc" id="L547">                pwriter.print(&quot;,minlat=&quot;);</span>
<span class="nc" id="L548">                pwriter.print(getMinLatency());</span>
<span class="nc" id="L549">                pwriter.print(&quot;,avglat=&quot;);</span>
<span class="nc" id="L550">                pwriter.print(getAvgLatency());</span>
<span class="nc" id="L551">                pwriter.print(&quot;,maxlat=&quot;);</span>
<span class="nc" id="L552">                pwriter.print(getMaxLatency());</span>
            }
        }
<span class="nc" id="L555">        pwriter.print(&quot;)&quot;);</span>
<span class="nc" id="L556">    }</span>

    public synchronized Map&lt;String, Object&gt; getConnectionInfo(boolean brief) {
<span class="nc" id="L559">        Map&lt;String, Object&gt; info = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L560">        info.put(&quot;remote_socket_address&quot;, getRemoteSocketAddress());</span>
<span class="nc" id="L561">        info.put(&quot;interest_ops&quot;, getInterestOps());</span>
<span class="nc" id="L562">        info.put(&quot;outstanding_requests&quot;, getOutstandingRequests());</span>
<span class="nc" id="L563">        info.put(&quot;packets_received&quot;, getPacketsReceived());</span>
<span class="nc" id="L564">        info.put(&quot;packets_sent&quot;, getPacketsSent());</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (!brief) {</span>
<span class="nc" id="L566">            info.put(&quot;session_id&quot;, getSessionId());</span>
<span class="nc" id="L567">            info.put(&quot;last_operation&quot;, getLastOperation());</span>
<span class="nc" id="L568">            info.put(&quot;established&quot;, getEstablished());</span>
<span class="nc" id="L569">            info.put(&quot;session_timeout&quot;, getSessionTimeout());</span>
<span class="nc" id="L570">            info.put(&quot;last_cxid&quot;, getLastCxid());</span>
<span class="nc" id="L571">            info.put(&quot;last_zxid&quot;, getLastZxid());</span>
<span class="nc" id="L572">            info.put(&quot;last_response_time&quot;, getLastResponseTime());</span>
<span class="nc" id="L573">            info.put(&quot;last_latency&quot;, getLastLatency());</span>
<span class="nc" id="L574">            info.put(&quot;min_latency&quot;, getMinLatency());</span>
<span class="nc" id="L575">            info.put(&quot;avg_latency&quot;, getAvgLatency());</span>
<span class="nc" id="L576">            info.put(&quot;max_latency&quot;, getMaxLatency());</span>
        }
<span class="nc" id="L578">        return info;</span>
    }

    /**
     * clean up the socket related to a command and also make sure we flush the
     * data before we do that
     *
     * @param pwriter
     *            the pwriter for a command socket
     */
    public void cleanupWriterSocket(PrintWriter pwriter) {
        try {
<span class="nc bnc" id="L590" title="All 2 branches missed.">            if (pwriter != null) {</span>
<span class="nc" id="L591">                pwriter.flush();</span>
<span class="nc" id="L592">                pwriter.close();</span>
            }
<span class="nc" id="L594">        } catch (Exception e) {</span>
<span class="nc" id="L595">            LOG.info(&quot;Error closing PrintWriter &quot;, e);</span>
        } finally {
            try {
<span class="nc" id="L598">                close(DisconnectReason.CLOSE_CONNECTION_COMMAND);</span>
<span class="nc" id="L599">            } catch (Exception e) {</span>
<span class="nc" id="L600">                LOG.error(&quot;Error closing a command socket &quot;, e);</span>
<span class="nc" id="L601">            }</span>
        }
<span class="nc" id="L603">    }</span>

    /**
     * @return true if the server is running, false otherwise.
     */
    public boolean isZKServerRunning() {
<span class="nc bnc" id="L609" title="All 4 branches missed.">        return zkServer != null &amp;&amp; zkServer.isRunning();</span>
    }

    /**
     * Returns the IP address or empty string.
     */
    public String getHostAddress() {
<span class="nc" id="L616">        InetSocketAddress remoteSocketAddress = getRemoteSocketAddress();</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (remoteSocketAddress == null) {</span>
<span class="nc" id="L618">            return &quot;&quot;;</span>
        }
<span class="nc" id="L620">        InetAddress address = remoteSocketAddress.getAddress();</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">        if (address == null) {</span>
<span class="nc" id="L622">            return &quot;&quot;;</span>
        }
<span class="nc" id="L624">        return address.getHostAddress();</span>
    }

    /**
     * Get session id in hexadecimal notation.
     */
    public String getSessionIdHex() {
<span class="nc" id="L631">        return &quot;0x&quot; + Long.toHexString(getSessionId());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>