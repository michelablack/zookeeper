<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClientCnxn.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper</a> &gt; <span class="el_source">ClientCnxn.java</span></div><h1>ClientCnxn.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadLocalRandom;
import javax.security.auth.login.LoginException;
import javax.security.sasl.SaslException;
import org.apache.jute.BinaryInputArchive;
import org.apache.jute.BinaryOutputArchive;
import org.apache.jute.Record;
import org.apache.zookeeper.AsyncCallback.ACLCallback;
import org.apache.zookeeper.AsyncCallback.AllChildrenNumberCallback;
import org.apache.zookeeper.AsyncCallback.Children2Callback;
import org.apache.zookeeper.AsyncCallback.ChildrenCallback;
import org.apache.zookeeper.AsyncCallback.Create2Callback;
import org.apache.zookeeper.AsyncCallback.DataCallback;
import org.apache.zookeeper.AsyncCallback.EphemeralsCallback;
import org.apache.zookeeper.AsyncCallback.MultiCallback;
import org.apache.zookeeper.AsyncCallback.StatCallback;
import org.apache.zookeeper.AsyncCallback.StringCallback;
import org.apache.zookeeper.AsyncCallback.VoidCallback;
import org.apache.zookeeper.KeeperException.Code;
import org.apache.zookeeper.OpResult.ErrorResult;
import org.apache.zookeeper.Watcher.Event;
import org.apache.zookeeper.Watcher.Event.EventType;
import org.apache.zookeeper.Watcher.Event.KeeperState;
import org.apache.zookeeper.ZooDefs.OpCode;
import org.apache.zookeeper.ZooKeeper.States;
import org.apache.zookeeper.ZooKeeper.WatchRegistration;
import org.apache.zookeeper.client.HostProvider;
import org.apache.zookeeper.client.ZKClientConfig;
import org.apache.zookeeper.client.ZooKeeperSaslClient;
import org.apache.zookeeper.common.Time;
import org.apache.zookeeper.proto.AuthPacket;
import org.apache.zookeeper.proto.ConnectRequest;
import org.apache.zookeeper.proto.Create2Response;
import org.apache.zookeeper.proto.CreateResponse;
import org.apache.zookeeper.proto.ExistsResponse;
import org.apache.zookeeper.proto.GetACLResponse;
import org.apache.zookeeper.proto.GetAllChildrenNumberResponse;
import org.apache.zookeeper.proto.GetChildren2Response;
import org.apache.zookeeper.proto.GetChildrenResponse;
import org.apache.zookeeper.proto.GetDataResponse;
import org.apache.zookeeper.proto.GetEphemeralsResponse;
import org.apache.zookeeper.proto.GetSASLRequest;
import org.apache.zookeeper.proto.ReplyHeader;
import org.apache.zookeeper.proto.RequestHeader;
import org.apache.zookeeper.proto.SetACLResponse;
import org.apache.zookeeper.proto.SetDataResponse;
import org.apache.zookeeper.proto.SetWatches;
import org.apache.zookeeper.proto.SetWatches2;
import org.apache.zookeeper.proto.WatcherEvent;
import org.apache.zookeeper.server.ByteBufferInputStream;
import org.apache.zookeeper.server.ZooKeeperThread;
import org.apache.zookeeper.server.ZooTrace;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

/**
 * This class manages the socket i/o for the client. ClientCnxn maintains a list
 * of available servers to connect to and &quot;transparently&quot; switches servers it is
 * connected to as needed.
 *
 */
@SuppressFBWarnings({&quot;EI_EXPOSE_REP&quot;, &quot;EI_EXPOSE_REP2&quot;})
public class ClientCnxn {

<span class="nc" id="L108">    private static final Logger LOG = LoggerFactory.getLogger(ClientCnxn.class);</span>

    /* ZOOKEEPER-706: If a session has a large number of watches set then
     * attempting to re-establish those watches after a connection loss may
     * fail due to the SetWatches request exceeding the server's configured
     * jute.maxBuffer value. To avoid this we instead split the watch
     * re-establishement across multiple SetWatches calls. This constant
     * controls the size of each call. It is set to 128kB to be conservative
     * with respect to the server's 1MB default for jute.maxBuffer.
     */
    private static final int SET_WATCHES_MAX_LENGTH = 128 * 1024;

    /* predefined xid's values recognized as special by the server */
    // -1 means notification(WATCHER_EVENT)
    public static final int NOTIFICATION_XID = -1;
    // -2 is the xid for pings
    public static final int PING_XID = -2;
    // -4 is the xid for AuthPacket
    public static final int AUTHPACKET_XID = -4;
    // -8 is the xid for setWatch
    public static final int SET_WATCHES_XID = -8;

    static class AuthData {

<span class="nc" id="L132">        AuthData(String scheme, byte[] data) {</span>
<span class="nc" id="L133">            this.scheme = scheme;</span>
<span class="nc" id="L134">            this.data = data;</span>
<span class="nc" id="L135">        }</span>

        String scheme;

        byte[] data;

    }

<span class="nc" id="L143">    private final CopyOnWriteArraySet&lt;AuthData&gt; authInfo = new CopyOnWriteArraySet&lt;AuthData&gt;();</span>

    /**
     * These are the packets that have been sent and are waiting for a response.
     */
<span class="nc" id="L148">    private final Queue&lt;Packet&gt; pendingQueue = new ArrayDeque&lt;&gt;();</span>

    /**
     * These are the packets that need to be sent.
     */
<span class="nc" id="L153">    private final LinkedBlockingDeque&lt;Packet&gt; outgoingQueue = new LinkedBlockingDeque&lt;Packet&gt;();</span>

    private int connectTimeout;

    /**
     * The timeout in ms the client negotiated with the server. This is the
     * &quot;real&quot; timeout, not the timeout request by the client (which may have
     * been increased/decreased by the server which applies bounds to this
     * value.
     */
    private volatile int negotiatedSessionTimeout;

    private int readTimeout;

    private final int sessionTimeout;

    private final ZKWatchManager watchManager;

    private long sessionId;

    private byte[] sessionPasswd;

    /**
     * If true, the connection is allowed to go to r-o mode. This field's value
     * is sent, besides other data, during session creation handshake. If the
     * server on the other side of the wire is partitioned it'll accept
     * read-only clients only.
     */
    private boolean readOnly;

    final String chrootPath;

    final SendThread sendThread;

    final EventThread eventThread;

    /**
     * Set to true when close is called. Latches the connection such that we
     * don't attempt to re-connect to the server if in the middle of closing the
     * connection (client sends session disconnect to server as part of close
     * operation)
     */
<span class="nc" id="L195">    private volatile boolean closing = false;</span>

    /**
     * A set of ZooKeeper hosts this client could connect to.
     */
    private final HostProvider hostProvider;

    /**
     * Is set to true when a connection to a r/w server is established for the
     * first time; never changed afterwards.
     * &lt;p&gt;
     * Is used to handle situations when client without sessionId connects to a
     * read-only server. Such client receives &quot;fake&quot; sessionId from read-only
     * server, but this sessionId is invalid for other servers. So when such
     * client finds a r/w server, it sends 0 instead of fake sessionId during
     * connection handshake and establishes new, valid session.
     * &lt;p&gt;
     * If this field is false (which implies we haven't seen r/w server before)
     * then non-zero sessionId is fake, otherwise it is valid.
     */
<span class="nc" id="L215">    volatile boolean seenRwServerBefore = false;</span>

    public ZooKeeperSaslClient zooKeeperSaslClient;

    private final ZKClientConfig clientConfig;
    /**
     * If any request's response in not received in configured requestTimeout
     * then it is assumed that the response packet is lost.
     */
    private long requestTimeout;

    ZKWatchManager getWatcherManager() {
<span class="nc" id="L227">        return watchManager;</span>
    }

    public long getSessionId() {
<span class="nc" id="L231">        return sessionId;</span>
    }

    public byte[] getSessionPasswd() {
<span class="nc" id="L235">        return sessionPasswd;</span>
    }

    public int getSessionTimeout() {
<span class="nc" id="L239">        return negotiatedSessionTimeout;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L244">        StringBuilder sb = new StringBuilder();</span>

<span class="nc" id="L246">        SocketAddress local = sendThread.getClientCnxnSocket().getLocalSocketAddress();</span>
<span class="nc" id="L247">        SocketAddress remote = sendThread.getClientCnxnSocket().getRemoteSocketAddress();</span>
<span class="nc" id="L248">        sb.append(&quot;sessionid:0x&quot;).append(Long.toHexString(getSessionId()))</span>
<span class="nc" id="L249">          .append(&quot; local:&quot;).append(local)</span>
<span class="nc" id="L250">          .append(&quot; remoteserver:&quot;).append(remote)</span>
<span class="nc" id="L251">          .append(&quot; lastZxid:&quot;).append(lastZxid)</span>
<span class="nc" id="L252">          .append(&quot; xid:&quot;).append(xid)</span>
<span class="nc" id="L253">          .append(&quot; sent:&quot;).append(sendThread.getClientCnxnSocket().getSentCount())</span>
<span class="nc" id="L254">          .append(&quot; recv:&quot;).append(sendThread.getClientCnxnSocket().getRecvCount())</span>
<span class="nc" id="L255">          .append(&quot; queuedpkts:&quot;).append(outgoingQueue.size())</span>
<span class="nc" id="L256">          .append(&quot; pendingresp:&quot;).append(pendingQueue.size())</span>
<span class="nc" id="L257">          .append(&quot; queuedevents:&quot;).append(eventThread.waitingEvents.size());</span>

<span class="nc" id="L259">        return sb.toString();</span>
    }

    /**
     * This class allows us to pass the headers and the relevant records around.
     */
    static class Packet {

        RequestHeader requestHeader;

        ReplyHeader replyHeader;

        Record request;

        Record response;

        ByteBuffer bb;

        /** Client's view of the path (may differ due to chroot) **/
        String clientPath;
        /** Servers's view of the path (may differ due to chroot) **/
        String serverPath;

        boolean finished;

        AsyncCallback cb;

        Object ctx;

        WatchRegistration watchRegistration;

        public boolean readOnly;

        WatchDeregistration watchDeregistration;

        /** Convenience ctor */
        Packet(
            RequestHeader requestHeader,
            ReplyHeader replyHeader,
            Record request,
            Record response,
            WatchRegistration watchRegistration) {
<span class="nc" id="L301">            this(requestHeader, replyHeader, request, response, watchRegistration, false);</span>
<span class="nc" id="L302">        }</span>

        Packet(
            RequestHeader requestHeader,
            ReplyHeader replyHeader,
            Record request,
            Record response,
            WatchRegistration watchRegistration,
<span class="nc" id="L310">            boolean readOnly) {</span>

<span class="nc" id="L312">            this.requestHeader = requestHeader;</span>
<span class="nc" id="L313">            this.replyHeader = replyHeader;</span>
<span class="nc" id="L314">            this.request = request;</span>
<span class="nc" id="L315">            this.response = response;</span>
<span class="nc" id="L316">            this.readOnly = readOnly;</span>
<span class="nc" id="L317">            this.watchRegistration = watchRegistration;</span>
<span class="nc" id="L318">        }</span>

        public void createBB() {
            try {
<span class="nc" id="L322">                ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L323">                BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);</span>
<span class="nc" id="L324">                boa.writeInt(-1, &quot;len&quot;); // We'll fill this in later</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">                if (requestHeader != null) {</span>
<span class="nc" id="L326">                    requestHeader.serialize(boa, &quot;header&quot;);</span>
                }
<span class="nc bnc" id="L328" title="All 2 branches missed.">                if (request instanceof ConnectRequest) {</span>
<span class="nc" id="L329">                    request.serialize(boa, &quot;connect&quot;);</span>
                    // append &quot;am-I-allowed-to-be-readonly&quot; flag
<span class="nc" id="L331">                    boa.writeBool(readOnly, &quot;readOnly&quot;);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                } else if (request != null) {</span>
<span class="nc" id="L333">                    request.serialize(boa, &quot;request&quot;);</span>
                }
<span class="nc" id="L335">                baos.close();</span>
<span class="nc" id="L336">                this.bb = ByteBuffer.wrap(baos.toByteArray());</span>
<span class="nc" id="L337">                this.bb.putInt(this.bb.capacity() - 4);</span>
<span class="nc" id="L338">                this.bb.rewind();</span>
<span class="nc" id="L339">            } catch (IOException e) {</span>
<span class="nc" id="L340">                LOG.warn(&quot;Unexpected exception&quot;, e);</span>
<span class="nc" id="L341">            }</span>
<span class="nc" id="L342">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L346">            StringBuilder sb = new StringBuilder();</span>

<span class="nc" id="L348">            sb.append(&quot;clientPath:&quot; + clientPath);</span>
<span class="nc" id="L349">            sb.append(&quot; serverPath:&quot; + serverPath);</span>
<span class="nc" id="L350">            sb.append(&quot; finished:&quot; + finished);</span>

<span class="nc" id="L352">            sb.append(&quot; header:: &quot; + requestHeader);</span>
<span class="nc" id="L353">            sb.append(&quot; replyHeader:: &quot; + replyHeader);</span>
<span class="nc" id="L354">            sb.append(&quot; request:: &quot; + request);</span>
<span class="nc" id="L355">            sb.append(&quot; response:: &quot; + response);</span>

            // jute toString is horrible, remove unnecessary newlines
<span class="nc" id="L358">            return sb.toString().replaceAll(&quot;\r*\n+&quot;, &quot; &quot;);</span>
        }

    }

    /**
     * Creates a connection object. The actual network connect doesn't get
     * established until needed. The start() instance method must be called
     * subsequent to construction.
     *
     * @param chrootPath the chroot of this client. Should be removed from this Class in ZOOKEEPER-838
     * @param hostProvider the list of ZooKeeper servers to connect to
     * @param sessionTimeout the timeout for connections.
     * @param clientConfig the client configuration.
     * @param defaultWatcher default watcher for this connection
     * @param clientCnxnSocket the socket implementation used (e.g. NIO/Netty)
     * @param canBeReadOnly whether the connection is allowed to go to read-only mode in case of partitioning
     */
    public ClientCnxn(
        String chrootPath,
        HostProvider hostProvider,
        int sessionTimeout,
        ZKClientConfig clientConfig,
        Watcher defaultWatcher,
        ClientCnxnSocket clientCnxnSocket,
        boolean canBeReadOnly
    ) throws IOException {
<span class="nc" id="L385">        this(</span>
            chrootPath,
            hostProvider,
            sessionTimeout,
            clientConfig,
            defaultWatcher,
            clientCnxnSocket,
            0,
            new byte[16],
            canBeReadOnly);
<span class="nc" id="L395">    }</span>

    /**
     * Creates a connection object. The actual network connect doesn't get
     * established until needed. The start() instance method must be called
     * subsequent to construction.
     *
     * @param chrootPath the chroot of this client. Should be removed from this Class in ZOOKEEPER-838
     * @param hostProvider the list of ZooKeeper servers to connect to
     * @param sessionTimeout the timeout for connections.
     * @param clientConfig the client configuration.
     * @param defaultWatcher default watcher for this connection
     * @param clientCnxnSocket the socket implementation used (e.g. NIO/Netty)
     * @param sessionId session id if re-establishing session
     * @param sessionPasswd session passwd if re-establishing session
     * @param canBeReadOnly whether the connection is allowed to go to read-only mode in case of partitioning
     * @throws IOException in cases of broken network
     */
    public ClientCnxn(
        String chrootPath,
        HostProvider hostProvider,
        int sessionTimeout,
        ZKClientConfig clientConfig,
        Watcher defaultWatcher,
        ClientCnxnSocket clientCnxnSocket,
        long sessionId,
        byte[] sessionPasswd,
        boolean canBeReadOnly
<span class="nc" id="L423">    ) throws IOException {</span>
<span class="nc" id="L424">        this.chrootPath = chrootPath;</span>
<span class="nc" id="L425">        this.hostProvider = hostProvider;</span>
<span class="nc" id="L426">        this.sessionTimeout = sessionTimeout;</span>
<span class="nc" id="L427">        this.clientConfig = clientConfig;</span>
<span class="nc" id="L428">        this.sessionId = sessionId;</span>
<span class="nc" id="L429">        this.sessionPasswd = sessionPasswd;</span>
<span class="nc" id="L430">        this.readOnly = canBeReadOnly;</span>

<span class="nc" id="L432">        this.watchManager = new ZKWatchManager(</span>
<span class="nc" id="L433">                clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET),</span>
                defaultWatcher);

<span class="nc" id="L436">        this.connectTimeout = sessionTimeout / hostProvider.size();</span>
<span class="nc" id="L437">        this.readTimeout = sessionTimeout * 2 / 3;</span>

<span class="nc" id="L439">        this.sendThread = new SendThread(clientCnxnSocket);</span>
<span class="nc" id="L440">        this.eventThread = new EventThread();</span>
<span class="nc" id="L441">        initRequestTimeout();</span>
<span class="nc" id="L442">    }</span>

    public void start() {
<span class="nc" id="L445">        sendThread.start();</span>
<span class="nc" id="L446">        eventThread.start();</span>
<span class="nc" id="L447">    }</span>

<span class="nc" id="L449">    private Object eventOfDeath = new Object();</span>

    private static class WatcherSetEventPair {

        private final Set&lt;Watcher&gt; watchers;
        private final WatchedEvent event;

<span class="nc" id="L456">        public WatcherSetEventPair(Set&lt;Watcher&gt; watchers, WatchedEvent event) {</span>
<span class="nc" id="L457">            this.watchers = watchers;</span>
<span class="nc" id="L458">            this.event = event;</span>
<span class="nc" id="L459">        }</span>

    }

    /**
     * Guard against creating &quot;-EventThread-EventThread-EventThread-...&quot; thread
     * names when ZooKeeper object is being created from within a watcher.
     * See ZOOKEEPER-795 for details.
     */
    private static String makeThreadName(String suffix) {
<span class="nc" id="L469">        String name = Thread.currentThread().getName().replaceAll(&quot;-EventThread&quot;, &quot;&quot;);</span>
<span class="nc" id="L470">        return name + suffix;</span>
    }

    /**
     * Tests that current thread is the main event loop.
     * This method is useful only for tests inside ZooKeeper project
     * it is not a public API intended for use by external applications.
     * @return true if Thread.currentThread() is an EventThread.
     */
    public static boolean isInEventThread() {
<span class="nc" id="L480">        return Thread.currentThread() instanceof EventThread;</span>
    }

    class EventThread extends ZooKeeperThread {

<span class="nc" id="L485">        private final LinkedBlockingQueue&lt;Object&gt; waitingEvents = new LinkedBlockingQueue&lt;Object&gt;();</span>

        /** This is really the queued session state until the event
         * thread actually processes the event and hands it to the watcher.
         * But for all intents and purposes this is the state.
         */
<span class="nc" id="L491">        private volatile KeeperState sessionState = KeeperState.Disconnected;</span>

<span class="nc" id="L493">        private volatile boolean wasKilled = false;</span>
<span class="nc" id="L494">        private volatile boolean isRunning = false;</span>

<span class="nc" id="L496">        EventThread() {</span>
<span class="nc" id="L497">            super(makeThreadName(&quot;-EventThread&quot;));</span>
<span class="nc" id="L498">            setDaemon(true);</span>
<span class="nc" id="L499">        }</span>

        public void queueEvent(WatchedEvent event) {
<span class="nc" id="L502">            queueEvent(event, null);</span>
<span class="nc" id="L503">        }</span>

        private void queueEvent(WatchedEvent event, Set&lt;Watcher&gt; materializedWatchers) {
<span class="nc bnc" id="L506" title="All 4 branches missed.">            if (event.getType() == EventType.None &amp;&amp; sessionState == event.getState()) {</span>
<span class="nc" id="L507">                return;</span>
            }
<span class="nc" id="L509">            sessionState = event.getState();</span>
            final Set&lt;Watcher&gt; watchers;
<span class="nc bnc" id="L511" title="All 2 branches missed.">            if (materializedWatchers == null) {</span>
                // materialize the watchers based on the event
<span class="nc" id="L513">                watchers = watchManager.materialize(event.getState(), event.getType(), event.getPath());</span>
            } else {
<span class="nc" id="L515">                watchers = new HashSet&lt;&gt;(materializedWatchers);</span>
            }
<span class="nc" id="L517">            WatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);</span>
            // queue the pair (watch set &amp; event) for later processing
<span class="nc" id="L519">            waitingEvents.add(pair);</span>
<span class="nc" id="L520">        }</span>

        public void queueCallback(AsyncCallback cb, int rc, String path, Object ctx) {
<span class="nc" id="L523">            waitingEvents.add(new LocalCallback(cb, rc, path, ctx));</span>
<span class="nc" id="L524">        }</span>

        @SuppressFBWarnings(&quot;JLM_JSR166_UTILCONCURRENT_MONITORENTER&quot;)
        public void queuePacket(Packet packet) {
<span class="nc bnc" id="L528" title="All 2 branches missed.">            if (wasKilled) {</span>
<span class="nc" id="L529">                synchronized (waitingEvents) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                    if (isRunning) {</span>
<span class="nc" id="L531">                        waitingEvents.add(packet);</span>
                    } else {
<span class="nc" id="L533">                        processEvent(packet);</span>
                    }
<span class="nc" id="L535">                }</span>
            } else {
<span class="nc" id="L537">                waitingEvents.add(packet);</span>
            }
<span class="nc" id="L539">        }</span>

        public void queueEventOfDeath() {
<span class="nc" id="L542">            waitingEvents.add(eventOfDeath);</span>
<span class="nc" id="L543">        }</span>

        @Override
        @SuppressFBWarnings(&quot;JLM_JSR166_UTILCONCURRENT_MONITORENTER&quot;)
        public void run() {
            try {
<span class="nc" id="L549">                isRunning = true;</span>
                while (true) {
<span class="nc" id="L551">                    Object event = waitingEvents.take();</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                    if (event == eventOfDeath) {</span>
<span class="nc" id="L553">                        wasKilled = true;</span>
                    } else {
<span class="nc" id="L555">                        processEvent(event);</span>
                    }
<span class="nc bnc" id="L557" title="All 2 branches missed.">                    if (wasKilled) {</span>
<span class="nc" id="L558">                        synchronized (waitingEvents) {</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                            if (waitingEvents.isEmpty()) {</span>
<span class="nc" id="L560">                                isRunning = false;</span>
<span class="nc" id="L561">                                break;</span>
                            }
<span class="nc" id="L563">                        }</span>
                    }
<span class="nc" id="L565">                }</span>
<span class="nc" id="L566">            } catch (InterruptedException e) {</span>
<span class="nc" id="L567">                LOG.error(&quot;Event thread exiting due to interruption&quot;, e);</span>
<span class="nc" id="L568">            }</span>

<span class="nc" id="L570">            LOG.info(&quot;EventThread shut down for session: 0x{}&quot;, Long.toHexString(getSessionId()));</span>
<span class="nc" id="L571">        }</span>

        private void processEvent(Object event) {
            try {
<span class="nc bnc" id="L575" title="All 2 branches missed.">                if (event instanceof WatcherSetEventPair) {</span>
                    // each watcher will process the event
<span class="nc" id="L577">                    WatcherSetEventPair pair = (WatcherSetEventPair) event;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">                    for (Watcher watcher : pair.watchers) {</span>
                        try {
<span class="nc" id="L580">                            watcher.process(pair.event);</span>
<span class="nc" id="L581">                        } catch (Throwable t) {</span>
<span class="nc" id="L582">                            LOG.error(&quot;Error while calling watcher.&quot;, t);</span>
<span class="nc" id="L583">                        }</span>
<span class="nc" id="L584">                    }</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">                } else if (event instanceof LocalCallback) {</span>
<span class="nc" id="L586">                    LocalCallback lcb = (LocalCallback) event;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                    if (lcb.cb instanceof StatCallback) {</span>
<span class="nc" id="L588">                        ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                    } else if (lcb.cb instanceof DataCallback) {</span>
<span class="nc" id="L590">                        ((DataCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                    } else if (lcb.cb instanceof ACLCallback) {</span>
<span class="nc" id="L592">                        ((ACLCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                    } else if (lcb.cb instanceof ChildrenCallback) {</span>
<span class="nc" id="L594">                        ((ChildrenCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                    } else if (lcb.cb instanceof Children2Callback) {</span>
<span class="nc" id="L596">                        ((Children2Callback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">                    } else if (lcb.cb instanceof StringCallback) {</span>
<span class="nc" id="L598">                        ((StringCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">                    } else if (lcb.cb instanceof AsyncCallback.EphemeralsCallback) {</span>
<span class="nc" id="L600">                        ((AsyncCallback.EphemeralsCallback) lcb.cb).processResult(lcb.rc, lcb.ctx, null);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">                    } else if (lcb.cb instanceof AsyncCallback.AllChildrenNumberCallback) {</span>
<span class="nc" id="L602">                        ((AsyncCallback.AllChildrenNumberCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, -1);</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                    } else if (lcb.cb instanceof AsyncCallback.MultiCallback) {</span>
<span class="nc" id="L604">                        ((AsyncCallback.MultiCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, Collections.emptyList());</span>
                    } else {
<span class="nc" id="L606">                        ((VoidCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx);</span>
                    }
<span class="nc" id="L608">                } else {</span>
<span class="nc" id="L609">                    Packet p = (Packet) event;</span>
<span class="nc" id="L610">                    int rc = 0;</span>
<span class="nc" id="L611">                    String clientPath = p.clientPath;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                    if (p.replyHeader.getErr() != 0) {</span>
<span class="nc" id="L613">                        rc = p.replyHeader.getErr();</span>
                    }
<span class="nc bnc" id="L615" title="All 2 branches missed.">                    if (p.cb == null) {</span>
<span class="nc" id="L616">                        LOG.warn(&quot;Somehow a null cb got to EventThread!&quot;);</span>
<span class="nc bnc" id="L617" title="All 6 branches missed.">                    } else if (p.response instanceof ExistsResponse</span>
                               || p.response instanceof SetDataResponse
                               || p.response instanceof SetACLResponse) {
<span class="nc" id="L620">                        StatCallback cb = (StatCallback) p.cb;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                        if (rc == Code.OK.intValue()) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                            if (p.response instanceof ExistsResponse) {</span>
<span class="nc" id="L623">                                cb.processResult(rc, clientPath, p.ctx, ((ExistsResponse) p.response).getStat());</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                            } else if (p.response instanceof SetDataResponse) {</span>
<span class="nc" id="L625">                                cb.processResult(rc, clientPath, p.ctx, ((SetDataResponse) p.response).getStat());</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                            } else if (p.response instanceof SetACLResponse) {</span>
<span class="nc" id="L627">                                cb.processResult(rc, clientPath, p.ctx, ((SetACLResponse) p.response).getStat());</span>
                            }
                        } else {
<span class="nc" id="L630">                            cb.processResult(rc, clientPath, p.ctx, null);</span>
                        }
<span class="nc bnc" id="L632" title="All 2 branches missed.">                    } else if (p.response instanceof GetDataResponse) {</span>
<span class="nc" id="L633">                        DataCallback cb = (DataCallback) p.cb;</span>
<span class="nc" id="L634">                        GetDataResponse rsp = (GetDataResponse) p.response;</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                        if (rc == Code.OK.intValue()) {</span>
<span class="nc" id="L636">                            cb.processResult(rc, clientPath, p.ctx, rsp.getData(), rsp.getStat());</span>
                        } else {
<span class="nc" id="L638">                            cb.processResult(rc, clientPath, p.ctx, null, null);</span>
                        }
<span class="nc bnc" id="L640" title="All 2 branches missed.">                    } else if (p.response instanceof GetACLResponse) {</span>
<span class="nc" id="L641">                        ACLCallback cb = (ACLCallback) p.cb;</span>
<span class="nc" id="L642">                        GetACLResponse rsp = (GetACLResponse) p.response;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                        if (rc == Code.OK.intValue()) {</span>
<span class="nc" id="L644">                            cb.processResult(rc, clientPath, p.ctx, rsp.getAcl(), rsp.getStat());</span>
                        } else {
<span class="nc" id="L646">                            cb.processResult(rc, clientPath, p.ctx, null, null);</span>
                        }
<span class="nc bnc" id="L648" title="All 2 branches missed.">                    } else if (p.response instanceof GetChildrenResponse) {</span>
<span class="nc" id="L649">                        ChildrenCallback cb = (ChildrenCallback) p.cb;</span>
<span class="nc" id="L650">                        GetChildrenResponse rsp = (GetChildrenResponse) p.response;</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">                        if (rc == Code.OK.intValue()) {</span>
<span class="nc" id="L652">                            cb.processResult(rc, clientPath, p.ctx, rsp.getChildren());</span>
                        } else {
<span class="nc" id="L654">                            cb.processResult(rc, clientPath, p.ctx, null);</span>
                        }
<span class="nc bnc" id="L656" title="All 2 branches missed.">                    } else if (p.response instanceof GetAllChildrenNumberResponse) {</span>
<span class="nc" id="L657">                        AllChildrenNumberCallback cb = (AllChildrenNumberCallback) p.cb;</span>
<span class="nc" id="L658">                        GetAllChildrenNumberResponse rsp = (GetAllChildrenNumberResponse) p.response;</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">                        if (rc == Code.OK.intValue()) {</span>
<span class="nc" id="L660">                            cb.processResult(rc, clientPath, p.ctx, rsp.getTotalNumber());</span>
                        } else {
<span class="nc" id="L662">                            cb.processResult(rc, clientPath, p.ctx, -1);</span>
                        }
<span class="nc bnc" id="L664" title="All 2 branches missed.">                    } else if (p.response instanceof GetChildren2Response) {</span>
<span class="nc" id="L665">                        Children2Callback cb = (Children2Callback) p.cb;</span>
<span class="nc" id="L666">                        GetChildren2Response rsp = (GetChildren2Response) p.response;</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                        if (rc == Code.OK.intValue()) {</span>
<span class="nc" id="L668">                            cb.processResult(rc, clientPath, p.ctx, rsp.getChildren(), rsp.getStat());</span>
                        } else {
<span class="nc" id="L670">                            cb.processResult(rc, clientPath, p.ctx, null, null);</span>
                        }
<span class="nc bnc" id="L672" title="All 2 branches missed.">                    } else if (p.response instanceof CreateResponse) {</span>
<span class="nc" id="L673">                        StringCallback cb = (StringCallback) p.cb;</span>
<span class="nc" id="L674">                        CreateResponse rsp = (CreateResponse) p.response;</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">                        if (rc == Code.OK.intValue()) {</span>
<span class="nc" id="L676">                            cb.processResult(</span>
                                rc,
                                clientPath,
                                p.ctx,
<span class="nc bnc" id="L680" title="All 2 branches missed.">                                (chrootPath == null</span>
<span class="nc" id="L681">                                    ? rsp.getPath()</span>
<span class="nc" id="L682">                                    : rsp.getPath().substring(chrootPath.length())));</span>
                        } else {
<span class="nc" id="L684">                            cb.processResult(rc, clientPath, p.ctx, null);</span>
                        }
<span class="nc bnc" id="L686" title="All 2 branches missed.">                    } else if (p.response instanceof Create2Response) {</span>
<span class="nc" id="L687">                        Create2Callback cb = (Create2Callback) p.cb;</span>
<span class="nc" id="L688">                        Create2Response rsp = (Create2Response) p.response;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">                        if (rc == Code.OK.intValue()) {</span>
<span class="nc" id="L690">                            cb.processResult(</span>
                                    rc,
                                    clientPath,
                                    p.ctx,
<span class="nc bnc" id="L694" title="All 2 branches missed.">                                    (chrootPath == null</span>
<span class="nc" id="L695">                                            ? rsp.getPath()</span>
<span class="nc" id="L696">                                            : rsp.getPath().substring(chrootPath.length())),</span>
<span class="nc" id="L697">                                    rsp.getStat());</span>
                        } else {
<span class="nc" id="L699">                            cb.processResult(rc, clientPath, p.ctx, null, null);</span>
                        }
<span class="nc bnc" id="L701" title="All 2 branches missed.">                    } else if (p.response instanceof MultiResponse) {</span>
<span class="nc" id="L702">                        MultiCallback cb = (MultiCallback) p.cb;</span>
<span class="nc" id="L703">                        MultiResponse rsp = (MultiResponse) p.response;</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                        if (rc == Code.OK.intValue()) {</span>
<span class="nc" id="L705">                            List&lt;OpResult&gt; results = rsp.getResultList();</span>
<span class="nc" id="L706">                            int newRc = rc;</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                            for (OpResult result : results) {</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">                                if (result instanceof ErrorResult</span>
<span class="nc" id="L709">                                    &amp;&amp; KeeperException.Code.OK.intValue()</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">                                       != (newRc = ((ErrorResult) result).getErr())) {</span>
<span class="nc" id="L711">                                    break;</span>
                                }
<span class="nc" id="L713">                            }</span>
<span class="nc" id="L714">                            cb.processResult(newRc, clientPath, p.ctx, results);</span>
<span class="nc" id="L715">                        } else {</span>
<span class="nc" id="L716">                            cb.processResult(rc, clientPath, p.ctx, null);</span>
                        }
<span class="nc bnc" id="L718" title="All 2 branches missed.">                    } else if (p.response instanceof GetEphemeralsResponse) {</span>
<span class="nc" id="L719">                        EphemeralsCallback cb = (EphemeralsCallback) p.cb;</span>
<span class="nc" id="L720">                        GetEphemeralsResponse rsp = (GetEphemeralsResponse) p.response;</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                        if (rc == Code.OK.intValue()) {</span>
<span class="nc" id="L722">                            cb.processResult(rc, p.ctx, rsp.getEphemerals());</span>
                        } else {
<span class="nc" id="L724">                            cb.processResult(rc, p.ctx, null);</span>
                        }
<span class="nc bnc" id="L726" title="All 2 branches missed.">                    } else if (p.cb instanceof VoidCallback) {</span>
<span class="nc" id="L727">                        VoidCallback cb = (VoidCallback) p.cb;</span>
<span class="nc" id="L728">                        cb.processResult(rc, clientPath, p.ctx);</span>
                    }
                }
<span class="nc" id="L731">            } catch (Throwable t) {</span>
<span class="nc" id="L732">                LOG.error(&quot;Unexpected throwable&quot;, t);</span>
<span class="nc" id="L733">            }</span>
<span class="nc" id="L734">        }</span>

    }

    // @VisibleForTesting
    protected void finishPacket(Packet p) {
<span class="nc" id="L740">        int err = p.replyHeader.getErr();</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (p.watchRegistration != null) {</span>
<span class="nc" id="L742">            p.watchRegistration.register(err);</span>
        }
        // Add all the removed watch events to the event queue, so that the
        // clients will be notified with 'Data/Child WatchRemoved' event type.
<span class="nc bnc" id="L746" title="All 2 branches missed.">        if (p.watchDeregistration != null) {</span>
<span class="nc" id="L747">            Map&lt;EventType, Set&lt;Watcher&gt;&gt; materializedWatchers = null;</span>
            try {
<span class="nc" id="L749">                materializedWatchers = p.watchDeregistration.unregister(err);</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">                for (Entry&lt;EventType, Set&lt;Watcher&gt;&gt; entry : materializedWatchers.entrySet()) {</span>
<span class="nc" id="L751">                    Set&lt;Watcher&gt; watchers = entry.getValue();</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">                    if (watchers.size() &gt; 0) {</span>
<span class="nc" id="L753">                        queueEvent(p.watchDeregistration.getClientPath(), err, watchers, entry.getKey());</span>
                        // ignore connectionloss when removing from local
                        // session
<span class="nc" id="L756">                        p.replyHeader.setErr(Code.OK.intValue());</span>
                    }
<span class="nc" id="L758">                }</span>
<span class="nc" id="L759">            } catch (KeeperException.NoWatcherException nwe) {</span>
<span class="nc" id="L760">                p.replyHeader.setErr(nwe.code().intValue());</span>
<span class="nc" id="L761">            } catch (KeeperException ke) {</span>
<span class="nc" id="L762">                p.replyHeader.setErr(ke.code().intValue());</span>
<span class="nc" id="L763">            }</span>
        }

<span class="nc bnc" id="L766" title="All 2 branches missed.">        if (p.cb == null) {</span>
<span class="nc" id="L767">            synchronized (p) {</span>
<span class="nc" id="L768">                p.finished = true;</span>
<span class="nc" id="L769">                p.notifyAll();</span>
<span class="nc" id="L770">            }</span>
        } else {
<span class="nc" id="L772">            p.finished = true;</span>
<span class="nc" id="L773">            eventThread.queuePacket(p);</span>
        }
<span class="nc" id="L775">    }</span>

    void queueEvent(String clientPath, int err, Set&lt;Watcher&gt; materializedWatchers, EventType eventType) {
<span class="nc" id="L778">        KeeperState sessionState = KeeperState.SyncConnected;</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (KeeperException.Code.SESSIONEXPIRED.intValue() == err</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">            || KeeperException.Code.CONNECTIONLOSS.intValue() == err) {</span>
<span class="nc" id="L781">            sessionState = Event.KeeperState.Disconnected;</span>
        }
<span class="nc" id="L783">        WatchedEvent event = new WatchedEvent(eventType, sessionState, clientPath);</span>
<span class="nc" id="L784">        eventThread.queueEvent(event, materializedWatchers);</span>
<span class="nc" id="L785">    }</span>

    void queueCallback(AsyncCallback cb, int rc, String path, Object ctx) {
<span class="nc" id="L788">        eventThread.queueCallback(cb, rc, path, ctx);</span>
<span class="nc" id="L789">    }</span>

    // for test only
    protected void onConnecting(InetSocketAddress addr) {

<span class="nc" id="L794">    }</span>

    private void conLossPacket(Packet p) {
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (p.replyHeader == null) {</span>
<span class="nc" id="L798">            return;</span>
        }
<span class="nc bnc" id="L800" title="All 3 branches missed.">        switch (state) {</span>
        case AUTH_FAILED:
<span class="nc" id="L802">            p.replyHeader.setErr(KeeperException.Code.AUTHFAILED.intValue());</span>
<span class="nc" id="L803">            break;</span>
        case CLOSED:
<span class="nc" id="L805">            p.replyHeader.setErr(KeeperException.Code.SESSIONEXPIRED.intValue());</span>
<span class="nc" id="L806">            break;</span>
        default:
<span class="nc" id="L808">            p.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());</span>
        }
<span class="nc" id="L810">        finishPacket(p);</span>
<span class="nc" id="L811">    }</span>

    private volatile long lastZxid;

    public long getLastZxid() {
<span class="nc" id="L816">        return lastZxid;</span>
    }

    static class EndOfStreamException extends IOException {

        private static final long serialVersionUID = -5438877188796231422L;

        public EndOfStreamException(String msg) {
<span class="nc" id="L824">            super(msg);</span>
<span class="nc" id="L825">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L829">            return &quot;EndOfStreamException: &quot; + getMessage();</span>
        }

    }

    private static class SessionTimeoutException extends IOException {

        private static final long serialVersionUID = 824482094072071178L;

        public SessionTimeoutException(String msg) {
<span class="nc" id="L839">            super(msg);</span>
<span class="nc" id="L840">        }</span>

    }

    private static class SessionExpiredException extends IOException {

        private static final long serialVersionUID = -1388816932076193249L;

        public SessionExpiredException(String msg) {
<span class="nc" id="L849">            super(msg);</span>
<span class="nc" id="L850">        }</span>

    }

    private static class RWServerFoundException extends IOException {

        private static final long serialVersionUID = 90431199887158758L;

        public RWServerFoundException(String msg) {
<span class="nc" id="L859">            super(msg);</span>
<span class="nc" id="L860">        }</span>

    }

    /**
     * This class services the outgoing request queue and generates the heart
     * beats. It also spawns the ReadThread.
     */
    class SendThread extends ZooKeeperThread {

        private long lastPingSentNs;
        private final ClientCnxnSocket clientCnxnSocket;
<span class="nc" id="L872">        private boolean isFirstConnect = true;</span>

        void readResponse(ByteBuffer incomingBuffer) throws IOException {
<span class="nc" id="L875">            ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);</span>
<span class="nc" id="L876">            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span>
<span class="nc" id="L877">            ReplyHeader replyHdr = new ReplyHeader();</span>

<span class="nc" id="L879">            replyHdr.deserialize(bbia, &quot;header&quot;);</span>
<span class="nc bnc" id="L880" title="All 4 branches missed.">            switch (replyHdr.getXid()) {</span>
            case PING_XID:
<span class="nc" id="L882">                LOG.debug(&quot;Got ping response for session id: 0x{} after {}ms.&quot;,</span>
<span class="nc" id="L883">                    Long.toHexString(sessionId),</span>
<span class="nc" id="L884">                    ((System.nanoTime() - lastPingSentNs) / 1000000));</span>
<span class="nc" id="L885">                return;</span>
              case AUTHPACKET_XID:
<span class="nc" id="L887">                LOG.debug(&quot;Got auth session id: 0x{}&quot;, Long.toHexString(sessionId));</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">                if (replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) {</span>
<span class="nc" id="L889">                    changeZkState(States.AUTH_FAILED);</span>
<span class="nc" id="L890">                    eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None,</span>
                        Watcher.Event.KeeperState.AuthFailed, null));
<span class="nc" id="L892">                    eventThread.queueEventOfDeath();</span>
                }
<span class="nc" id="L894">              return;</span>
            case NOTIFICATION_XID:
<span class="nc" id="L896">                LOG.debug(&quot;Got notification session id: 0x{}&quot;,</span>
<span class="nc" id="L897">                    Long.toHexString(sessionId));</span>
<span class="nc" id="L898">                WatcherEvent event = new WatcherEvent();</span>
<span class="nc" id="L899">                event.deserialize(bbia, &quot;response&quot;);</span>

                // convert from a server path to a client path
<span class="nc bnc" id="L902" title="All 2 branches missed.">                if (chrootPath != null) {</span>
<span class="nc" id="L903">                    String serverPath = event.getPath();</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                    if (serverPath.compareTo(chrootPath) == 0) {</span>
<span class="nc" id="L905">                        event.setPath(&quot;/&quot;);</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                    } else if (serverPath.length() &gt; chrootPath.length()) {</span>
<span class="nc" id="L907">                        event.setPath(serverPath.substring(chrootPath.length()));</span>
                     } else {
<span class="nc" id="L909">                         LOG.warn(&quot;Got server path {} which is too short for chroot path {}.&quot;,</span>
<span class="nc" id="L910">                             event.getPath(), chrootPath);</span>
                     }
                }

<span class="nc" id="L914">                WatchedEvent we = new WatchedEvent(event);</span>
<span class="nc" id="L915">                LOG.debug(&quot;Got {} for session id 0x{}&quot;, we, Long.toHexString(sessionId));</span>
<span class="nc" id="L916">                eventThread.queueEvent(we);</span>
<span class="nc" id="L917">                return;</span>
            default:
                break;
            }

            // If SASL authentication is currently in progress, construct and
            // send a response packet immediately, rather than queuing a
            // response as with other packets.
<span class="nc bnc" id="L925" title="All 2 branches missed.">            if (tunnelAuthInProgress()) {</span>
<span class="nc" id="L926">                GetSASLRequest request = new GetSASLRequest();</span>
<span class="nc" id="L927">                request.deserialize(bbia, &quot;token&quot;);</span>
<span class="nc" id="L928">                zooKeeperSaslClient.respondToServer(request.getToken(), ClientCnxn.this);</span>
<span class="nc" id="L929">                return;</span>
            }

            Packet packet;
<span class="nc" id="L933">            synchronized (pendingQueue) {</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">                if (pendingQueue.size() == 0) {</span>
<span class="nc" id="L935">                    throw new IOException(&quot;Nothing in the queue, but got &quot; + replyHdr.getXid());</span>
                }
<span class="nc" id="L937">                packet = pendingQueue.remove();</span>
<span class="nc" id="L938">            }</span>
            /*
             * Since requests are processed in order, we better get a response
             * to the first request!
             */
            try {
<span class="nc bnc" id="L944" title="All 2 branches missed.">                if (packet.requestHeader.getXid() != replyHdr.getXid()) {</span>
<span class="nc" id="L945">                    packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());</span>
<span class="nc" id="L946">                    throw new IOException(&quot;Xid out of order. Got Xid &quot; + replyHdr.getXid()</span>
<span class="nc" id="L947">                                          + &quot; with err &quot; + replyHdr.getErr()</span>
<span class="nc" id="L948">                                          + &quot; expected Xid &quot; + packet.requestHeader.getXid()</span>
                                          + &quot; for a packet with details: &quot; + packet);
                }

<span class="nc" id="L952">                packet.replyHeader.setXid(replyHdr.getXid());</span>
<span class="nc" id="L953">                packet.replyHeader.setErr(replyHdr.getErr());</span>
<span class="nc" id="L954">                packet.replyHeader.setZxid(replyHdr.getZxid());</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">                if (replyHdr.getZxid() &gt; 0) {</span>
<span class="nc" id="L956">                    lastZxid = replyHdr.getZxid();</span>
                }
<span class="nc bnc" id="L958" title="All 4 branches missed.">                if (packet.response != null &amp;&amp; replyHdr.getErr() == 0) {</span>
<span class="nc" id="L959">                    packet.response.deserialize(bbia, &quot;response&quot;);</span>
                }

<span class="nc" id="L962">                LOG.debug(&quot;Reading reply session id: 0x{}, packet:: {}&quot;, Long.toHexString(sessionId), packet);</span>
            } finally {
<span class="nc" id="L964">                finishPacket(packet);</span>
            }
<span class="nc" id="L966">        }</span>

<span class="nc" id="L968">        SendThread(ClientCnxnSocket clientCnxnSocket) throws IOException {</span>
<span class="nc" id="L969">            super(makeThreadName(&quot;-SendThread()&quot;));</span>
<span class="nc" id="L970">            changeZkState(States.CONNECTING);</span>
<span class="nc" id="L971">            this.clientCnxnSocket = clientCnxnSocket;</span>
<span class="nc" id="L972">            setDaemon(true);</span>
<span class="nc" id="L973">        }</span>

        // TODO: can not name this method getState since Thread.getState()
        // already exists
        // It would be cleaner to make class SendThread an implementation of
        // Runnable
        /**
         * Used by ClientCnxnSocket
         *
         * @return
         */
        synchronized ZooKeeper.States getZkState() {
<span class="nc" id="L985">            return state;</span>
        }

        synchronized void changeZkState(ZooKeeper.States newState) throws IOException {
<span class="nc bnc" id="L989" title="All 4 branches missed.">            if (!state.isAlive() &amp;&amp; newState == States.CONNECTING) {</span>
<span class="nc" id="L990">                throw new IOException(</span>
                        &quot;Connection has already been closed and reconnection is not allowed&quot;);
            }
            // It's safer to place state modification at the end.
<span class="nc" id="L994">            state = newState;</span>
<span class="nc" id="L995">        }</span>

        ClientCnxnSocket getClientCnxnSocket() {
<span class="nc" id="L998">            return clientCnxnSocket;</span>
        }

        /**
         * Setup session, previous watches, authentication.
         */
        void primeConnection() throws IOException {
<span class="nc" id="L1005">            LOG.info(</span>
                &quot;Socket connection established, initiating session, client: {}, server: {}&quot;,
<span class="nc" id="L1007">                clientCnxnSocket.getLocalSocketAddress(),</span>
<span class="nc" id="L1008">                clientCnxnSocket.getRemoteSocketAddress());</span>
<span class="nc" id="L1009">            isFirstConnect = false;</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">            long sessId = (seenRwServerBefore) ? sessionId : 0;</span>
<span class="nc" id="L1011">            ConnectRequest conReq = new ConnectRequest(0, lastZxid, sessionTimeout, sessId, sessionPasswd);</span>
            // We add backwards since we are pushing into the front
            // Only send if there's a pending watch
<span class="nc bnc" id="L1014" title="All 2 branches missed.">            if (!clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET)) {</span>
<span class="nc" id="L1015">                List&lt;String&gt; dataWatches = watchManager.getDataWatchList();</span>
<span class="nc" id="L1016">                List&lt;String&gt; existWatches = watchManager.getExistWatchList();</span>
<span class="nc" id="L1017">                List&lt;String&gt; childWatches = watchManager.getChildWatchList();</span>
<span class="nc" id="L1018">                List&lt;String&gt; persistentWatches = watchManager.getPersistentWatchList();</span>
<span class="nc" id="L1019">                List&lt;String&gt; persistentRecursiveWatches = watchManager.getPersistentRecursiveWatchList();</span>
<span class="nc bnc" id="L1020" title="All 6 branches missed.">                if (!dataWatches.isEmpty() || !existWatches.isEmpty() || !childWatches.isEmpty()</span>
<span class="nc bnc" id="L1021" title="All 4 branches missed.">                        || !persistentWatches.isEmpty() || !persistentRecursiveWatches.isEmpty()) {</span>
<span class="nc" id="L1022">                    Iterator&lt;String&gt; dataWatchesIter = prependChroot(dataWatches).iterator();</span>
<span class="nc" id="L1023">                    Iterator&lt;String&gt; existWatchesIter = prependChroot(existWatches).iterator();</span>
<span class="nc" id="L1024">                    Iterator&lt;String&gt; childWatchesIter = prependChroot(childWatches).iterator();</span>
<span class="nc" id="L1025">                    Iterator&lt;String&gt; persistentWatchesIter = prependChroot(persistentWatches).iterator();</span>
<span class="nc" id="L1026">                    Iterator&lt;String&gt; persistentRecursiveWatchesIter = prependChroot(persistentRecursiveWatches).iterator();</span>
<span class="nc" id="L1027">                    long setWatchesLastZxid = lastZxid;</span>

<span class="nc bnc" id="L1029" title="All 6 branches missed.">                    while (dataWatchesIter.hasNext() || existWatchesIter.hasNext() || childWatchesIter.hasNext()</span>
<span class="nc bnc" id="L1030" title="All 4 branches missed.">                            || persistentWatchesIter.hasNext() || persistentRecursiveWatchesIter.hasNext()) {</span>
<span class="nc" id="L1031">                        List&lt;String&gt; dataWatchesBatch = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1032">                        List&lt;String&gt; existWatchesBatch = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1033">                        List&lt;String&gt; childWatchesBatch = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1034">                        List&lt;String&gt; persistentWatchesBatch = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1035">                        List&lt;String&gt; persistentRecursiveWatchesBatch = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1036">                        int batchLength = 0;</span>

                        // Note, we may exceed our max length by a bit when we add the last
                        // watch in the batch. This isn't ideal, but it makes the code simpler.
<span class="nc bnc" id="L1040" title="All 2 branches missed.">                        while (batchLength &lt; SET_WATCHES_MAX_LENGTH) {</span>
                            final String watch;
<span class="nc bnc" id="L1042" title="All 2 branches missed.">                            if (dataWatchesIter.hasNext()) {</span>
<span class="nc" id="L1043">                                watch = dataWatchesIter.next();</span>
<span class="nc" id="L1044">                                dataWatchesBatch.add(watch);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                            } else if (existWatchesIter.hasNext()) {</span>
<span class="nc" id="L1046">                                watch = existWatchesIter.next();</span>
<span class="nc" id="L1047">                                existWatchesBatch.add(watch);</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">                            } else if (childWatchesIter.hasNext()) {</span>
<span class="nc" id="L1049">                                watch = childWatchesIter.next();</span>
<span class="nc" id="L1050">                                childWatchesBatch.add(watch);</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">                            }  else if (persistentWatchesIter.hasNext()) {</span>
<span class="nc" id="L1052">                                watch = persistentWatchesIter.next();</span>
<span class="nc" id="L1053">                                persistentWatchesBatch.add(watch);</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                            } else if (persistentRecursiveWatchesIter.hasNext()) {</span>
<span class="nc" id="L1055">                                watch = persistentRecursiveWatchesIter.next();</span>
<span class="nc" id="L1056">                                persistentRecursiveWatchesBatch.add(watch);</span>
                            } else {
                                break;
                            }
<span class="nc" id="L1060">                            batchLength += watch.length();</span>
<span class="nc" id="L1061">                        }</span>

                        Record record;
                        int opcode;
<span class="nc bnc" id="L1065" title="All 4 branches missed.">                        if (persistentWatchesBatch.isEmpty() &amp;&amp; persistentRecursiveWatchesBatch.isEmpty()) {</span>
                            // maintain compatibility with older servers - if no persistent/recursive watchers
                            // are used, use the old version of SetWatches
<span class="nc" id="L1068">                            record = new SetWatches(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch, childWatchesBatch);</span>
<span class="nc" id="L1069">                            opcode = OpCode.setWatches;</span>
                        } else {
<span class="nc" id="L1071">                            record = new SetWatches2(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch,</span>
                                    childWatchesBatch, persistentWatchesBatch, persistentRecursiveWatchesBatch);
<span class="nc" id="L1073">                            opcode = OpCode.setWatches2;</span>
                        }
<span class="nc" id="L1075">                        RequestHeader header = new RequestHeader(ClientCnxn.SET_WATCHES_XID, opcode);</span>
<span class="nc" id="L1076">                        Packet packet = new Packet(header, new ReplyHeader(), record, null, null);</span>
<span class="nc" id="L1077">                        outgoingQueue.addFirst(packet);</span>
<span class="nc" id="L1078">                    }</span>
                }
            }

<span class="nc bnc" id="L1082" title="All 2 branches missed.">            for (AuthData id : authInfo) {</span>
<span class="nc" id="L1083">                outgoingQueue.addFirst(</span>
                    new Packet(
                        new RequestHeader(ClientCnxn.AUTHPACKET_XID, OpCode.auth),
                        null,
                        new AuthPacket(0, id.scheme, id.data),
                        null,
                        null));
<span class="nc" id="L1090">            }</span>
<span class="nc" id="L1091">            outgoingQueue.addFirst(new Packet(null, null, conReq, null, null, readOnly));</span>
<span class="nc" id="L1092">            clientCnxnSocket.connectionPrimed();</span>
<span class="nc" id="L1093">            LOG.debug(&quot;Session establishment request sent on {}&quot;, clientCnxnSocket.getRemoteSocketAddress());</span>
<span class="nc" id="L1094">        }</span>

        private List&lt;String&gt; prependChroot(List&lt;String&gt; paths) {
<span class="nc bnc" id="L1097" title="All 4 branches missed.">            if (chrootPath != null &amp;&amp; !paths.isEmpty()) {</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">                for (int i = 0; i &lt; paths.size(); ++i) {</span>
<span class="nc" id="L1099">                    String clientPath = paths.get(i);</span>
                    String serverPath;
                    // handle clientPath = &quot;/&quot;
<span class="nc bnc" id="L1102" title="All 2 branches missed.">                    if (clientPath.length() == 1) {</span>
<span class="nc" id="L1103">                        serverPath = chrootPath;</span>
                    } else {
<span class="nc" id="L1105">                        serverPath = chrootPath + clientPath;</span>
                    }
<span class="nc" id="L1107">                    paths.set(i, serverPath);</span>
                }
            }
<span class="nc" id="L1110">            return paths;</span>
        }

        private void sendPing() {
<span class="nc" id="L1114">            lastPingSentNs = System.nanoTime();</span>
<span class="nc" id="L1115">            RequestHeader h = new RequestHeader(ClientCnxn.PING_XID, OpCode.ping);</span>
<span class="nc" id="L1116">            queuePacket(h, null, null, null, null, null, null, null, null);</span>
<span class="nc" id="L1117">        }</span>

<span class="nc" id="L1119">        private InetSocketAddress rwServerAddress = null;</span>

        private static final int minPingRwTimeout = 100;

        private static final int maxPingRwTimeout = 60000;

<span class="nc" id="L1125">        private int pingRwTimeout = minPingRwTimeout;</span>

        // Set to true if and only if constructor of ZooKeeperSaslClient
        // throws a LoginException: see startConnect() below.
<span class="nc" id="L1129">        private boolean saslLoginFailed = false;</span>

        private void startConnect(InetSocketAddress addr) throws IOException {
            // initializing it for new connection
<span class="nc" id="L1133">            saslLoginFailed = false;</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">            if (!isFirstConnect) {</span>
                try {
<span class="nc" id="L1136">                    Thread.sleep(ThreadLocalRandom.current().nextLong(1000));</span>
<span class="nc" id="L1137">                } catch (InterruptedException e) {</span>
<span class="nc" id="L1138">                    LOG.warn(&quot;Unexpected exception&quot;, e);</span>
<span class="nc" id="L1139">                }</span>
            }
<span class="nc" id="L1141">            changeZkState(States.CONNECTING);</span>

<span class="nc" id="L1143">            String hostPort = addr.getHostString() + &quot;:&quot; + addr.getPort();</span>
<span class="nc" id="L1144">            MDC.put(&quot;myid&quot;, hostPort);</span>
<span class="nc" id="L1145">            setName(getName().replaceAll(&quot;\\(.*\\)&quot;, &quot;(&quot; + hostPort + &quot;)&quot;));</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">            if (clientConfig.isSaslClientEnabled()) {</span>
                try {
<span class="nc bnc" id="L1148" title="All 2 branches missed.">                    if (zooKeeperSaslClient != null) {</span>
<span class="nc" id="L1149">                        zooKeeperSaslClient.shutdown();</span>
                    }
<span class="nc" id="L1151">                    zooKeeperSaslClient = new ZooKeeperSaslClient(SaslServerPrincipal.getServerPrincipal(addr, clientConfig), clientConfig);</span>
<span class="nc" id="L1152">                } catch (LoginException e) {</span>
                    // An authentication error occurred when the SASL client tried to initialize:
                    // for Kerberos this means that the client failed to authenticate with the KDC.
                    // This is different from an authentication error that occurs during communication
                    // with the Zookeeper server, which is handled below.
<span class="nc" id="L1157">                    LOG.warn(</span>
                        &quot;SASL configuration failed. &quot;
                            + &quot;Will continue connection to Zookeeper server without &quot;
                            + &quot;SASL authentication, if Zookeeper server allows it.&quot;, e);
<span class="nc" id="L1161">                    eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, null));</span>
<span class="nc" id="L1162">                    saslLoginFailed = true;</span>
<span class="nc" id="L1163">                }</span>
            }
<span class="nc" id="L1165">            logStartConnect(addr);</span>

<span class="nc" id="L1167">            clientCnxnSocket.connect(addr);</span>
<span class="nc" id="L1168">        }</span>

        private void logStartConnect(InetSocketAddress addr) {
<span class="nc" id="L1171">            LOG.info(&quot;Opening socket connection to server {}.&quot;, addr);</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">            if (zooKeeperSaslClient != null) {</span>
<span class="nc" id="L1173">                LOG.info(&quot;SASL config status: {}&quot;, zooKeeperSaslClient.getConfigStatus());</span>
            }
<span class="nc" id="L1175">        }</span>

        @Override
        public void run() {
<span class="nc" id="L1179">            clientCnxnSocket.introduce(this, sessionId, outgoingQueue);</span>
<span class="nc" id="L1180">            clientCnxnSocket.updateNow();</span>
<span class="nc" id="L1181">            clientCnxnSocket.updateLastSendAndHeard();</span>
            int to;
<span class="nc" id="L1183">            long lastPingRwServer = Time.currentElapsedTime();</span>
<span class="nc" id="L1184">            final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds</span>
<span class="nc" id="L1185">            InetSocketAddress serverAddress = null;</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            while (state.isAlive()) {</span>
                try {
<span class="nc bnc" id="L1188" title="All 2 branches missed.">                    if (!clientCnxnSocket.isConnected()) {</span>
                        // don't re-establish connection if we are closing
<span class="nc bnc" id="L1190" title="All 2 branches missed.">                        if (closing) {</span>
<span class="nc" id="L1191">                            break;</span>
                        }
<span class="nc bnc" id="L1193" title="All 2 branches missed.">                        if (rwServerAddress != null) {</span>
<span class="nc" id="L1194">                            serverAddress = rwServerAddress;</span>
<span class="nc" id="L1195">                            rwServerAddress = null;</span>
                        } else {
<span class="nc" id="L1197">                            serverAddress = hostProvider.next(1000);</span>
                        }
<span class="nc" id="L1199">                        onConnecting(serverAddress);</span>
<span class="nc" id="L1200">                        startConnect(serverAddress);</span>
                        // Update now to start the connection timer right after we make a connection attempt
<span class="nc" id="L1202">                        clientCnxnSocket.updateNow();</span>
<span class="nc" id="L1203">                        clientCnxnSocket.updateLastSendAndHeard();</span>
                    }

<span class="nc bnc" id="L1206" title="All 2 branches missed.">                    if (state.isConnected()) {</span>
                        // determine whether we need to send an AuthFailed event.
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                        if (zooKeeperSaslClient != null) {</span>
<span class="nc" id="L1209">                            boolean sendAuthEvent = false;</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">                            if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {</span>
                                try {
<span class="nc" id="L1212">                                    zooKeeperSaslClient.initialize(ClientCnxn.this);</span>
<span class="nc" id="L1213">                                } catch (SaslException e) {</span>
<span class="nc" id="L1214">                                    LOG.error(&quot;SASL authentication with Zookeeper Quorum member failed.&quot;, e);</span>
<span class="nc" id="L1215">                                    changeZkState(States.AUTH_FAILED);</span>
<span class="nc" id="L1216">                                    sendAuthEvent = true;</span>
<span class="nc" id="L1217">                                }</span>
                            }
<span class="nc" id="L1219">                            KeeperState authState = zooKeeperSaslClient.getKeeperState();</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">                            if (authState != null) {</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">                                if (authState == KeeperState.AuthFailed) {</span>
                                    // An authentication error occurred during authentication with the Zookeeper Server.
<span class="nc" id="L1223">                                    changeZkState(States.AUTH_FAILED);</span>
<span class="nc" id="L1224">                                    sendAuthEvent = true;</span>
                                } else {
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                                    if (authState == KeeperState.SaslAuthenticated) {</span>
<span class="nc" id="L1227">                                        sendAuthEvent = true;</span>
                                    }
                                }
                            }

<span class="nc bnc" id="L1232" title="All 2 branches missed.">                            if (sendAuthEvent) {</span>
<span class="nc" id="L1233">                                eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">                                if (state == States.AUTH_FAILED) {</span>
<span class="nc" id="L1235">                                    eventThread.queueEventOfDeath();</span>
                                }
                            }
                        }
<span class="nc" id="L1239">                        to = readTimeout - clientCnxnSocket.getIdleRecv();</span>
                    } else {
<span class="nc" id="L1241">                        to = connectTimeout - clientCnxnSocket.getIdleRecv();</span>
                    }

<span class="nc bnc" id="L1244" title="All 2 branches missed.">                    if (to &lt;= 0) {</span>
<span class="nc" id="L1245">                        String warnInfo = String.format(</span>
                            &quot;Client session timed out, have not heard from server in %dms for session id 0x%s&quot;,
<span class="nc" id="L1247">                            clientCnxnSocket.getIdleRecv(),</span>
<span class="nc" id="L1248">                            Long.toHexString(sessionId));</span>
<span class="nc" id="L1249">                        LOG.warn(warnInfo);</span>
<span class="nc" id="L1250">                        throw new SessionTimeoutException(warnInfo);</span>
                    }
<span class="nc bnc" id="L1252" title="All 2 branches missed.">                    if (state.isConnected()) {</span>
                        //1000(1 second) is to prevent race condition missing to send the second ping
                        //also make sure not to send too many pings when readTimeout is small
<span class="nc" id="L1255">                        int timeToNextPing = readTimeout / 2</span>
<span class="nc" id="L1256">                                             - clientCnxnSocket.getIdleSend()</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">                                             - ((clientCnxnSocket.getIdleSend() &gt; 1000) ? 1000 : 0);</span>
                        //send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL
<span class="nc bnc" id="L1259" title="All 4 branches missed.">                        if (timeToNextPing &lt;= 0 || clientCnxnSocket.getIdleSend() &gt; MAX_SEND_PING_INTERVAL) {</span>
<span class="nc" id="L1260">                            sendPing();</span>
<span class="nc" id="L1261">                            clientCnxnSocket.updateLastSend();</span>
                        } else {
<span class="nc bnc" id="L1263" title="All 2 branches missed.">                            if (timeToNextPing &lt; to) {</span>
<span class="nc" id="L1264">                                to = timeToNextPing;</span>
                            }
                        }
                    }

                    // If we are in read-only mode, seek for read/write server
<span class="nc bnc" id="L1270" title="All 2 branches missed.">                    if (state == States.CONNECTEDREADONLY) {</span>
<span class="nc" id="L1271">                        long now = Time.currentElapsedTime();</span>
<span class="nc" id="L1272">                        int idlePingRwServer = (int) (now - lastPingRwServer);</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">                        if (idlePingRwServer &gt;= pingRwTimeout) {</span>
<span class="nc" id="L1274">                            lastPingRwServer = now;</span>
<span class="nc" id="L1275">                            idlePingRwServer = 0;</span>
<span class="nc" id="L1276">                            pingRwTimeout = Math.min(2 * pingRwTimeout, maxPingRwTimeout);</span>
<span class="nc" id="L1277">                            pingRwServer();</span>
                        }
<span class="nc" id="L1279">                        to = Math.min(to, pingRwTimeout - idlePingRwServer);</span>
                    }

<span class="nc" id="L1282">                    clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);</span>
<span class="nc" id="L1283">                } catch (Throwable e) {</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">                    if (closing) {</span>
                        // closing so this is expected
<span class="nc" id="L1286">                        LOG.warn(</span>
                            &quot;An exception was thrown while closing send thread for session 0x{}.&quot;,
<span class="nc" id="L1288">                            Long.toHexString(getSessionId()),</span>
                            e);
<span class="nc" id="L1290">                        break;</span>
                    } else {
<span class="nc" id="L1292">                        LOG.warn(</span>
                            &quot;Session 0x{} for sever {}, Closing socket connection. &quot;
                                + &quot;Attempting reconnect except it is a SessionExpiredException.&quot;,
<span class="nc" id="L1295">                            Long.toHexString(getSessionId()),</span>
                            serverAddress,
                            e);

                        // At this point, there might still be new packets appended to outgoingQueue.
                        // they will be handled in next connection or cleared up if closed.
<span class="nc" id="L1301">                        cleanAndNotifyState();</span>
                    }
<span class="nc" id="L1303">                }</span>
            }

<span class="nc" id="L1306">            synchronized (state) {</span>
                // When it comes to this point, it guarantees that later queued
                // packet to outgoingQueue will be notified of death.
<span class="nc" id="L1309">                cleanup();</span>
<span class="nc" id="L1310">            }</span>
<span class="nc" id="L1311">            clientCnxnSocket.close();</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">            if (state.isAlive()) {</span>
<span class="nc" id="L1313">                eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));</span>
            }
<span class="nc" id="L1315">            eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Closed, null));</span>
<span class="nc" id="L1316">            ZooTrace.logTraceMessage(</span>
<span class="nc" id="L1317">                LOG,</span>
<span class="nc" id="L1318">                ZooTrace.getTextTraceLevel(),</span>
<span class="nc" id="L1319">                &quot;SendThread exited loop for session: 0x&quot; + Long.toHexString(getSessionId()));</span>
<span class="nc" id="L1320">        }</span>

        private void cleanAndNotifyState() {
<span class="nc" id="L1323">            cleanup();</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">            if (state.isAlive()) {</span>
<span class="nc" id="L1325">                eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));</span>
            }
<span class="nc" id="L1327">            clientCnxnSocket.updateNow();</span>
<span class="nc" id="L1328">            clientCnxnSocket.updateLastSendAndHeard();</span>
<span class="nc" id="L1329">        }</span>

        private void pingRwServer() throws RWServerFoundException {
<span class="nc" id="L1332">            String result = null;</span>
<span class="nc" id="L1333">            InetSocketAddress addr = hostProvider.next(0);</span>

<span class="nc" id="L1335">            LOG.info(&quot;Checking server {} for being r/w. Timeout {}&quot;, addr, pingRwTimeout);</span>

<span class="nc" id="L1337">            Socket sock = null;</span>
<span class="nc" id="L1338">            BufferedReader br = null;</span>
            try {
<span class="nc" id="L1340">                sock = new Socket(addr.getHostString(), addr.getPort());</span>
<span class="nc" id="L1341">                sock.setSoLinger(false, -1);</span>
<span class="nc" id="L1342">                sock.setSoTimeout(1000);</span>
<span class="nc" id="L1343">                sock.setTcpNoDelay(true);</span>
<span class="nc" id="L1344">                sock.getOutputStream().write(&quot;isro&quot;.getBytes());</span>
<span class="nc" id="L1345">                sock.getOutputStream().flush();</span>
<span class="nc" id="L1346">                sock.shutdownOutput();</span>
<span class="nc" id="L1347">                br = new BufferedReader(new InputStreamReader(sock.getInputStream()));</span>
<span class="nc" id="L1348">                result = br.readLine();</span>
<span class="nc" id="L1349">            } catch (ConnectException e) {</span>
                // ignore, this just means server is not up
<span class="nc" id="L1351">            } catch (IOException e) {</span>
                // some unexpected error, warn about it
<span class="nc" id="L1353">                LOG.warn(&quot;Exception while seeking for r/w server.&quot;, e);</span>
            } finally {
<span class="nc bnc" id="L1355" title="All 2 branches missed.">                if (sock != null) {</span>
                    try {
<span class="nc" id="L1357">                        sock.close();</span>
<span class="nc" id="L1358">                    } catch (IOException e) {</span>
<span class="nc" id="L1359">                        LOG.warn(&quot;Unexpected exception&quot;, e);</span>
<span class="nc" id="L1360">                    }</span>
                }
<span class="nc bnc" id="L1362" title="All 2 branches missed.">                if (br != null) {</span>
                    try {
<span class="nc" id="L1364">                        br.close();</span>
<span class="nc" id="L1365">                    } catch (IOException e) {</span>
<span class="nc" id="L1366">                        LOG.warn(&quot;Unexpected exception&quot;, e);</span>
<span class="nc" id="L1367">                    }</span>
                }
            }

<span class="nc bnc" id="L1371" title="All 2 branches missed.">            if (&quot;rw&quot;.equals(result)) {</span>
<span class="nc" id="L1372">                pingRwTimeout = minPingRwTimeout;</span>
                // save the found address so that it's used during the next
                // connection attempt
<span class="nc" id="L1375">                rwServerAddress = addr;</span>
<span class="nc" id="L1376">                throw new RWServerFoundException(&quot;Majority server found at &quot;</span>
<span class="nc" id="L1377">                                                 + addr.getHostString() + &quot;:&quot; + addr.getPort());</span>
            }
<span class="nc" id="L1379">        }</span>

        private void cleanup() {
<span class="nc" id="L1382">            clientCnxnSocket.cleanup();</span>
<span class="nc" id="L1383">            synchronized (pendingQueue) {</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                for (Packet p : pendingQueue) {</span>
<span class="nc" id="L1385">                    conLossPacket(p);</span>
<span class="nc" id="L1386">                }</span>
<span class="nc" id="L1387">                pendingQueue.clear();</span>
<span class="nc" id="L1388">            }</span>
            // We can't call outgoingQueue.clear() here because
            // between iterating and clear up there might be new
            // packets added in queuePacket().
<span class="nc" id="L1392">            Iterator&lt;Packet&gt; iter = outgoingQueue.iterator();</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L1394">                Packet p = iter.next();</span>
<span class="nc" id="L1395">                conLossPacket(p);</span>
<span class="nc" id="L1396">                iter.remove();</span>
<span class="nc" id="L1397">            }</span>
<span class="nc" id="L1398">        }</span>

        /**
         * Callback invoked by the ClientCnxnSocket once a connection has been
         * established.
         *
         * @param _negotiatedSessionTimeout
         * @param _sessionId
         * @param _sessionPasswd
         * @param isRO
         * @throws IOException
         */
        void onConnected(
            int _negotiatedSessionTimeout,
            long _sessionId,
            byte[] _sessionPasswd,
            boolean isRO) throws IOException {
<span class="nc" id="L1415">            negotiatedSessionTimeout = _negotiatedSessionTimeout;</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">            if (negotiatedSessionTimeout &lt;= 0) {</span>
<span class="nc" id="L1417">                changeZkState(States.CLOSED);</span>

<span class="nc" id="L1419">                eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));</span>
<span class="nc" id="L1420">                eventThread.queueEventOfDeath();</span>

<span class="nc" id="L1422">                String warnInfo = String.format(</span>
                    &quot;Unable to reconnect to ZooKeeper service, session 0x%s has expired&quot;,
<span class="nc" id="L1424">                    Long.toHexString(sessionId));</span>
<span class="nc" id="L1425">                LOG.warn(warnInfo);</span>
<span class="nc" id="L1426">                throw new SessionExpiredException(warnInfo);</span>
            }

<span class="nc bnc" id="L1429" title="All 4 branches missed.">            if (!readOnly &amp;&amp; isRO) {</span>
<span class="nc" id="L1430">                LOG.error(&quot;Read/write client got connected to read-only server&quot;);</span>
            }

<span class="nc" id="L1433">            readTimeout = negotiatedSessionTimeout * 2 / 3;</span>
<span class="nc" id="L1434">            connectTimeout = negotiatedSessionTimeout / hostProvider.size();</span>
<span class="nc" id="L1435">            hostProvider.onConnected();</span>
<span class="nc" id="L1436">            sessionId = _sessionId;</span>
<span class="nc" id="L1437">            sessionPasswd = _sessionPasswd;</span>
<span class="nc bnc" id="L1438" title="All 2 branches missed.">            changeZkState((isRO) ? States.CONNECTEDREADONLY : States.CONNECTED);</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">            seenRwServerBefore |= !isRO;</span>
<span class="nc" id="L1440">            LOG.info(</span>
                &quot;Session establishment complete on server {}, session id = 0x{}, negotiated timeout = {}{}&quot;,
<span class="nc" id="L1442">                clientCnxnSocket.getRemoteSocketAddress(),</span>
<span class="nc" id="L1443">                Long.toHexString(sessionId),</span>
<span class="nc" id="L1444">                negotiatedSessionTimeout,</span>
<span class="nc bnc" id="L1445" title="All 2 branches missed.">                (isRO ? &quot; (READ-ONLY mode)&quot; : &quot;&quot;));</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">            KeeperState eventState = (isRO) ? KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;</span>
<span class="nc" id="L1447">            eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, eventState, null));</span>
<span class="nc" id="L1448">        }</span>

        void close() {
            try {
<span class="nc" id="L1452">                changeZkState(States.CLOSED);</span>
<span class="nc" id="L1453">            } catch (IOException e) {</span>
<span class="nc" id="L1454">                LOG.warn(&quot;Connection close fails when migrates state from {} to CLOSED&quot;,</span>
<span class="nc" id="L1455">                        getZkState());</span>
<span class="nc" id="L1456">            }</span>
<span class="nc" id="L1457">            clientCnxnSocket.onClosing();</span>
<span class="nc" id="L1458">        }</span>

        void testableCloseSocket() throws IOException {
<span class="nc" id="L1461">            clientCnxnSocket.testableCloseSocket();</span>
<span class="nc" id="L1462">        }</span>

        public boolean tunnelAuthInProgress() {
            // 1. SASL client is disabled.
<span class="nc bnc" id="L1466" title="All 2 branches missed.">            if (!clientConfig.isSaslClientEnabled()) {</span>
<span class="nc" id="L1467">                return false;</span>
            }

            // 2. SASL login failed.
<span class="nc bnc" id="L1471" title="All 2 branches missed.">            if (saslLoginFailed) {</span>
<span class="nc" id="L1472">                return false;</span>
            }

            // 3. SendThread has not created the authenticating object yet,
            // therefore authentication is (at the earliest stage of being) in progress.
<span class="nc bnc" id="L1477" title="All 2 branches missed.">            if (zooKeeperSaslClient == null) {</span>
<span class="nc" id="L1478">                return true;</span>
            }

            // 4. authenticating object exists, so ask it for its progress.
<span class="nc" id="L1482">            return zooKeeperSaslClient.clientTunneledAuthenticationInProgress();</span>
        }

        public void sendPacket(Packet p) throws IOException {
<span class="nc" id="L1486">            clientCnxnSocket.sendPacket(p);</span>
<span class="nc" id="L1487">        }</span>

    }

    /**
     * Shutdown the send/event threads. This method should not be called
     * directly - rather it should be called as part of close operation. This
     * method is primarily here to allow the tests to verify disconnection
     * behavior.
     */
    public void disconnect() {
<span class="nc" id="L1498">        LOG.debug(&quot;Disconnecting client for session: 0x{}&quot;, Long.toHexString(getSessionId()));</span>

<span class="nc" id="L1500">        sendThread.close();</span>
        try {
<span class="nc" id="L1502">            sendThread.join();</span>
<span class="nc" id="L1503">        } catch (InterruptedException ex) {</span>
<span class="nc" id="L1504">            LOG.warn(&quot;Got interrupted while waiting for the sender thread to close&quot;, ex);</span>
<span class="nc" id="L1505">        }</span>
<span class="nc" id="L1506">        eventThread.queueEventOfDeath();</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">        if (zooKeeperSaslClient != null) {</span>
<span class="nc" id="L1508">            zooKeeperSaslClient.shutdown();</span>
        }
<span class="nc" id="L1510">    }</span>

    /**
     * Close the connection, which includes; send session disconnect to the
     * server, shutdown the send/event threads.
     *
     * @throws IOException
     */
    public void close() throws IOException {
<span class="nc" id="L1519">        LOG.debug(&quot;Closing client for session: 0x{}&quot;, Long.toHexString(getSessionId()));</span>

        try {
<span class="nc" id="L1522">            RequestHeader h = new RequestHeader();</span>
<span class="nc" id="L1523">            h.setType(ZooDefs.OpCode.closeSession);</span>

<span class="nc" id="L1525">            submitRequest(h, null, null, null);</span>
<span class="nc" id="L1526">        } catch (InterruptedException e) {</span>
            // ignore, close the send/event threads
        } finally {
<span class="nc" id="L1529">            disconnect();</span>
        }
<span class="nc" id="L1531">    }</span>

    // @VisibleForTesting
<span class="nc" id="L1534">    protected int xid = 1;</span>

    // @VisibleForTesting
<span class="nc" id="L1537">    volatile States state = States.NOT_CONNECTED;</span>

    /*
     * getXid() is called externally by ClientCnxnNIO::doIO() when packets are sent from the outgoingQueue to
     * the server. Thus, getXid() must be public.
     */
    public synchronized int getXid() {
        // Avoid negative cxid values.  In particular, cxid values of -4, -2, and -1 are special and
        // must not be used for requests -- see SendThread.readResponse.
        // Skip from MAX to 1.
<span class="nc bnc" id="L1547" title="All 2 branches missed.">        if (xid == Integer.MAX_VALUE) {</span>
<span class="nc" id="L1548">            xid = 1;</span>
        }
<span class="nc" id="L1550">        return xid++;</span>
    }

    public ReplyHeader submitRequest(
        RequestHeader h,
        Record request,
        Record response,
        WatchRegistration watchRegistration) throws InterruptedException {
<span class="nc" id="L1558">        return submitRequest(h, request, response, watchRegistration, null);</span>
    }

    public ReplyHeader submitRequest(
        RequestHeader h,
        Record request,
        Record response,
        WatchRegistration watchRegistration,
        WatchDeregistration watchDeregistration) throws InterruptedException {
<span class="nc" id="L1567">        ReplyHeader r = new ReplyHeader();</span>
<span class="nc" id="L1568">        Packet packet = queuePacket(</span>
            h,
            r,
            request,
            response,
            null,
            null,
            null,
            null,
            watchRegistration,
            watchDeregistration);
<span class="nc" id="L1579">        synchronized (packet) {</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">            if (requestTimeout &gt; 0) {</span>
                // Wait for request completion with timeout
<span class="nc" id="L1582">                waitForPacketFinish(r, packet);</span>
            } else {
                // Wait for request completion infinitely
<span class="nc bnc" id="L1585" title="All 2 branches missed.">                while (!packet.finished) {</span>
<span class="nc" id="L1586">                    packet.wait();</span>
                }
            }
<span class="nc" id="L1589">        }</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">        if (r.getErr() == Code.REQUESTTIMEOUT.intValue()) {</span>
<span class="nc" id="L1591">            sendThread.cleanAndNotifyState();</span>
        }
<span class="nc" id="L1593">        return r;</span>
    }

    /**
     * Wait for request completion with timeout.
     */
    private void waitForPacketFinish(ReplyHeader r, Packet packet) throws InterruptedException {
<span class="nc" id="L1600">        long waitStartTime = Time.currentElapsedTime();</span>
<span class="nc bnc" id="L1601" title="All 2 branches missed.">        while (!packet.finished) {</span>
<span class="nc" id="L1602">            packet.wait(requestTimeout);</span>
<span class="nc bnc" id="L1603" title="All 4 branches missed.">            if (!packet.finished &amp;&amp; ((Time.currentElapsedTime() - waitStartTime) &gt;= requestTimeout)) {</span>
<span class="nc" id="L1604">                LOG.error(&quot;Timeout error occurred for the packet '{}'.&quot;, packet);</span>
<span class="nc" id="L1605">                r.setErr(Code.REQUESTTIMEOUT.intValue());</span>
<span class="nc" id="L1606">                break;</span>
            }
        }
<span class="nc" id="L1609">    }</span>

    public void saslCompleted() {
<span class="nc" id="L1612">        sendThread.getClientCnxnSocket().saslCompleted();</span>
<span class="nc" id="L1613">    }</span>

    public void sendPacket(Record request, Record response, AsyncCallback cb, int opCode) throws IOException {
        // Generate Xid now because it will be sent immediately,
        // by call to sendThread.sendPacket() below.
<span class="nc" id="L1618">        int xid = getXid();</span>
<span class="nc" id="L1619">        RequestHeader h = new RequestHeader();</span>
<span class="nc" id="L1620">        h.setXid(xid);</span>
<span class="nc" id="L1621">        h.setType(opCode);</span>

<span class="nc" id="L1623">        ReplyHeader r = new ReplyHeader();</span>
<span class="nc" id="L1624">        r.setXid(xid);</span>

<span class="nc" id="L1626">        Packet p = new Packet(h, r, request, response, null, false);</span>
<span class="nc" id="L1627">        p.cb = cb;</span>
<span class="nc" id="L1628">        sendThread.sendPacket(p);</span>
<span class="nc" id="L1629">    }</span>

    public Packet queuePacket(
        RequestHeader h,
        ReplyHeader r,
        Record request,
        Record response,
        AsyncCallback cb,
        String clientPath,
        String serverPath,
        Object ctx,
        WatchRegistration watchRegistration) {
<span class="nc" id="L1641">        return queuePacket(h, r, request, response, cb, clientPath, serverPath, ctx, watchRegistration, null);</span>
    }

    public Packet queuePacket(
        RequestHeader h,
        ReplyHeader r,
        Record request,
        Record response,
        AsyncCallback cb,
        String clientPath,
        String serverPath,
        Object ctx,
        WatchRegistration watchRegistration,
        WatchDeregistration watchDeregistration) {
<span class="nc" id="L1655">        Packet packet = null;</span>

        // Note that we do not generate the Xid for the packet yet. It is
        // generated later at send-time, by an implementation of ClientCnxnSocket::doIO(),
        // where the packet is actually sent.
<span class="nc" id="L1660">        packet = new Packet(h, r, request, response, watchRegistration);</span>
<span class="nc" id="L1661">        packet.cb = cb;</span>
<span class="nc" id="L1662">        packet.ctx = ctx;</span>
<span class="nc" id="L1663">        packet.clientPath = clientPath;</span>
<span class="nc" id="L1664">        packet.serverPath = serverPath;</span>
<span class="nc" id="L1665">        packet.watchDeregistration = watchDeregistration;</span>
        // The synchronized block here is for two purpose:
        // 1. synchronize with the final cleanup() in SendThread.run() to avoid race
        // 2. synchronized against each packet. So if a closeSession packet is added,
        // later packet will be notified.
<span class="nc" id="L1670">        synchronized (state) {</span>
<span class="nc bnc" id="L1671" title="All 4 branches missed.">            if (!state.isAlive() || closing) {</span>
<span class="nc" id="L1672">                conLossPacket(packet);</span>
            } else {
                // If the client is asking to close the session then
                // mark as closing
<span class="nc bnc" id="L1676" title="All 2 branches missed.">                if (h.getType() == OpCode.closeSession) {</span>
<span class="nc" id="L1677">                    closing = true;</span>
                }
<span class="nc" id="L1679">                outgoingQueue.add(packet);</span>
            }
<span class="nc" id="L1681">        }</span>
<span class="nc" id="L1682">        sendThread.getClientCnxnSocket().packetAdded();</span>
<span class="nc" id="L1683">        return packet;</span>
    }

    public void addAuthInfo(String scheme, byte[] auth) {
<span class="nc bnc" id="L1687" title="All 2 branches missed.">        if (!state.isAlive()) {</span>
<span class="nc" id="L1688">            return;</span>
        }
<span class="nc" id="L1690">        authInfo.add(new AuthData(scheme, auth));</span>
<span class="nc" id="L1691">        queuePacket(</span>
            new RequestHeader(ClientCnxn.AUTHPACKET_XID, OpCode.auth),
            null,
            new AuthPacket(0, scheme, auth),
            null,
            null,
            null,
            null,
            null,
            null);
<span class="nc" id="L1701">    }</span>

    States getState() {
<span class="nc" id="L1704">        return state;</span>
    }

    private static class LocalCallback {

        private final AsyncCallback cb;
        private final int rc;
        private final String path;
        private final Object ctx;

<span class="nc" id="L1714">        public LocalCallback(AsyncCallback cb, int rc, String path, Object ctx) {</span>
<span class="nc" id="L1715">            this.cb = cb;</span>
<span class="nc" id="L1716">            this.rc = rc;</span>
<span class="nc" id="L1717">            this.path = path;</span>
<span class="nc" id="L1718">            this.ctx = ctx;</span>
<span class="nc" id="L1719">        }</span>

    }

    private void initRequestTimeout() {
        try {
<span class="nc" id="L1725">            requestTimeout = clientConfig.getLong(</span>
                ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT,
                ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT_DEFAULT);
<span class="nc" id="L1728">            LOG.info(</span>
                &quot;{} value is {}. feature enabled={}&quot;,
                ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT,
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                requestTimeout,</span>
<span class="nc" id="L1732">                requestTimeout &gt; 0);</span>
<span class="nc" id="L1733">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L1734">            LOG.error(</span>
                &quot;Configured value {} for property {} can not be parsed to long.&quot;,
<span class="nc" id="L1736">                clientConfig.getProperty(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT),</span>
                ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT);
<span class="nc" id="L1738">            throw e;</span>
<span class="nc" id="L1739">        }</span>
<span class="nc" id="L1740">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>