<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClientCnxnSocketNIO.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper</a> &gt; <span class="el_source">ClientCnxnSocketNIO.java</span></div><h1>ClientCnxnSocketNIO.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.channels.UnresolvedAddressException;
import java.nio.channels.UnsupportedAddressTypeException;
import java.util.Iterator;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.LinkedBlockingDeque;
import org.apache.zookeeper.ClientCnxn.EndOfStreamException;
import org.apache.zookeeper.ClientCnxn.Packet;
import org.apache.zookeeper.ZooDefs.OpCode;
import org.apache.zookeeper.client.ZKClientConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ClientCnxnSocketNIO extends ClientCnxnSocket {

<span class="nc" id="L44">    private static final Logger LOG = LoggerFactory.getLogger(ClientCnxnSocketNIO.class);</span>

<span class="nc" id="L46">    private final Selector selector = Selector.open();</span>

    private SelectionKey sockKey;

    private SocketAddress localSocketAddress;

    private SocketAddress remoteSocketAddress;

<span class="nc" id="L54">    ClientCnxnSocketNIO(ZKClientConfig clientConfig) throws IOException {</span>
<span class="nc" id="L55">        this.clientConfig = clientConfig;</span>
<span class="nc" id="L56">        initProperties();</span>
<span class="nc" id="L57">    }</span>

    @Override
    boolean isConnected() {
<span class="nc bnc" id="L61" title="All 2 branches missed.">        return sockKey != null;</span>
    }

    /**
     * @throws InterruptedException
     * @throws IOException
     */
    void doIO(Queue&lt;Packet&gt; pendingQueue, ClientCnxn cnxn) throws InterruptedException, IOException {
<span class="nc" id="L69">        SocketChannel sock = (SocketChannel) sockKey.channel();</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (sock == null) {</span>
<span class="nc" id="L71">            throw new IOException(&quot;Socket is null!&quot;);</span>
        }
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (sockKey.isReadable()) {</span>
<span class="nc" id="L74">            int rc = sock.read(incomingBuffer);</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">            if (rc &lt; 0) {</span>
<span class="nc" id="L76">                throw new EndOfStreamException(&quot;Unable to read additional data from server sessionid 0x&quot;</span>
<span class="nc" id="L77">                                               + Long.toHexString(sessionId)</span>
                                               + &quot;, likely server has closed socket&quot;);
            }
<span class="nc bnc" id="L80" title="All 2 branches missed.">            if (!incomingBuffer.hasRemaining()) {</span>
<span class="nc" id="L81">                incomingBuffer.flip();</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">                if (incomingBuffer == lenBuffer) {</span>
<span class="nc" id="L83">                    recvCount.getAndIncrement();</span>
<span class="nc" id="L84">                    readLength();</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">                } else if (!initialized) {</span>
<span class="nc" id="L86">                    readConnectResult();</span>
<span class="nc" id="L87">                    enableRead();</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">                    if (findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress()) != null) {</span>
                        // Since SASL authentication has completed (if client is configured to do so),
                        // outgoing packets waiting in the outgoingQueue can now be sent.
<span class="nc" id="L91">                        enableWrite();</span>
                    }
<span class="nc" id="L93">                    lenBuffer.clear();</span>
<span class="nc" id="L94">                    incomingBuffer = lenBuffer;</span>
<span class="nc" id="L95">                    updateLastHeard();</span>
<span class="nc" id="L96">                    initialized = true;</span>
                } else {
<span class="nc" id="L98">                    sendThread.readResponse(incomingBuffer);</span>
<span class="nc" id="L99">                    lenBuffer.clear();</span>
<span class="nc" id="L100">                    incomingBuffer = lenBuffer;</span>
<span class="nc" id="L101">                    updateLastHeard();</span>
                }
            }
        }
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (sockKey.isWritable()) {</span>
<span class="nc" id="L106">            Packet p = findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress());</span>

<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (p != null) {</span>
<span class="nc" id="L109">                updateLastSend();</span>
                // If we already started writing p, p.bb will already exist
<span class="nc bnc" id="L111" title="All 2 branches missed.">                if (p.bb == null) {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">                    if ((p.requestHeader != null)</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">                        &amp;&amp; (p.requestHeader.getType() != OpCode.ping)</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">                        &amp;&amp; (p.requestHeader.getType() != OpCode.auth)) {</span>
<span class="nc" id="L115">                        p.requestHeader.setXid(cnxn.getXid());</span>
                    }
<span class="nc" id="L117">                    p.createBB();</span>
                }
<span class="nc" id="L119">                sock.write(p.bb);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                if (!p.bb.hasRemaining()) {</span>
<span class="nc" id="L121">                    sentCount.getAndIncrement();</span>
<span class="nc" id="L122">                    outgoingQueue.removeFirstOccurrence(p);</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                    if (p.requestHeader != null</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                        &amp;&amp; p.requestHeader.getType() != OpCode.ping</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">                        &amp;&amp; p.requestHeader.getType() != OpCode.auth) {</span>
<span class="nc" id="L126">                        synchronized (pendingQueue) {</span>
<span class="nc" id="L127">                            pendingQueue.add(p);</span>
<span class="nc" id="L128">                        }</span>
                    }
                }
            }
<span class="nc bnc" id="L132" title="All 2 branches missed.">            if (outgoingQueue.isEmpty()) {</span>
                // No more packets to send: turn off write interest flag.
                // Will be turned on later by a later call to enableWrite(),
                // from within ZooKeeperSaslClient (if client is configured
                // to attempt SASL authentication), or in either doIO() or
                // in doTransport() if not.
<span class="nc" id="L138">                disableWrite();</span>
<span class="nc bnc" id="L139" title="All 6 branches missed.">            } else if (!initialized &amp;&amp; p != null &amp;&amp; !p.bb.hasRemaining()) {</span>
                // On initial connection, write the complete connect request
                // packet, but then disable further writes until after
                // receiving a successful connection response.  If the
                // session is expired, then the server sends the expiration
                // response and immediately closes its end of the socket.  If
                // the client is simultaneously writing on its end, then the
                // TCP stack may choose to abort with RST, in which case the
                // client would never receive the session expired event.  See
                // http://docs.oracle.com/javase/6/docs/technotes/guides/net/articles/connection_release.html
<span class="nc" id="L149">                disableWrite();</span>
            } else {
                // Just in case
<span class="nc" id="L152">                enableWrite();</span>
            }
        }
<span class="nc" id="L155">    }</span>

    private Packet findSendablePacket(LinkedBlockingDeque&lt;Packet&gt; outgoingQueue, boolean tunneledAuthInProgres) {
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (outgoingQueue.isEmpty()) {</span>
<span class="nc" id="L159">            return null;</span>
        }
        // If we've already starting sending the first packet, we better finish
<span class="nc bnc" id="L162" title="All 4 branches missed.">        if (outgoingQueue.getFirst().bb != null || !tunneledAuthInProgres) {</span>
<span class="nc" id="L163">            return outgoingQueue.getFirst();</span>
        }
        // Since client's authentication with server is in progress,
        // send only the null-header packet queued by primeConnection().
        // This packet must be sent so that the SASL authentication process
        // can proceed, but all other packets should wait until
        // SASL authentication completes.
<span class="nc" id="L170">        Iterator&lt;Packet&gt; iter = outgoingQueue.iterator();</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L172">            Packet p = iter.next();</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (p.requestHeader == null) {</span>
                // We've found the priming-packet. Move it to the beginning of the queue.
<span class="nc" id="L175">                iter.remove();</span>
<span class="nc" id="L176">                outgoingQueue.addFirst(p);</span>
<span class="nc" id="L177">                return p;</span>
            } else {
                // Non-priming packet: defer it until later, leaving it in the queue
                // until authentication completes.
<span class="nc" id="L181">                LOG.debug(&quot;Deferring non-priming packet {} until SASL authentication completes.&quot;, p);</span>
            }
<span class="nc" id="L183">        }</span>
<span class="nc" id="L184">        return null;</span>
    }

    @Override
    void cleanup() {
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (sockKey != null) {</span>
<span class="nc" id="L190">            SocketChannel sock = (SocketChannel) sockKey.channel();</span>
<span class="nc" id="L191">            sockKey.cancel();</span>
            try {
<span class="nc" id="L193">                sock.socket().shutdownInput();</span>
<span class="nc" id="L194">            } catch (IOException e) {</span>
<span class="nc" id="L195">                LOG.debug(&quot;Ignoring exception during shutdown input&quot;, e);</span>
<span class="nc" id="L196">            }</span>
            try {
<span class="nc" id="L198">                sock.socket().shutdownOutput();</span>
<span class="nc" id="L199">            } catch (IOException e) {</span>
<span class="nc" id="L200">                LOG.debug(&quot;Ignoring exception during shutdown output&quot;, e);</span>
<span class="nc" id="L201">            }</span>
            try {
<span class="nc" id="L203">                sock.socket().close();</span>
<span class="nc" id="L204">            } catch (IOException e) {</span>
<span class="nc" id="L205">                LOG.debug(&quot;Ignoring exception during socket close&quot;, e);</span>
<span class="nc" id="L206">            }</span>
            try {
<span class="nc" id="L208">                sock.close();</span>
<span class="nc" id="L209">            } catch (IOException e) {</span>
<span class="nc" id="L210">                LOG.debug(&quot;Ignoring exception during channel close&quot;, e);</span>
<span class="nc" id="L211">            }</span>
        }
        try {
<span class="nc" id="L214">            Thread.sleep(100);</span>
<span class="nc" id="L215">        } catch (InterruptedException e) {</span>
<span class="nc" id="L216">            LOG.debug(&quot;SendThread interrupted during sleep, ignoring&quot;);</span>
<span class="nc" id="L217">        }</span>
<span class="nc" id="L218">        sockKey = null;</span>
<span class="nc" id="L219">    }</span>

    @Override
    void close() {
        try {
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L225">                LOG.trace(&quot;Doing client selector close&quot;);</span>
            }

<span class="nc" id="L228">            selector.close();</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L231">                LOG.trace(&quot;Closed client selector&quot;);</span>
            }
<span class="nc" id="L233">        } catch (IOException e) {</span>
<span class="nc" id="L234">            LOG.warn(&quot;Ignoring exception during selector close&quot;, e);</span>
<span class="nc" id="L235">        }</span>
<span class="nc" id="L236">    }</span>

    /**
     * create a socket channel.
     * @return the created socket channel
     * @throws IOException
     */
    SocketChannel createSock() throws IOException {
        SocketChannel sock;
<span class="nc" id="L245">        sock = SocketChannel.open();</span>
<span class="nc" id="L246">        sock.configureBlocking(false);</span>
<span class="nc" id="L247">        sock.socket().setSoLinger(false, -1);</span>
<span class="nc" id="L248">        sock.socket().setTcpNoDelay(true);</span>
<span class="nc" id="L249">        return sock;</span>
    }

    /**
     * register with the selection and connect
     * @param sock the {@link SocketChannel}
     * @param addr the address of remote host
     * @throws IOException
     */
    void registerAndConnect(SocketChannel sock, InetSocketAddress addr) throws IOException {
<span class="nc" id="L259">        sockKey = sock.register(selector, SelectionKey.OP_CONNECT);</span>
<span class="nc" id="L260">        boolean immediateConnect = sock.connect(addr);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (immediateConnect) {</span>
<span class="nc" id="L262">            sendThread.primeConnection();</span>
        }
<span class="nc" id="L264">    }</span>

    @Override
    void connect(InetSocketAddress addr) throws IOException {
<span class="nc" id="L268">        SocketChannel sock = createSock();</span>
        try {
<span class="nc" id="L270">            registerAndConnect(sock, addr);</span>
<span class="nc" id="L271">        } catch (UnresolvedAddressException | UnsupportedAddressTypeException | SecurityException | IOException e) {</span>
<span class="nc" id="L272">            LOG.error(&quot;Unable to open socket to {}&quot;, addr);</span>
<span class="nc" id="L273">            sock.close();</span>
<span class="nc" id="L274">            throw e;</span>
<span class="nc" id="L275">        }</span>
<span class="nc" id="L276">        initialized = false;</span>

        /*
         * Reset incomingBuffer
         */
<span class="nc" id="L281">        lenBuffer.clear();</span>
<span class="nc" id="L282">        incomingBuffer = lenBuffer;</span>
<span class="nc" id="L283">    }</span>

    /**
     * Returns the address to which the socket is connected.
     *
     * @return ip address of the remote side of the connection or null if not
     *         connected
     */
    @Override
    SocketAddress getRemoteSocketAddress() {
<span class="nc" id="L293">        return remoteSocketAddress;</span>
    }

    /**
     * Returns the local address to which the socket is bound.
     *
     * @return ip address of the remote side of the connection or null if not
     *         connected
     */
    @Override
    SocketAddress getLocalSocketAddress() {
<span class="nc" id="L304">        return localSocketAddress;</span>
    }

    private void updateSocketAddresses() {
<span class="nc" id="L308">        Socket socket = ((SocketChannel) sockKey.channel()).socket();</span>
<span class="nc" id="L309">        localSocketAddress = socket.getLocalSocketAddress();</span>
<span class="nc" id="L310">        remoteSocketAddress = socket.getRemoteSocketAddress();</span>
<span class="nc" id="L311">    }</span>

    @Override
    void packetAdded() {
<span class="nc" id="L315">        wakeupCnxn();</span>
<span class="nc" id="L316">    }</span>

    @Override
    void onClosing() {
<span class="nc" id="L320">        wakeupCnxn();</span>
<span class="nc" id="L321">    }</span>

    private synchronized void wakeupCnxn() {
<span class="nc" id="L324">        selector.wakeup();</span>
<span class="nc" id="L325">    }</span>

    @Override
    void doTransport(
        int waitTimeOut,
        Queue&lt;Packet&gt; pendingQueue,
        ClientCnxn cnxn) throws IOException, InterruptedException {
<span class="nc" id="L332">        selector.select(waitTimeOut);</span>
        Set&lt;SelectionKey&gt; selected;
<span class="nc" id="L334">        synchronized (this) {</span>
<span class="nc" id="L335">            selected = selector.selectedKeys();</span>
<span class="nc" id="L336">        }</span>
        // Everything below and until we get back to the select is
        // non blocking, so time is effectively a constant. That is
        // Why we just have to do this once, here
<span class="nc" id="L340">        updateNow();</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        for (SelectionKey k : selected) {</span>
<span class="nc" id="L342">            SocketChannel sc = ((SocketChannel) k.channel());</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            if ((k.readyOps() &amp; SelectionKey.OP_CONNECT) != 0) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                if (sc.finishConnect()) {</span>
<span class="nc" id="L345">                    updateLastSendAndHeard();</span>
<span class="nc" id="L346">                    updateSocketAddresses();</span>
<span class="nc" id="L347">                    sendThread.primeConnection();</span>
                }
<span class="nc bnc" id="L349" title="All 2 branches missed.">            } else if ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {</span>
<span class="nc" id="L350">                doIO(pendingQueue, cnxn);</span>
            }
<span class="nc" id="L352">        }</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (sendThread.getZkState().isConnected()) {</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress()) != null) {</span>
<span class="nc" id="L355">                enableWrite();</span>
            }
        }
<span class="nc" id="L358">        selected.clear();</span>
<span class="nc" id="L359">    }</span>

    //TODO should this be synchronized?
    @Override
    void testableCloseSocket() throws IOException {
<span class="nc" id="L364">        LOG.info(&quot;testableCloseSocket() called&quot;);</span>
        // sockKey may be concurrently accessed by multiple
        // threads. We use tmp here to avoid a race condition
<span class="nc" id="L367">        SelectionKey tmp = sockKey;</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (tmp != null) {</span>
<span class="nc" id="L369">            ((SocketChannel) tmp.channel()).socket().close();</span>
        }
<span class="nc" id="L371">    }</span>

    @Override
    void saslCompleted() {
<span class="nc" id="L375">        enableWrite();</span>
<span class="nc" id="L376">    }</span>

    synchronized void enableWrite() {
<span class="nc" id="L379">        int i = sockKey.interestOps();</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if ((i &amp; SelectionKey.OP_WRITE) == 0) {</span>
<span class="nc" id="L381">            sockKey.interestOps(i | SelectionKey.OP_WRITE);</span>
        }
<span class="nc" id="L383">    }</span>

    private synchronized void disableWrite() {
<span class="nc" id="L386">        int i = sockKey.interestOps();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if ((i &amp; SelectionKey.OP_WRITE) != 0) {</span>
<span class="nc" id="L388">            sockKey.interestOps(i &amp; (~SelectionKey.OP_WRITE));</span>
        }
<span class="nc" id="L390">    }</span>

    private synchronized void enableRead() {
<span class="nc" id="L393">        int i = sockKey.interestOps();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if ((i &amp; SelectionKey.OP_READ) == 0) {</span>
<span class="nc" id="L395">            sockKey.interestOps(i | SelectionKey.OP_READ);</span>
        }
<span class="nc" id="L397">    }</span>

    @Override
    void connectionPrimed() {
<span class="nc" id="L401">        sockKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span>
<span class="nc" id="L402">    }</span>

    Selector getSelector() {
<span class="nc" id="L405">        return selector;</span>
    }

    @Override
    void sendPacket(Packet p) throws IOException {
<span class="nc" id="L410">        SocketChannel sock = (SocketChannel) sockKey.channel();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (sock == null) {</span>
<span class="nc" id="L412">            throw new IOException(&quot;Socket is null!&quot;);</span>
        }
<span class="nc" id="L414">        p.createBB();</span>
<span class="nc" id="L415">        ByteBuffer pbb = p.bb;</span>
<span class="nc" id="L416">        sock.write(pbb);</span>
<span class="nc" id="L417">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>