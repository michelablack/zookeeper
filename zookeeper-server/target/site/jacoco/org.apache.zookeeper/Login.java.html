<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Login.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper</a> &gt; <span class="el_source">Login.java</span></div><h1>Login.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper;

/**
 * This class is responsible for refreshing Kerberos credentials for
 * logins for both Zookeeper client and server.
 * See ZooKeeperSaslServer for server-side usage.
 * See ZooKeeperSaslClient for client-side usage.
 */

import java.util.Date;
import java.util.Set;
import java.util.concurrent.ThreadLocalRandom;
import javax.security.auth.Subject;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.kerberos.KerberosPrincipal;
import javax.security.auth.kerberos.KerberosTicket;
import javax.security.auth.login.AppConfigurationEntry;
import javax.security.auth.login.Configuration;
import javax.security.auth.login.LoginContext;
import javax.security.auth.login.LoginException;
import org.apache.zookeeper.client.ZKClientConfig;
import org.apache.zookeeper.common.Time;
import org.apache.zookeeper.common.ZKConfig;
import org.apache.zookeeper.server.ZooKeeperSaslServer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Login {

    private static final String KINIT_COMMAND_DEFAULT = &quot;/usr/bin/kinit&quot;;
<span class="nc" id="L49">    private static final Logger LOG = LoggerFactory.getLogger(Login.class);</span>
<span class="nc" id="L50">    public static final String SYSTEM_USER = System.getProperty(&quot;user.name&quot;, &quot;&lt;NA&gt;&quot;);</span>
    public CallbackHandler callbackHandler;

    // LoginThread will sleep until 80% of time from last refresh to
    // ticket's expiry has been reached, at which time it will wake
    // and try to renew the ticket.
    private static final float TICKET_RENEW_WINDOW = 0.80f;

    /**
     * Percentage of random jitter added to the renewal time
     */
    private static final float TICKET_RENEW_JITTER = 0.05f;

    // Regardless of TICKET_RENEW_WINDOW setting above and the ticket expiry time,
    // thread will not sleep between refresh attempts any less than 1 minute (60*1000 milliseconds = 1 minute).
    // Change the '1' to e.g. 5, to change this to 5 minutes.
    private static final long MIN_TIME_BEFORE_RELOGIN = 1 * 60 * 1000L;

<span class="nc" id="L68">    private Subject subject = null;</span>
<span class="nc" id="L69">    private Thread t = null;</span>
<span class="nc" id="L70">    private boolean isKrbTicket = false;</span>
<span class="nc" id="L71">    private boolean isUsingTicketCache = false;</span>

<span class="nc" id="L73">    private LoginContext login = null;</span>
<span class="nc" id="L74">    private String loginContextName = null;</span>
<span class="nc" id="L75">    private String principal = null;</span>

    // Initialize 'lastLogin' to do a login at first time
<span class="nc" id="L78">    private long lastLogin = Time.currentElapsedTime() - MIN_TIME_BEFORE_RELOGIN;</span>
    private final ZKConfig zkConfig;

    /**
     * LoginThread constructor. The constructor starts the thread used to
     * periodically re-login to the Kerberos Ticket Granting Server.
     *
     * @param loginContextName
     *            name of section in JAAS file that will be use to login. Passed
     *            as first param to javax.security.auth.login.LoginContext().
     *
     * @param callbackHandler
     *            Passed as second param to
     *            javax.security.auth.login.LoginContext().
     * @param zkConfig
     *            client or server configurations
     * @throws javax.security.auth.login.LoginException
     *             Thrown if authentication fails.
     */
<span class="nc" id="L97">    public Login(final String loginContextName, CallbackHandler callbackHandler, final ZKConfig zkConfig) throws LoginException {</span>
<span class="nc" id="L98">        this.zkConfig = zkConfig;</span>
<span class="nc" id="L99">        this.callbackHandler = callbackHandler;</span>
<span class="nc" id="L100">        login = login(loginContextName);</span>
<span class="nc" id="L101">        this.loginContextName = loginContextName;</span>
<span class="nc" id="L102">        subject = login.getSubject();</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();</span>
<span class="nc" id="L104">        AppConfigurationEntry[] entries = Configuration.getConfiguration().getAppConfigurationEntry(loginContextName);</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        for (AppConfigurationEntry entry : entries) {</span>
            // there will only be a single entry, so this for() loop will only be iterated through once.
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (entry.getOptions().get(&quot;useTicketCache&quot;) != null) {</span>
<span class="nc" id="L108">                String val = (String) entry.getOptions().get(&quot;useTicketCache&quot;);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">                if (val.equals(&quot;true&quot;)) {</span>
<span class="nc" id="L110">                    isUsingTicketCache = true;</span>
                }
            }
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if (entry.getOptions().get(&quot;principal&quot;) != null) {</span>
<span class="nc" id="L114">                principal = (String) entry.getOptions().get(&quot;principal&quot;);</span>
            }
            break;
        }

<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (!isKrbTicket) {</span>
            // if no TGT, do not bother with ticket management.
<span class="nc" id="L121">            return;</span>
        }

        // Refresh the Ticket Granting Ticket (TGT) periodically. How often to refresh is determined by the
        // TGT's existing expiry date and the configured MIN_TIME_BEFORE_RELOGIN. For testing and development,
        // you can decrease the interval of expiration of tickets (for example, to 3 minutes) by running :
        //  &quot;modprinc -maxlife 3mins &lt;principal&gt;&quot; in kadmin.
<span class="nc" id="L128">        t = new Thread(new Runnable() {</span>
            public void run() {
<span class="nc" id="L130">                LOG.info(&quot;TGT refresh thread started.&quot;);</span>
                while (true) {  // renewal thread's main loop. if it exits from here, thread will exit.
<span class="nc" id="L132">                    KerberosTicket tgt = getTGT();</span>
<span class="nc" id="L133">                    long now = Time.currentWallTime();</span>
                    long nextRefresh;
                    Date nextRefreshDate;
<span class="nc bnc" id="L136" title="All 2 branches missed.">                    if (tgt == null) {</span>
<span class="nc" id="L137">                        nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;</span>
<span class="nc" id="L138">                        nextRefreshDate = new Date(nextRefresh);</span>
<span class="nc" id="L139">                        LOG.warn(&quot;No TGT found: will try again at {}&quot;, nextRefreshDate);</span>
                    } else {
<span class="nc" id="L141">                        nextRefresh = getRefreshTime(tgt);</span>
<span class="nc" id="L142">                        long expiry = tgt.getEndTime().getTime();</span>
<span class="nc" id="L143">                        Date expiryDate = new Date(expiry);</span>
<span class="nc bnc" id="L144" title="All 4 branches missed.">                        if ((isUsingTicketCache) &amp;&amp; (tgt.getEndTime().equals(tgt.getRenewTill()))) {</span>
<span class="nc" id="L145">                            LOG.error(</span>
                                &quot;The TGT cannot be renewed beyond the next expiry date: {}.&quot;
                                    + &quot;This process will not be able to authenticate new SASL connections after that &quot;
                                    + &quot;time (for example, it will not be authenticate a new connection with a Zookeeper &quot;
                                    + &quot;Quorum member).  Ask your system administrator to either increase the &quot;
                                    + &quot;'renew until' time by doing : 'modprinc -maxrenewlife {}' within &quot;
                                    + &quot;kadmin, or instead, to generate a keytab for {}. Because the TGT's &quot;
                                    + &quot;expiry cannot be further extended by refreshing, exiting refresh thread now.&quot;,
                                expiryDate,
<span class="nc" id="L154">                                principal,</span>
<span class="nc" id="L155">                                principal);</span>
<span class="nc" id="L156">                            return;</span>
                        }
                        // determine how long to sleep from looking at ticket's expiry.
                        // We should not allow the ticket to expire, but we should take into consideration
                        // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so
                        // would cause ticket expiration.
<span class="nc bnc" id="L162" title="All 4 branches missed.">                        if ((nextRefresh &gt; expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) &gt; expiry)) {</span>
                            // expiry is before next scheduled refresh).
<span class="nc" id="L164">                            nextRefresh = now;</span>
                        } else {
<span class="nc bnc" id="L166" title="All 2 branches missed.">                            if (nextRefresh &lt; (now + MIN_TIME_BEFORE_RELOGIN)) {</span>
                                // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).
<span class="nc" id="L168">                                Date until = new Date(nextRefresh);</span>
<span class="nc" id="L169">                                Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);</span>
<span class="nc" id="L170">                                LOG.warn(</span>
                                    &quot;TGT refresh thread time adjusted from : {} to : {} since &quot;
                                        + &quot;the former is sooner than the minimum refresh interval (&quot;
                                        + &quot;{} seconds) from now.&quot;,
                                    until,
                                    newuntil,
<span class="nc" id="L176">                                    (MIN_TIME_BEFORE_RELOGIN / 1000));</span>
                            }
<span class="nc" id="L178">                            nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);</span>
                        }
<span class="nc" id="L180">                        nextRefreshDate = new Date(nextRefresh);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                        if (nextRefresh &gt; expiry) {</span>
<span class="nc" id="L182">                            LOG.error(</span>
                                &quot;next refresh: {} is later than expiry {}.&quot;
                                    + &quot; This may indicate a clock skew problem.&quot;
                                    + &quot; Check that this host and the KDC's &quot;
                                    + &quot;hosts' clocks are in sync. Exiting refresh thread.&quot;,
                                nextRefreshDate,
                                expiryDate);
<span class="nc" id="L189">                            return;</span>
                        }
                    }
<span class="nc bnc" id="L192" title="All 2 branches missed.">                    if (now == nextRefresh) {</span>
<span class="nc" id="L193">                        LOG.info(&quot;refreshing now because expiry is before next scheduled refresh time.&quot;);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">                    } else if (now &lt; nextRefresh) {</span>
<span class="nc" id="L195">                        Date until = new Date(nextRefresh);</span>
<span class="nc" id="L196">                        LOG.info(&quot;TGT refresh sleeping until: {}&quot;, until.toString());</span>
                        try {
<span class="nc" id="L198">                            Thread.sleep(nextRefresh - now);</span>
<span class="nc" id="L199">                        } catch (InterruptedException ie) {</span>
<span class="nc" id="L200">                            LOG.warn(&quot;TGT renewal thread has been interrupted and will exit.&quot;);</span>
<span class="nc" id="L201">                            break;</span>
<span class="nc" id="L202">                        }</span>
<span class="nc" id="L203">                    } else {</span>
<span class="nc" id="L204">                        LOG.error(</span>
                            &quot;nextRefresh:{} is in the past: exiting refresh thread. Check&quot;
                                + &quot; clock sync between this host and KDC - (KDC's clock is likely ahead of this host).&quot;
                                + &quot; Manual intervention will be required for this client to successfully authenticate.&quot;
                                + &quot; Exiting refresh thread.&quot;,
                            nextRefreshDate);
<span class="nc" id="L210">                        break;</span>
                    }
<span class="nc bnc" id="L212" title="All 2 branches missed.">                    if (isUsingTicketCache) {</span>
<span class="nc" id="L213">                        String cmd = zkConfig.getProperty(ZKConfig.KINIT_COMMAND, KINIT_COMMAND_DEFAULT);</span>
<span class="nc" id="L214">                        String kinitArgs = &quot;-R&quot;;</span>
<span class="nc" id="L215">                        int retry = 1;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                        while (retry &gt;= 0) {</span>
                            try {
<span class="nc" id="L218">                                LOG.debug(&quot;running ticket cache refresh command: {} {}&quot;, cmd, kinitArgs);</span>
<span class="nc" id="L219">                                Shell.execCommand(cmd, kinitArgs);</span>
<span class="nc" id="L220">                                break;</span>
<span class="nc" id="L221">                            } catch (Exception e) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                                if (retry &gt; 0) {</span>
<span class="nc" id="L223">                                    --retry;</span>
                                    // sleep for 10 seconds
                                    try {
<span class="nc" id="L226">                                        Thread.sleep(10 * 1000);</span>
<span class="nc" id="L227">                                    } catch (InterruptedException ie) {</span>
<span class="nc" id="L228">                                        LOG.error(&quot;Interrupted while renewing TGT, exiting Login thread&quot;);</span>
<span class="nc" id="L229">                                        return;</span>
<span class="nc" id="L230">                                    }</span>
                                } else {
<span class="nc" id="L232">                                    LOG.warn(</span>
                                        &quot;Could not renew TGT due to problem running shell command: '{} {}'.&quot;
                                            + &quot; Exiting refresh thread.&quot;,
                                        cmd,
                                        kinitArgs,
                                        e);
<span class="nc" id="L238">                                    return;</span>
                                }
<span class="nc" id="L240">                            }</span>
                        }
                    }
                    try {
<span class="nc" id="L244">                        int retry = 1;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                        while (retry &gt;= 0) {</span>
                            try {
<span class="nc" id="L247">                                reLogin();</span>
<span class="nc" id="L248">                                break;</span>
<span class="nc" id="L249">                            } catch (LoginException le) {</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                                if (retry &gt; 0) {</span>
<span class="nc" id="L251">                                    --retry;</span>
                                    // sleep for 10 seconds.
                                    try {
<span class="nc" id="L254">                                        Thread.sleep(10 * 1000);</span>
<span class="nc" id="L255">                                    } catch (InterruptedException e) {</span>
<span class="nc" id="L256">                                        LOG.error(&quot;Interrupted during login retry after LoginException:&quot;, le);</span>
<span class="nc" id="L257">                                        throw le;</span>
<span class="nc" id="L258">                                    }</span>
                                } else {
<span class="nc" id="L260">                                    LOG.error(&quot;Could not refresh TGT for principal: {}.&quot;, principal, le);</span>
                                }
<span class="nc" id="L262">                            }</span>
                        }
<span class="nc" id="L264">                    } catch (LoginException le) {</span>
<span class="nc" id="L265">                        LOG.error(&quot;Failed to refresh TGT: refresh thread exiting now.&quot;, le);</span>
<span class="nc" id="L266">                        break;</span>
<span class="nc" id="L267">                    }</span>
<span class="nc" id="L268">                }</span>
<span class="nc" id="L269">            }</span>
        });
<span class="nc" id="L271">        t.setDaemon(true);</span>
<span class="nc" id="L272">    }</span>

    public void startThreadIfNeeded() {
        // thread object 't' will be null if a refresh thread is not needed.
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (t != null) {</span>
<span class="nc" id="L277">            t.start();</span>
        }
<span class="nc" id="L279">    }</span>

    public void shutdown() {
<span class="nc bnc" id="L282" title="All 4 branches missed.">        if ((t != null) &amp;&amp; (t.isAlive())) {</span>
<span class="nc" id="L283">            t.interrupt();</span>
            try {
<span class="nc" id="L285">                t.join();</span>
<span class="nc" id="L286">            } catch (InterruptedException e) {</span>
<span class="nc" id="L287">                LOG.warn(&quot;error while waiting for Login thread to shutdown.&quot;, e);</span>
<span class="nc" id="L288">            }</span>
        }
<span class="nc" id="L290">    }</span>

    public Subject getSubject() {
<span class="nc" id="L293">        return subject;</span>
    }

    public String getUserName() {
<span class="nc bnc" id="L297" title="All 4 branches missed.">        if (principal == null || principal.isEmpty()) {</span>
<span class="nc" id="L298">            return SYSTEM_USER;</span>
        }
<span class="nc" id="L300">        return principal;</span>
    }

    public String getLoginContextName() {
<span class="nc" id="L304">        return loginContextName;</span>
    }

    private synchronized LoginContext login(final String loginContextName) throws LoginException {
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (loginContextName == null) {</span>
<span class="nc" id="L309">            throw new LoginException(&quot;loginContext name (JAAS file section header) was null. &quot;</span>
                                     + &quot;Please check your java.security.login.auth.config (=&quot;
<span class="nc" id="L311">                                     + System.getProperty(&quot;java.security.login.auth.config&quot;)</span>
                                     + &quot;) and your &quot;
<span class="nc" id="L313">                                     + getLoginContextMessage());</span>
        }
<span class="nc" id="L315">        LoginContext loginContext = new LoginContext(loginContextName, callbackHandler);</span>
<span class="nc" id="L316">        loginContext.login();</span>
<span class="nc" id="L317">        LOG.info(&quot;{} successfully logged in.&quot;, loginContextName);</span>
<span class="nc" id="L318">        return loginContext;</span>
    }

    private String getLoginContextMessage() {
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (zkConfig instanceof ZKClientConfig) {</span>
<span class="nc" id="L323">            return ZKClientConfig.LOGIN_CONTEXT_NAME_KEY</span>
                   + &quot;(=&quot;
<span class="nc" id="L325">                   + zkConfig.getProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, ZKClientConfig.LOGIN_CONTEXT_NAME_KEY_DEFAULT)</span>
                   + &quot;)&quot;;
        } else {
<span class="nc" id="L328">            return ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY</span>
                   + &quot;(=&quot;
<span class="nc" id="L330">                   + System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME)</span>
                   + &quot;)&quot;;
        }
    }

    // c.f. org.apache.hadoop.security.UserGroupInformation.
    private long getRefreshTime(KerberosTicket tgt) {
<span class="nc" id="L337">        long start = tgt.getStartTime().getTime();</span>
<span class="nc" id="L338">        long expires = tgt.getEndTime().getTime();</span>
<span class="nc" id="L339">        LOG.info(&quot;TGT valid starting at:        {}&quot;, tgt.getStartTime().toString());</span>
<span class="nc" id="L340">        LOG.info(&quot;TGT expires:                  {}&quot;, tgt.getEndTime().toString());</span>
<span class="nc" id="L341">        long proposedRefresh = start + (long) ((expires - start)</span>
            * (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER
<span class="nc" id="L343">                * ThreadLocalRandom.current().nextDouble())));</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (proposedRefresh &gt; expires) {</span>
            // proposedRefresh is too far in the future: it's after ticket expires: simply return now.
<span class="nc" id="L346">            return Time.currentWallTime();</span>
        } else {
<span class="nc" id="L348">            return proposedRefresh;</span>
        }
    }

    private synchronized KerberosTicket getTGT() {
<span class="nc" id="L353">        Set&lt;KerberosTicket&gt; tickets = subject.getPrivateCredentials(KerberosTicket.class);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">        for (KerberosTicket ticket : tickets) {</span>
<span class="nc" id="L355">            KerberosPrincipal server = ticket.getServer();</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">            if (server.getName().equals(&quot;krbtgt/&quot; + server.getRealm() + &quot;@&quot; + server.getRealm())) {</span>
<span class="nc" id="L357">                LOG.debug(&quot;Client principal is \&quot;{}\&quot;.&quot;, ticket.getClient().getName());</span>
<span class="nc" id="L358">                LOG.debug(&quot;Server principal is \&quot;{}\&quot;.&quot;, ticket.getServer().getName());</span>
<span class="nc" id="L359">                return ticket;</span>
            }
<span class="nc" id="L361">        }</span>
<span class="nc" id="L362">        return null;</span>
    }

    private boolean hasSufficientTimeElapsed() {
<span class="nc" id="L366">        long now = Time.currentElapsedTime();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (now - getLastLogin() &lt; MIN_TIME_BEFORE_RELOGIN) {</span>
<span class="nc" id="L368">            LOG.warn(&quot;Not attempting to re-login since the last re-login was &quot;</span>
                     + &quot;attempted less than {} seconds before.&quot;,
<span class="nc" id="L370">                     (MIN_TIME_BEFORE_RELOGIN / 1000));</span>
<span class="nc" id="L371">            return false;</span>
        }
        // register most recent relogin attempt
<span class="nc" id="L374">        setLastLogin(now);</span>
<span class="nc" id="L375">        return true;</span>
    }

    /**
     * Returns login object
     * @return login
     */
    private LoginContext getLogin() {
<span class="nc" id="L383">        return login;</span>
    }

    /**
     * Set the login object
     * @param login
     */
    private void setLogin(LoginContext login) {
<span class="nc" id="L391">        this.login = login;</span>
<span class="nc" id="L392">    }</span>

    /**
     * Set the last login time.
     * @param time the number of milliseconds since the beginning of time
     */
    private void setLastLogin(long time) {
<span class="nc" id="L399">        lastLogin = time;</span>
<span class="nc" id="L400">    }</span>

    /**
     * Get the time of the last login.
     * @return the number of milliseconds since the beginning of time.
     */
    private long getLastLogin() {
<span class="nc" id="L407">        return lastLogin;</span>
    }

    /**
     * Re-login a principal. This method assumes that {@link #login(String)} has happened already.
     * @throws javax.security.auth.login.LoginException on a failure
     */
    // c.f. HADOOP-6559
    private synchronized void reLogin() throws LoginException {
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (!isKrbTicket) {</span>
<span class="nc" id="L417">            return;</span>
        }
<span class="nc" id="L419">        LoginContext login = getLogin();</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (login == null) {</span>
<span class="nc" id="L421">            throw new LoginException(&quot;login must be done first&quot;);</span>
        }
<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (!hasSufficientTimeElapsed()) {</span>
<span class="nc" id="L424">            return;</span>
        }
<span class="nc" id="L426">        LOG.info(&quot;Initiating logout for {}&quot;, principal);</span>
<span class="nc" id="L427">        synchronized (Login.class) {</span>
            //clear up the kerberos state. But the tokens are not cleared! As per
            //the Java kerberos login module code, only the kerberos credentials
            //are cleared
<span class="nc" id="L431">            login.logout();</span>
            //login and also update the subject field of this instance to
            //have the new credentials (pass it to the LoginContext constructor)
<span class="nc" id="L434">            login = new LoginContext(loginContextName, getSubject());</span>
<span class="nc" id="L435">            LOG.info(&quot;Initiating re-login for {}&quot;, principal);</span>
<span class="nc" id="L436">            login.login();</span>
<span class="nc" id="L437">            setLogin(login);</span>
<span class="nc" id="L438">        }</span>
<span class="nc" id="L439">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>