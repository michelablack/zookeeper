<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SnapStream.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server.persistence</a> &gt; <span class="el_source">SnapStream.java</span></div><h1>SnapStream.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server.persistence;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.zip.Adler32;
import java.util.zip.CheckedInputStream;
import java.util.zip.CheckedOutputStream;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;
import org.apache.jute.InputArchive;
import org.apache.jute.OutputArchive;
import org.apache.zookeeper.common.AtomicFileOutputStream;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xerial.snappy.SnappyCodec;
import org.xerial.snappy.SnappyInputStream;
import org.xerial.snappy.SnappyOutputStream;

/**
 * Represent the Stream used in serialize and deserialize the Snapshot.
 */
<span class="nc" id="L50">public class SnapStream {</span>

<span class="nc" id="L52">    private static final Logger LOG = LoggerFactory.getLogger(SnapStream.class);</span>

    public static final String ZOOKEEPER_SHAPSHOT_STREAM_MODE = &quot;zookeeper.snapshot.compression.method&quot;;

<span class="nc" id="L56">    private static StreamMode streamMode = StreamMode.fromString(</span>
<span class="nc" id="L57">        System.getProperty(ZOOKEEPER_SHAPSHOT_STREAM_MODE,</span>
<span class="nc" id="L58">                           StreamMode.DEFAULT_MODE.getName()));</span>

    static {
<span class="nc" id="L61">        LOG.info(&quot;{} = {}&quot;, ZOOKEEPER_SHAPSHOT_STREAM_MODE, streamMode);</span>
<span class="nc" id="L62">    }</span>

<span class="nc" id="L64">    public enum StreamMode {</span>
<span class="nc" id="L65">        GZIP(&quot;gz&quot;),</span>
<span class="nc" id="L66">        SNAPPY(&quot;snappy&quot;),</span>
<span class="nc" id="L67">        CHECKED(&quot;&quot;);</span>

<span class="nc" id="L69">        public static final StreamMode DEFAULT_MODE = CHECKED;</span>

        private String name;

<span class="nc" id="L73">        StreamMode(String name) {</span>
<span class="nc" id="L74">            this.name = name;</span>
<span class="nc" id="L75">        }</span>

        public String getName() {
<span class="nc" id="L78">            return name;</span>
        }

        public String getFileExtension() {
<span class="nc bnc" id="L82" title="All 2 branches missed.">            return name.isEmpty() ? &quot;&quot; : &quot;.&quot; + name;</span>
        }

        public static StreamMode fromString(String name) {
<span class="nc bnc" id="L86" title="All 2 branches missed.">            for (StreamMode c : values()) {</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">                if (c.getName().compareToIgnoreCase(name) == 0) {</span>
<span class="nc" id="L88">                    return c;</span>
                }
            }
<span class="nc" id="L91">            return DEFAULT_MODE;</span>
        }
    }

    /**
     * Return the CheckedInputStream based on the extension of the fileName.
     *
     * @param file the file the InputStream read from
     * @return the specific InputStream
     * @throws IOException
     */
    public static CheckedInputStream getInputStream(File file) throws IOException {
<span class="nc" id="L103">        FileInputStream fis = new FileInputStream(file);</span>
        InputStream is;
        try {
<span class="nc bnc" id="L106" title="All 3 branches missed.">            switch (getStreamMode(file.getName())) {</span>
                case GZIP:
<span class="nc" id="L108">                    is = new GZIPInputStream(fis);</span>
<span class="nc" id="L109">                    break;</span>
                case SNAPPY:
<span class="nc" id="L111">                    is = new SnappyInputStream(fis);</span>
<span class="nc" id="L112">                    break;</span>
                case CHECKED:
                default:
<span class="nc" id="L115">                    is = new BufferedInputStream(fis);</span>
            }
<span class="nc" id="L117">            return new CheckedInputStream(is, new Adler32());</span>
<span class="nc" id="L118">        } catch (IOException e) {</span>
<span class="nc" id="L119">            fis.close();</span>
<span class="nc" id="L120">            throw e;</span>
        }
    }

    /**
     * Return the OutputStream based on predefined stream mode.
     *
     * @param file the file the OutputStream writes to
     * @param fsync sync the file immediately after write
     * @return the specific OutputStream
     * @throws IOException
     */
    public static CheckedOutputStream getOutputStream(File file, boolean fsync) throws IOException {
<span class="nc bnc" id="L133" title="All 2 branches missed.">        OutputStream fos = fsync ? new AtomicFileOutputStream(file) : new FileOutputStream(file);</span>
        OutputStream os;
<span class="nc bnc" id="L135" title="All 3 branches missed.">        switch (streamMode) {</span>
        case GZIP:
            try {
<span class="nc" id="L138">                os = new GZIPOutputStream(fos);</span>
<span class="nc" id="L139">            } catch (IOException e) {</span>
<span class="nc" id="L140">                fos.close();</span>
<span class="nc" id="L141">                throw e;</span>
<span class="nc" id="L142">            }</span>
            break;
        case SNAPPY:
            // Unlike SnappyInputStream, the SnappyOutputStream
            // constructor cannot throw an IOException.
<span class="nc" id="L147">            os = new SnappyOutputStream(fos);</span>
<span class="nc" id="L148">            break;</span>
        case CHECKED:
        default:
<span class="nc" id="L151">            os = new BufferedOutputStream(fos);</span>
        }
<span class="nc" id="L153">        return new CheckedOutputStream(os, new Adler32());</span>
    }

    /**
     * Write specific seal to the OutputArchive and close the OutputStream.
     * Currently, only CheckedOutputStream will write it's checkSum to the
     * end of the stream.
     *
     */
    public static void sealStream(CheckedOutputStream os, OutputArchive oa) throws IOException {
<span class="nc" id="L163">        long val = os.getChecksum().getValue();</span>
<span class="nc" id="L164">        oa.writeLong(val, &quot;val&quot;);</span>
<span class="nc" id="L165">        oa.writeString(&quot;/&quot;, &quot;path&quot;);</span>
<span class="nc" id="L166">    }</span>

    /**
     * Verify the integrity of the seal, only CheckedInputStream will verify
     * the checkSum of the content.
     *
     */
    static void checkSealIntegrity(CheckedInputStream is, InputArchive ia) throws IOException {
<span class="nc" id="L174">        long checkSum = is.getChecksum().getValue();</span>
<span class="nc" id="L175">        long val = ia.readLong(&quot;val&quot;);</span>
<span class="nc" id="L176">        ia.readString(&quot;path&quot;);  // Read and ignore &quot;/&quot; written by SealStream.</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (val != checkSum) {</span>
<span class="nc" id="L178">            throw new IOException(&quot;CRC corruption&quot;);</span>
        }
<span class="nc" id="L180">    }</span>

    /**
     * Verifies that the file is a valid snapshot. Snapshot may be invalid if
     * it's incomplete as in a situation when the server dies while in the
     * process of storing a snapshot. Any files that are improperly formated
     * or corrupted are invalid. Any file that is not a snapshot is also an
     * invalid snapshot.
     *
     * @param file file to verify
     * @return true if the snapshot is valid
     * @throws IOException
     */
    public static boolean isValidSnapshot(File file) throws IOException {
<span class="nc bnc" id="L194" title="All 4 branches missed.">        if (file == null || Util.getZxidFromName(file.getName(), FileSnap.SNAPSHOT_FILE_PREFIX) == -1) {</span>
<span class="nc" id="L195">            return false;</span>
        }

<span class="nc" id="L198">        boolean isValid = false;</span>
<span class="nc bnc" id="L199" title="All 3 branches missed.">        switch (getStreamMode(file.getName())) {</span>
        case GZIP:
<span class="nc" id="L201">            isValid = isValidGZipStream(file);</span>
<span class="nc" id="L202">            break;</span>
        case SNAPPY:
<span class="nc" id="L204">            isValid = isValidSnappyStream(file);</span>
<span class="nc" id="L205">            break;</span>
        case CHECKED:
        default:
<span class="nc" id="L208">            isValid = isValidCheckedStream(file);</span>
        }
<span class="nc" id="L210">        return isValid;</span>
    }

    public static void setStreamMode(StreamMode mode) {
<span class="nc" id="L214">        streamMode = mode;</span>
<span class="nc" id="L215">    }</span>

    public static StreamMode getStreamMode() {
<span class="nc" id="L218">        return streamMode;</span>
    }

    /**
     * Detect the stream mode from file name extension
     *
     * @param fileName
     * @return the stream mode detected
     */
    public static StreamMode getStreamMode(String fileName) {
<span class="nc" id="L228">        String[] splitSnapName = fileName.split(&quot;\\.&quot;);</span>

        // Use file extension to detect format


<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (splitSnapName.length &gt; 1) {</span>
<span class="nc" id="L234">            String mode = splitSnapName[splitSnapName.length - 1];</span>
<span class="nc" id="L235">            return StreamMode.fromString(mode);</span>
        }

<span class="nc" id="L238">        return StreamMode.CHECKED;</span>
    }

    /**
     * Certify the GZip stream integrity by checking the header
     * for the GZip magic string
     *
     * @param f file to verify
     * @return true if it has the correct GZip magic string
     * @throws IOException
     */
    private static boolean isValidGZipStream(File f) throws IOException {
<span class="nc" id="L250">        byte[] byteArray = new byte[2];</span>
<span class="nc" id="L251">        try (FileInputStream fis = new FileInputStream(f)) {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">            if (2 != fis.read(byteArray, 0, 2)) {</span>
<span class="nc" id="L253">                LOG.error(&quot;Read incorrect number of bytes from {}&quot;, f.getName());</span>
<span class="nc" id="L254">                return false;</span>
            }
<span class="nc" id="L256">            ByteBuffer bb = ByteBuffer.wrap(byteArray);</span>
<span class="nc" id="L257">            byte[] magicHeader = new byte[2];</span>
<span class="nc" id="L258">            bb.get(magicHeader, 0, 2);</span>
<span class="nc" id="L259">            int magic = magicHeader[0] &amp; 0xff | ((magicHeader[1] &lt;&lt; 8) &amp; 0xff00);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            return magic == GZIPInputStream.GZIP_MAGIC;</span>
<span class="nc" id="L261">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L262">            LOG.error(&quot;Unable to open file {}&quot;, f.getName(), e);</span>
<span class="nc" id="L263">            return false;</span>
        }
    }

    /**
     * Certify the Snappy stream integrity by checking the header
     * for the Snappy magic string
     *
     * @param f file to verify
     * @return true if it has the correct Snappy magic string
     * @throws IOException
     */
    private static boolean isValidSnappyStream(File f) throws IOException {
<span class="nc" id="L276">        byte[] byteArray = new byte[SnappyCodec.MAGIC_LEN];</span>
<span class="nc" id="L277">        try (FileInputStream fis = new FileInputStream(f)) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (SnappyCodec.MAGIC_LEN != fis.read(byteArray, 0, SnappyCodec.MAGIC_LEN)) {</span>
<span class="nc" id="L279">                LOG.error(&quot;Read incorrect number of bytes from {}&quot;, f.getName());</span>
<span class="nc" id="L280">                return false;</span>
            }
<span class="nc" id="L282">            ByteBuffer bb = ByteBuffer.wrap(byteArray);</span>
<span class="nc" id="L283">            byte[] magicHeader = new byte[SnappyCodec.MAGIC_LEN];</span>
<span class="nc" id="L284">            bb.get(magicHeader, 0, SnappyCodec.MAGIC_LEN);</span>
<span class="nc" id="L285">            return Arrays.equals(magicHeader, SnappyCodec.getMagicHeader());</span>
<span class="nc" id="L286">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L287">            LOG.error(&quot;Unable to open file {}&quot;, f.getName(), e);</span>
<span class="nc" id="L288">            return false;</span>
        }
    }

    /**
     * Certify the Checked stream integrity by checking the header
     * length and format
     *
     * @param f file to verify
     * @return true if it has the correct header
     * @throws IOException
     */
    private static boolean isValidCheckedStream(File f) throws IOException {
<span class="nc" id="L301">        try (RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;)) {</span>
            // including the header and the last / bytes
            // the snapshot should be at least 10 bytes
<span class="nc bnc" id="L304" title="All 2 branches missed.">            if (raf.length() &lt; 10) {</span>
<span class="nc" id="L305">                return false;</span>
            }

<span class="nc" id="L308">            raf.seek(raf.length() - 5);</span>
<span class="nc" id="L309">            byte[] bytes = new byte[5];</span>
<span class="nc" id="L310">            int readlen = 0;</span>
            int l;
<span class="nc bnc" id="L312" title="All 4 branches missed.">            while (readlen &lt; 5 &amp;&amp; (l = raf.read(bytes, readlen, bytes.length - readlen)) &gt;= 0) {</span>
<span class="nc" id="L313">                readlen += l;</span>
            }
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (readlen != bytes.length) {</span>
<span class="nc" id="L316">                LOG.info(&quot;Invalid snapshot {}. too short, len = {} bytes&quot;, f.getName(), readlen);</span>
<span class="nc" id="L317">                return false;</span>
            }
<span class="nc" id="L319">            ByteBuffer bb = ByteBuffer.wrap(bytes);</span>
<span class="nc" id="L320">            int len = bb.getInt();</span>
<span class="nc" id="L321">            byte b = bb.get();</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">            if (len != 1 || b != '/') {</span>
<span class="nc" id="L323">                LOG.info(&quot;Invalid snapshot {}. len = {}, byte = {}&quot;, f.getName(), len, (b &amp; 0xff));</span>
<span class="nc" id="L324">                return false;</span>
            }
<span class="nc" id="L326">        }</span>

<span class="nc" id="L328">        return true;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>