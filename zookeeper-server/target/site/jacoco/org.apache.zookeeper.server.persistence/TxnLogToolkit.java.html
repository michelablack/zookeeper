<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TxnLogToolkit.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server.persistence</a> &gt; <span class="el_source">TxnLogToolkit.java</span></div><h1>TxnLogToolkit.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server.persistence;

import static org.apache.zookeeper.server.persistence.FileTxnLog.TXNLOG_MAGIC;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.Closeable;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.text.DateFormat;
import java.util.Date;
import java.util.List;
import java.util.Scanner;
import java.util.zip.Adler32;
import java.util.zip.Checksum;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.jute.BinaryInputArchive;
import org.apache.jute.BinaryOutputArchive;
import org.apache.jute.Record;
import org.apache.zookeeper.server.ExitCode;
import org.apache.zookeeper.server.Request;
import org.apache.zookeeper.server.TxnLogEntry;
import org.apache.zookeeper.server.util.LogChopper;
import org.apache.zookeeper.server.util.SerializeUtils;
import org.apache.zookeeper.txn.CreateContainerTxn;
import org.apache.zookeeper.txn.CreateTTLTxn;
import org.apache.zookeeper.txn.CreateTxn;
import org.apache.zookeeper.txn.MultiTxn;
import org.apache.zookeeper.txn.SetDataTxn;
import org.apache.zookeeper.txn.Txn;
import org.apache.zookeeper.txn.TxnHeader;
import org.apache.zookeeper.util.ServiceUtils;

public class TxnLogToolkit implements Closeable {

    static class TxnLogToolkitException extends Exception {

        private static final long serialVersionUID = 1L;
        private int exitCode;

        TxnLogToolkitException(int exitCode, String message, Object... params) {
<span class="nc" id="L72">            super(String.format(message, params));</span>
<span class="nc" id="L73">            this.exitCode = exitCode;</span>
<span class="nc" id="L74">        }</span>

        int getExitCode() {
<span class="nc" id="L77">            return exitCode;</span>
        }

    }

    static class TxnLogToolkitParseException extends TxnLogToolkitException {

        private static final long serialVersionUID = 1L;
        private Options options;

        TxnLogToolkitParseException(Options options, int exitCode, String message, Object... params) {
<span class="nc" id="L88">            super(exitCode, message, params);</span>
<span class="nc" id="L89">            this.options = options;</span>
<span class="nc" id="L90">        }</span>

        Options getOptions() {
<span class="nc" id="L93">            return options;</span>
        }

    }

    private File txnLogFile;
<span class="nc" id="L99">    private boolean recoveryMode = false;</span>
<span class="nc" id="L100">    private boolean verbose = false;</span>
    private FileInputStream txnFis;
    private BinaryInputArchive logStream;

    // Recovery mode
<span class="nc" id="L105">    private int crcFixed = 0;</span>
    private FileOutputStream recoveryFos;
    private BinaryOutputArchive recoveryOa;
    private File recoveryLogFile;
<span class="nc" id="L109">    private FilePadding filePadding = new FilePadding();</span>
<span class="nc" id="L110">    private boolean force = false;</span>

    // chop mode
<span class="nc" id="L113">    private long zxid = -1L;</span>

    /**
     * @param args Command line arguments
     */
    public static void main(String[] args) throws Exception {
<span class="nc" id="L119">        try (final TxnLogToolkit lt = parseCommandLine(args)) {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">            if (lt.isDumpMode()) {</span>
<span class="nc" id="L121">                lt.dump(new Scanner(System.in));</span>
<span class="nc" id="L122">                lt.printStat();</span>
            } else {
<span class="nc" id="L124">                lt.chop();</span>
            }
<span class="nc" id="L126">        } catch (TxnLogToolkitParseException e) {</span>
<span class="nc" id="L127">            System.err.println(e.getMessage() + &quot;\n&quot;);</span>
<span class="nc" id="L128">            printHelpAndExit(e.getExitCode(), e.getOptions());</span>
<span class="nc" id="L129">        } catch (TxnLogToolkitException e) {</span>
<span class="nc" id="L130">            System.err.println(e.getMessage());</span>
<span class="nc" id="L131">            ServiceUtils.requestSystemExit(e.getExitCode());</span>
<span class="nc" id="L132">        }</span>
<span class="nc" id="L133">    }</span>

    public TxnLogToolkit(
        boolean recoveryMode,
        boolean verbose,
        String txnLogFileName,
<span class="nc" id="L139">        boolean force) throws FileNotFoundException, TxnLogToolkitException {</span>
<span class="nc" id="L140">        this.recoveryMode = recoveryMode;</span>
<span class="nc" id="L141">        this.verbose = verbose;</span>
<span class="nc" id="L142">        this.force = force;</span>
<span class="nc" id="L143">        txnLogFile = loadTxnFile(txnLogFileName);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (recoveryMode) {</span>
<span class="nc" id="L145">            recoveryLogFile = new File(txnLogFile.toString() + &quot;.fixed&quot;);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">            if (recoveryLogFile.exists()) {</span>
<span class="nc" id="L147">                throw new TxnLogToolkitException(</span>
<span class="nc" id="L148">                    ExitCode.UNEXPECTED_ERROR.getValue(),</span>
                    &quot;Recovery file %s already exists or not writable&quot;,
                    recoveryLogFile);
            }
        }

<span class="nc" id="L154">        openTxnLogFile();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (recoveryMode) {</span>
<span class="nc" id="L156">            openRecoveryFile();</span>
        }
<span class="nc" id="L158">    }</span>

<span class="nc" id="L160">    public TxnLogToolkit(String txnLogFileName, String zxidName) throws TxnLogToolkitException {</span>
<span class="nc" id="L161">        txnLogFile = loadTxnFile(txnLogFileName);</span>
<span class="nc" id="L162">        zxid = Long.decode(zxidName);</span>
<span class="nc" id="L163">    }</span>

    private File loadTxnFile(String txnLogFileName) throws TxnLogToolkitException {
<span class="nc" id="L166">        File logFile = new File(txnLogFileName);</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">        if (!logFile.exists() || !logFile.canRead()) {</span>
<span class="nc" id="L168">            throw new TxnLogToolkitException(</span>
<span class="nc" id="L169">                ExitCode.UNEXPECTED_ERROR.getValue(),</span>
                &quot;File doesn't exist or not readable: %s&quot;,
                logFile);
        }
<span class="nc" id="L173">        return logFile;</span>
    }

    public void dump(Scanner scanner) throws Exception {
<span class="nc" id="L177">        crcFixed = 0;</span>

<span class="nc" id="L179">        FileHeader fhdr = new FileHeader();</span>
<span class="nc" id="L180">        fhdr.deserialize(logStream, &quot;fileheader&quot;);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (fhdr.getMagic() != TXNLOG_MAGIC) {</span>
<span class="nc" id="L182">            throw new TxnLogToolkitException(</span>
<span class="nc" id="L183">                ExitCode.INVALID_INVOCATION.getValue(),</span>
                &quot;Invalid magic number for %s&quot;,
<span class="nc" id="L185">                txnLogFile.getName());</span>
        }
<span class="nc" id="L187">        System.out.println(&quot;ZooKeeper Transactional Log File with dbid &quot; + fhdr.getDbid()</span>
<span class="nc" id="L188">                           + &quot; txnlog format version &quot; + fhdr.getVersion());</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (recoveryMode) {</span>
<span class="nc" id="L191">            fhdr.serialize(recoveryOa, &quot;fileheader&quot;);</span>
<span class="nc" id="L192">            recoveryFos.flush();</span>
<span class="nc" id="L193">            filePadding.setCurrentSize(recoveryFos.getChannel().position());</span>
        }

<span class="nc" id="L196">        int count = 0;</span>
        while (true) {
            long crcValue;
            byte[] bytes;
            try {
<span class="nc" id="L201">                crcValue = logStream.readLong(&quot;crcvalue&quot;);</span>
<span class="nc" id="L202">                bytes = logStream.readBuffer(&quot;txnEntry&quot;);</span>
<span class="nc" id="L203">            } catch (EOFException e) {</span>
<span class="nc" id="L204">                System.out.println(&quot;EOF reached after &quot; + count + &quot; txns.&quot;);</span>
<span class="nc" id="L205">                return;</span>
<span class="nc" id="L206">            }</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (bytes.length == 0) {</span>
                // Since we preallocate, we define EOF to be an
                // empty transaction
<span class="nc" id="L210">                System.out.println(&quot;EOF reached after &quot; + count + &quot; txns.&quot;);</span>
<span class="nc" id="L211">                return;</span>
            }
<span class="nc" id="L213">            Checksum crc = new Adler32();</span>
<span class="nc" id="L214">            crc.update(bytes, 0, bytes.length);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">            if (crcValue != crc.getValue()) {</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                if (recoveryMode) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                    if (!force) {</span>
<span class="nc" id="L218">                        printTxn(bytes, &quot;CRC ERROR&quot;);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                        if (askForFix(scanner)) {</span>
<span class="nc" id="L220">                            crcValue = crc.getValue();</span>
<span class="nc" id="L221">                            ++crcFixed;</span>
                        }
                    } else {
<span class="nc" id="L224">                        crcValue = crc.getValue();</span>
<span class="nc" id="L225">                        printTxn(bytes, &quot;CRC FIXED&quot;);</span>
<span class="nc" id="L226">                        ++crcFixed;</span>
                    }
                } else {
<span class="nc" id="L229">                    printTxn(bytes, &quot;CRC ERROR&quot;);</span>
                }
            }
<span class="nc bnc" id="L232" title="All 4 branches missed.">            if (!recoveryMode || verbose) {</span>
<span class="nc" id="L233">                printTxn(bytes);</span>
            }
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (logStream.readByte(&quot;EOR&quot;) != 'B') {</span>
<span class="nc" id="L236">                throw new TxnLogToolkitException(ExitCode.UNEXPECTED_ERROR.getValue(), &quot;Last transaction was partial.&quot;);</span>
            }
<span class="nc bnc" id="L238" title="All 2 branches missed.">            if (recoveryMode) {</span>
<span class="nc" id="L239">                filePadding.padFile(recoveryFos.getChannel());</span>
<span class="nc" id="L240">                recoveryOa.writeLong(crcValue, &quot;crcvalue&quot;);</span>
<span class="nc" id="L241">                recoveryOa.writeBuffer(bytes, &quot;txnEntry&quot;);</span>
<span class="nc" id="L242">                recoveryOa.writeByte((byte) 'B', &quot;EOR&quot;);</span>
            }
<span class="nc" id="L244">            count++;</span>
<span class="nc" id="L245">        }</span>
    }

    public void chop() {
<span class="nc" id="L249">        File targetFile = new File(txnLogFile.getParentFile(), txnLogFile.getName() + &quot;.chopped&quot; + zxid);</span>
<span class="nc" id="L250">        try (InputStream is = new BufferedInputStream(new FileInputStream(txnLogFile));</span>
<span class="nc" id="L251">             OutputStream os = new BufferedOutputStream(new FileOutputStream(targetFile))) {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">            if (!LogChopper.chop(is, os, zxid)) {</span>
<span class="nc" id="L253">                throw new TxnLogToolkitException(</span>
<span class="nc" id="L254">                    ExitCode.INVALID_INVOCATION.getValue(),</span>
                    &quot;Failed to chop %s&quot;,
<span class="nc" id="L256">                    txnLogFile.getName());</span>
            }
<span class="nc" id="L258">        } catch (Exception e) {</span>
<span class="nc" id="L259">            System.out.println(&quot;Got exception: &quot; + e.getMessage());</span>
<span class="nc" id="L260">        }</span>
<span class="nc" id="L261">    }</span>

    public boolean isDumpMode() {
<span class="nc bnc" id="L264" title="All 2 branches missed.">        return zxid &lt; 0;</span>
    }

    private boolean askForFix(Scanner scanner) throws TxnLogToolkitException {
        while (true) {
<span class="nc" id="L269">            System.out.print(&quot;Would you like to fix it (Yes/No/Abort) ? &quot;);</span>
<span class="nc" id="L270">            char answer = Character.toUpperCase(scanner.next().charAt(0));</span>
<span class="nc bnc" id="L271" title="All 4 branches missed.">            switch (answer) {</span>
            case 'Y':
<span class="nc" id="L273">                return true;</span>
            case 'N':
<span class="nc" id="L275">                return false;</span>
            case 'A':
<span class="nc" id="L277">                throw new TxnLogToolkitException(ExitCode.EXECUTION_FINISHED.getValue(), &quot;Recovery aborted.&quot;);</span>
            }
<span class="nc" id="L279">        }</span>
    }

    private void printTxn(byte[] bytes) throws IOException {
<span class="nc" id="L283">        printTxn(bytes, &quot;&quot;);</span>
<span class="nc" id="L284">    }</span>

    private void printTxn(byte[] bytes, String prefix) throws IOException {
<span class="nc" id="L287">        TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);</span>
<span class="nc" id="L288">        TxnHeader hdr = logEntry.getHeader();</span>
<span class="nc" id="L289">        Record txn = logEntry.getTxn();</span>
<span class="nc" id="L290">        String txnStr = getFormattedTxnStr(txn);</span>
<span class="nc" id="L291">        String txns = String.format(</span>
            &quot;%s session 0x%s cxid 0x%s zxid 0x%s %s %s&quot;,
<span class="nc" id="L293">            DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(hdr.getTime())),</span>
<span class="nc" id="L294">            Long.toHexString(hdr.getClientId()),</span>
<span class="nc" id="L295">            Long.toHexString(hdr.getCxid()),</span>
<span class="nc" id="L296">            Long.toHexString(hdr.getZxid()),</span>
<span class="nc" id="L297">                Request.op2String(hdr.getType()),</span>
            txnStr);
<span class="nc bnc" id="L299" title="All 4 branches missed.">        if (prefix != null &amp;&amp; !&quot;&quot;.equals(prefix.trim())) {</span>
<span class="nc" id="L300">            System.out.print(prefix + &quot; - &quot;);</span>
        }
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (txns.endsWith(&quot;\n&quot;)) {</span>
<span class="nc" id="L303">            System.out.print(txns);</span>
        } else {
<span class="nc" id="L305">            System.out.println(txns);</span>
        }
<span class="nc" id="L307">    }</span>

    /**
     * get the formatted string from the txn.
     * @param txn transaction log data
     * @return the formatted string
     */
    private static String getFormattedTxnStr(Record txn) throws IOException {
<span class="nc" id="L315">        StringBuilder txnData = new StringBuilder();</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (txn == null) {</span>
<span class="nc" id="L317">            return txnData.toString();</span>
        }
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (txn instanceof CreateTxn) {</span>
<span class="nc" id="L320">            CreateTxn createTxn = ((CreateTxn) txn);</span>
<span class="nc" id="L321">            txnData.append(createTxn.getPath() + &quot;,&quot; + checkNullToEmpty(createTxn.getData()))</span>
<span class="nc" id="L322">                   .append(&quot;,&quot; + createTxn.getAcl() + &quot;,&quot; + createTxn.getEphemeral())</span>
<span class="nc" id="L323">                   .append(&quot;,&quot; + createTxn.getParentCVersion());</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">        } else if (txn instanceof SetDataTxn) {</span>
<span class="nc" id="L325">            SetDataTxn setDataTxn = ((SetDataTxn) txn);</span>
<span class="nc" id="L326">            txnData.append(setDataTxn.getPath() + &quot;,&quot; + checkNullToEmpty(setDataTxn.getData()))</span>
<span class="nc" id="L327">                   .append(&quot;,&quot; + setDataTxn.getVersion());</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        } else if (txn instanceof CreateContainerTxn) {</span>
<span class="nc" id="L329">            CreateContainerTxn createContainerTxn = ((CreateContainerTxn) txn);</span>
<span class="nc" id="L330">            txnData.append(createContainerTxn.getPath() + &quot;,&quot; + checkNullToEmpty(createContainerTxn.getData()))</span>
<span class="nc" id="L331">                   .append(&quot;,&quot; + createContainerTxn.getAcl() + &quot;,&quot; + createContainerTxn.getParentCVersion());</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        } else if (txn instanceof CreateTTLTxn) {</span>
<span class="nc" id="L333">            CreateTTLTxn createTTLTxn = ((CreateTTLTxn) txn);</span>
<span class="nc" id="L334">            txnData.append(createTTLTxn.getPath() + &quot;,&quot; + checkNullToEmpty(createTTLTxn.getData()))</span>
<span class="nc" id="L335">                   .append(&quot;,&quot; + createTTLTxn.getAcl() + &quot;,&quot; + createTTLTxn.getParentCVersion())</span>
<span class="nc" id="L336">                   .append(&quot;,&quot; + createTTLTxn.getTtl());</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        } else if (txn instanceof MultiTxn) {</span>
<span class="nc" id="L338">            MultiTxn multiTxn = ((MultiTxn) txn);</span>
<span class="nc" id="L339">            List&lt;Txn&gt; txnList = multiTxn.getTxns();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            for (int i = 0; i &lt; txnList.size(); i++) {</span>
<span class="nc" id="L341">                Txn t = txnList.get(i);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                if (i == 0) {</span>
<span class="nc" id="L343">                    txnData.append(Request.op2String(t.getType()) + &quot;:&quot; + checkNullToEmpty(t.getData()));</span>
                } else {
<span class="nc" id="L345">                    txnData.append(&quot;;&quot; + Request.op2String(t.getType()) + &quot;:&quot; + checkNullToEmpty(t.getData()));</span>
                }
            }
<span class="nc" id="L348">        } else {</span>
<span class="nc" id="L349">            txnData.append(txn.toString());</span>
        }

<span class="nc" id="L352">        return txnData.toString();</span>
    }

    private static String checkNullToEmpty(byte[] data) throws IOException {
<span class="nc bnc" id="L356" title="All 4 branches missed.">        if (data == null || data.length == 0) {</span>
<span class="nc" id="L357">            return &quot;&quot;;</span>
        }

<span class="nc" id="L360">        return new String(data, StandardCharsets.UTF_8);</span>
    }

    private void openTxnLogFile() throws FileNotFoundException {
<span class="nc" id="L364">        txnFis = new FileInputStream(txnLogFile);</span>
<span class="nc" id="L365">        logStream = BinaryInputArchive.getArchive(txnFis);</span>
<span class="nc" id="L366">    }</span>

    private void closeTxnLogFile() throws IOException {
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (txnFis != null) {</span>
<span class="nc" id="L370">            txnFis.close();</span>
        }
<span class="nc" id="L372">    }</span>

    private void openRecoveryFile() throws FileNotFoundException {
<span class="nc" id="L375">        recoveryFos = new FileOutputStream(recoveryLogFile);</span>
<span class="nc" id="L376">        recoveryOa = BinaryOutputArchive.getArchive(recoveryFos);</span>
<span class="nc" id="L377">    }</span>

    private void closeRecoveryFile() throws IOException {
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (recoveryFos != null) {</span>
<span class="nc" id="L381">            recoveryFos.close();</span>
        }
<span class="nc" id="L383">    }</span>

    private static TxnLogToolkit parseCommandLine(String[] args) throws TxnLogToolkitException, FileNotFoundException {
<span class="nc" id="L386">        CommandLineParser parser = new DefaultParser();</span>
<span class="nc" id="L387">        Options options = new Options();</span>

<span class="nc" id="L389">        Option helpOpt = new Option(&quot;h&quot;, &quot;help&quot;, false, &quot;Print help message&quot;);</span>
<span class="nc" id="L390">        options.addOption(helpOpt);</span>

<span class="nc" id="L392">        Option recoverOpt = new Option(&quot;r&quot;, &quot;recover&quot;, false, &quot;Recovery mode. Re-calculate CRC for broken entries.&quot;);</span>
<span class="nc" id="L393">        options.addOption(recoverOpt);</span>

<span class="nc" id="L395">        Option quietOpt = new Option(&quot;v&quot;, &quot;verbose&quot;, false, &quot;Be verbose in recovery mode: print all entries, not just fixed ones.&quot;);</span>
<span class="nc" id="L396">        options.addOption(quietOpt);</span>

<span class="nc" id="L398">        Option dumpOpt = new Option(&quot;d&quot;, &quot;dump&quot;, false, &quot;Dump mode. Dump all entries of the log file with printing the content of a nodepath (default)&quot;);</span>
<span class="nc" id="L399">        options.addOption(dumpOpt);</span>

<span class="nc" id="L401">        Option forceOpt = new Option(&quot;y&quot;, &quot;yes&quot;, false, &quot;Non-interactive mode: repair all CRC errors without asking&quot;);</span>
<span class="nc" id="L402">        options.addOption(forceOpt);</span>

        // Chop mode options
<span class="nc" id="L405">        Option chopOpt = new Option(&quot;c&quot;, &quot;chop&quot;, false, &quot;Chop mode. Chop txn file to a zxid.&quot;);</span>
<span class="nc" id="L406">        Option zxidOpt = new Option(&quot;z&quot;, &quot;zxid&quot;, true, &quot;Used with chop. Zxid to which to chop.&quot;);</span>
<span class="nc" id="L407">        options.addOption(chopOpt);</span>
<span class="nc" id="L408">        options.addOption(zxidOpt);</span>

        try {
<span class="nc" id="L411">            CommandLine cli = parser.parse(options, args);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (cli.hasOption(&quot;help&quot;)) {</span>
<span class="nc" id="L413">                printHelpAndExit(0, options);</span>
            }
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (cli.getArgs().length &lt; 1) {</span>
<span class="nc" id="L416">                printHelpAndExit(1, options);</span>
            }
<span class="nc bnc" id="L418" title="All 4 branches missed.">            if (cli.hasOption(&quot;chop&quot;) &amp;&amp; cli.hasOption(&quot;zxid&quot;)) {</span>
<span class="nc" id="L419">                return new TxnLogToolkit(cli.getArgs()[0], cli.getOptionValue(&quot;zxid&quot;));</span>
            }
<span class="nc" id="L421">            return new TxnLogToolkit(cli.hasOption(&quot;recover&quot;), cli.hasOption(&quot;verbose&quot;), cli.getArgs()[0], cli.hasOption(&quot;yes&quot;));</span>
<span class="nc" id="L422">        } catch (ParseException e) {</span>
<span class="nc" id="L423">            throw new TxnLogToolkitParseException(options, ExitCode.UNEXPECTED_ERROR.getValue(), e.getMessage());</span>
        }
    }

    private static void printHelpAndExit(int exitCode, Options options) {
<span class="nc" id="L428">        HelpFormatter help = new HelpFormatter();</span>
<span class="nc" id="L429">        help.printHelp(120, &quot;TxnLogToolkit [-dhrvc] &lt;txn_log_file_name&gt; (-z &lt;zxid&gt;)&quot;, &quot;&quot;, options, &quot;&quot;);</span>
<span class="nc" id="L430">        ServiceUtils.requestSystemExit(exitCode);</span>
<span class="nc" id="L431">    }</span>

    private void printStat() {
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (recoveryMode) {</span>
<span class="nc" id="L435">            System.out.printf(&quot;Recovery file %s has been written with %d fixed CRC error(s)%n&quot;, recoveryLogFile, crcFixed);</span>
        }
<span class="nc" id="L437">    }</span>

    @Override
    public void close() throws IOException {
<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (recoveryMode) {</span>
<span class="nc" id="L442">            closeRecoveryFile();</span>
        }
<span class="nc" id="L444">        closeTxnLogFile();</span>
<span class="nc" id="L445">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>