<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileChangeWatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.common</a> &gt; <span class="el_source">FileChangeWatcher.java</span></div><h1>FileChangeWatcher.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.common;

import java.io.IOException;
import java.nio.file.ClosedWatchServiceException;
import java.nio.file.FileSystem;
import java.nio.file.Path;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.util.function.Consumer;
import org.apache.zookeeper.server.ZooKeeperThread;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Instances of this class can be used to watch a directory for file changes. When a file is added to, deleted from,
 * or is modified in the given directory, the callback provided by the user will be called from a background thread.
 * Some things to keep in mind:
 * &lt;ul&gt;
 * &lt;li&gt;The callback should be thread-safe.&lt;/li&gt;
 * &lt;li&gt;Changes that happen around the time the thread is started may be missed.&lt;/li&gt;
 * &lt;li&gt;There is a delay between a file changing and the callback firing.&lt;/li&gt;
 * &lt;li&gt;The watch is not recursive - changes to subdirectories will not trigger a callback.&lt;/li&gt;
 * &lt;/ul&gt;
 */
public final class FileChangeWatcher {

<span class="nc" id="L47">    private static final Logger LOG = LoggerFactory.getLogger(FileChangeWatcher.class);</span>

<span class="nc" id="L49">    public enum State {</span>
<span class="nc" id="L50">        NEW,      // object created but start() not called yet</span>
<span class="nc" id="L51">        STARTING, // start() called but background thread has not entered main loop</span>
<span class="nc" id="L52">        RUNNING,  // background thread is running</span>
<span class="nc" id="L53">        STOPPING, // stop() called but background thread has not exited main loop</span>
<span class="nc" id="L54">        STOPPED   // stop() called and background thread has exited, or background thread crashed</span>
    }

    private final WatcherThread watcherThread;
    private State state; // protected by synchronized(this)

    /**
     * Creates a watcher that watches &lt;code&gt;dirPath&lt;/code&gt; and invokes &lt;code&gt;callback&lt;/code&gt; on changes.
     *
     * @param dirPath the directory to watch.
     * @param callback the callback to invoke with events. &lt;code&gt;event.kind()&lt;/code&gt; will return the type of event,
     *                 and &lt;code&gt;event.context()&lt;/code&gt; will return the filename relative to &lt;code&gt;dirPath&lt;/code&gt;.
     * @throws IOException if there is an error creating the WatchService.
     */
<span class="nc" id="L68">    public FileChangeWatcher(Path dirPath, Consumer&lt;WatchEvent&lt;?&gt;&gt; callback) throws IOException {</span>
<span class="nc" id="L69">        FileSystem fs = dirPath.getFileSystem();</span>
<span class="nc" id="L70">        WatchService watchService = fs.newWatchService();</span>

<span class="nc" id="L72">        LOG.debug(&quot;Registering with watch service: {}&quot;, dirPath);</span>

<span class="nc" id="L74">        dirPath.register(watchService, new WatchEvent.Kind&lt;?&gt;[]{StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.OVERFLOW});</span>
<span class="nc" id="L75">        state = State.NEW;</span>
<span class="nc" id="L76">        this.watcherThread = new WatcherThread(watchService, callback);</span>
<span class="nc" id="L77">        this.watcherThread.setDaemon(true);</span>
<span class="nc" id="L78">    }</span>

    /**
     * Returns the current {@link FileChangeWatcher.State}.
     * @return the current state.
     */
    public synchronized State getState() {
<span class="nc" id="L85">        return state;</span>
    }

    /**
     * Blocks until the current state becomes &lt;code&gt;desiredState&lt;/code&gt;.
     * Currently only used by tests, thus package-private.
     * @param desiredState the desired state.
     * @throws InterruptedException if the current thread gets interrupted.
     */
    synchronized void waitForState(State desiredState) throws InterruptedException {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        while (this.state != desiredState) {</span>
<span class="nc" id="L96">            this.wait();</span>
        }
<span class="nc" id="L98">    }</span>

    /**
     * Sets the state to &lt;code&gt;newState&lt;/code&gt;.
     * @param newState the new state.
     */
    private synchronized void setState(State newState) {
<span class="nc" id="L105">        state = newState;</span>
<span class="nc" id="L106">        this.notifyAll();</span>
<span class="nc" id="L107">    }</span>

    /**
     * Atomically sets the state to &lt;code&gt;update&lt;/code&gt; if and only if the
     * state is currently &lt;code&gt;expected&lt;/code&gt;.
     * @param expected the expected state.
     * @param update the new state.
     * @return true if the update succeeds, or false if the current state
     *         does not equal &lt;code&gt;expected&lt;/code&gt;.
     */
    private synchronized boolean compareAndSetState(State expected, State update) {
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (state == expected) {</span>
<span class="nc" id="L119">            setState(update);</span>
<span class="nc" id="L120">            return true;</span>
        } else {
<span class="nc" id="L122">            return false;</span>
        }
    }

    /**
     * Atomically sets the state to &lt;code&gt;update&lt;/code&gt; if and only if the
     * state is currently one of &lt;code&gt;expectedStates&lt;/code&gt;.
     * @param expectedStates the expected states.
     * @param update the new state.
     * @return true if the update succeeds, or false if the current state
     *         does not equal any of the &lt;code&gt;expectedStates&lt;/code&gt;.
     */
    private synchronized boolean compareAndSetState(State[] expectedStates, State update) {
<span class="nc bnc" id="L135" title="All 2 branches missed.">        for (State expected : expectedStates) {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            if (state == expected) {</span>
<span class="nc" id="L137">                setState(update);</span>
<span class="nc" id="L138">                return true;</span>
            }
        }
<span class="nc" id="L141">        return false;</span>
    }

    /**
     * Tells the background thread to start. Does not wait for it to be running.
     * Calling this method more than once has no effect.
     */
    public void start() {
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (!compareAndSetState(State.NEW, State.STARTING)) {</span>
            // If previous state was not NEW, start() has already been called.
<span class="nc" id="L151">            return;</span>
        }
<span class="nc" id="L153">        this.watcherThread.start();</span>
<span class="nc" id="L154">    }</span>

    /**
     * Tells the background thread to stop. Does not wait for it to exit.
     */
    public void stop() {
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (compareAndSetState(new State[]{State.RUNNING, State.STARTING}, State.STOPPING)) {</span>
<span class="nc" id="L161">            watcherThread.interrupt();</span>
        }
<span class="nc" id="L163">    }</span>

    /**
     * Inner class that implements the watcher thread logic.
     */
    private class WatcherThread extends ZooKeeperThread {

        private static final String THREAD_NAME = &quot;FileChangeWatcher&quot;;

        final WatchService watchService;
        final Consumer&lt;WatchEvent&lt;?&gt;&gt; callback;

<span class="nc" id="L175">        WatcherThread(WatchService watchService, Consumer&lt;WatchEvent&lt;?&gt;&gt; callback) {</span>
<span class="nc" id="L176">            super(THREAD_NAME);</span>
<span class="nc" id="L177">            this.watchService = watchService;</span>
<span class="nc" id="L178">            this.callback = callback;</span>
<span class="nc" id="L179">        }</span>

        @Override
        public void run() {
            try {
<span class="nc" id="L184">                LOG.info(&quot;{} thread started&quot;, getName());</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                if (!compareAndSetState(FileChangeWatcher.State.STARTING, FileChangeWatcher.State.RUNNING)) {</span>
                    // stop() called shortly after start(), before
                    // this thread started running.
<span class="nc" id="L188">                    FileChangeWatcher.State state = FileChangeWatcher.this.getState();</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                    if (state != FileChangeWatcher.State.STOPPING) {</span>
<span class="nc" id="L190">                        throw new IllegalStateException(&quot;Unexpected state: &quot; + state);</span>
                    }
<span class="nc" id="L192">                    return;</span>
                }
<span class="nc" id="L194">                runLoop();</span>
<span class="nc" id="L195">            } catch (Exception e) {</span>
<span class="nc" id="L196">                LOG.warn(&quot;Error in runLoop()&quot;, e);</span>
<span class="nc" id="L197">                throw e;</span>
            } finally {
                try {
<span class="nc" id="L200">                    watchService.close();</span>
<span class="nc" id="L201">                } catch (IOException e) {</span>
<span class="nc" id="L202">                    LOG.warn(&quot;Error closing watch service&quot;, e);</span>
<span class="nc" id="L203">                }</span>
<span class="nc" id="L204">                LOG.info(&quot;{} thread finished&quot;, getName());</span>
<span class="nc" id="L205">                FileChangeWatcher.this.setState(FileChangeWatcher.State.STOPPED);</span>
            }
<span class="nc" id="L207">        }</span>

        private void runLoop() {
<span class="nc bnc" id="L210" title="All 2 branches missed.">            while (FileChangeWatcher.this.getState() == FileChangeWatcher.State.RUNNING) {</span>
                WatchKey key;
                try {
<span class="nc" id="L213">                    key = watchService.take();</span>
<span class="nc" id="L214">                } catch (InterruptedException | ClosedWatchServiceException e) {</span>
<span class="nc" id="L215">                    LOG.debug(&quot;{} was interrupted and is shutting down...&quot;, getName());</span>
<span class="nc" id="L216">                    break;</span>
<span class="nc" id="L217">                }</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                for (WatchEvent&lt;?&gt; event : key.pollEvents()) {</span>
<span class="nc" id="L219">                    LOG.debug(&quot;Got file changed event: {} with context: {}&quot;, event.kind(), event.context());</span>
                    try {
<span class="nc" id="L221">                        callback.accept(event);</span>
<span class="nc" id="L222">                    } catch (Throwable e) {</span>
<span class="nc" id="L223">                        LOG.error(&quot;Error from callback&quot;, e);</span>
<span class="nc" id="L224">                    }</span>
<span class="nc" id="L225">                }</span>
<span class="nc" id="L226">                boolean isKeyValid = key.reset();</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                if (!isKeyValid) {</span>
                    // This is likely a problem, it means that file reloading is broken, probably because the
                    // directory we are watching was deleted or otherwise became inaccessible (unmounted, permissions
                    // changed, ???).
                    // For now, we log an error and exit the watcher thread.
<span class="nc" id="L232">                    LOG.error(&quot;Watch key no longer valid, maybe the directory is inaccessible?&quot;);</span>
<span class="nc" id="L233">                    break;</span>
                }
<span class="nc" id="L235">            }</span>
<span class="nc" id="L236">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>