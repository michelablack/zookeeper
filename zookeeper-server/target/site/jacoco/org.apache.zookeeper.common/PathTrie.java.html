<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PathTrie.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.common</a> &gt; <span class="el_source">PathTrie.java</span></div><h1>PathTrie.java</h1><pre class="source lang-java linenums"> /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * &quot;License&quot;); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */

 package org.apache.zookeeper.common;

 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.stream.Stream;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

 /**
  * a class that implements prefix matching for
  * components of a filesystem path. the trie
  * looks like a tree with edges mapping to
  * the component of a path.
  * example /ab/bc/cf would map to a trie
  *           /
  *        ab/
  *        (ab)
  *      bc/
  *       /
  *      (bc)
  *   cf/
  *   (cf)
  */
 public class PathTrie {

     /** Logger for this class */
<span class="nc" id="L52">     private static final Logger LOG = LoggerFactory.getLogger(PathTrie.class);</span>

     /** Root node of PathTrie */
     private final TrieNode rootNode;

<span class="nc" id="L57">     private final ReadWriteLock lock = new ReentrantReadWriteLock(true);</span>

<span class="nc" id="L59">     private final Lock readLock = lock.readLock();</span>

<span class="nc" id="L61">     private final Lock writeLock = lock.writeLock();</span>

     static class TrieNode {

         final String value;
         final Map&lt;String, TrieNode&gt; children;
         boolean property;
         TrieNode parent;

         /**
          * Create a trie node with parent as parameter.
          *
          * @param parent the parent of this node
          * @param value the value stored in this node
          */
<span class="nc" id="L76">         private TrieNode(TrieNode parent, String value) {</span>
<span class="nc" id="L77">             this.value = value;</span>
<span class="nc" id="L78">             this.parent = parent;</span>
<span class="nc" id="L79">             this.property = false;</span>
<span class="nc" id="L80">             this.children = new HashMap&lt;&gt;(4);</span>
<span class="nc" id="L81">         }</span>

         /**
          * Get the parent of this node.
          *
          * @return the parent node
          */
         TrieNode getParent() {
<span class="nc" id="L89">             return this.parent;</span>
         }

         /**
          * set the parent of this node.
          *
          * @param parent the parent to set to
          */
         void setParent(TrieNode parent) {
<span class="nc" id="L98">             this.parent = parent;</span>
<span class="nc" id="L99">         }</span>

         /**
          * A property that is set for a node - making it special.
          */
         void setProperty(boolean prop) {
<span class="nc" id="L105">             this.property = prop;</span>
<span class="nc" id="L106">         }</span>

         /**
          * The property of this node.
          *
          * @return the property for this node
          */
         boolean hasProperty() {
<span class="nc" id="L114">             return this.property;</span>
         }

         /**
          * The value stored in this node.
          *
          * @return the value stored in this node
          */
         public String getValue() {
<span class="nc" id="L123">             return this.value;</span>
         }

         /**
          * Add a child to the existing node.
          *
          * @param childName the string name of the child
          * @param node the node that is the child
          */
         void addChild(String childName, TrieNode node) {
<span class="nc" id="L133">             this.children.putIfAbsent(childName, node);</span>
<span class="nc" id="L134">         }</span>

         /**
          * Delete child from this node.
          *
          * @param childName the name of the child to be deleted
          */
         void deleteChild(String childName) {
<span class="nc" id="L142">             this.children.computeIfPresent(childName, (key, childNode) -&gt; {</span>
                 // Node no longer has an external property associated
<span class="nc" id="L144">                 childNode.setProperty(false);</span>

                 // Delete it if it has no children (is a leaf node)
<span class="nc bnc" id="L147" title="All 2 branches missed.">                 if (childNode.isLeafNode()) {</span>
<span class="nc" id="L148">                     childNode.setParent(null);</span>
<span class="nc" id="L149">                     return null;</span>
                 }

<span class="nc" id="L152">                 return childNode;</span>
             });
<span class="nc" id="L154">         }</span>

         /**
          * Return the child of a node mapping to the input child name.
          *
          * @param childName the name of the child
          * @return the child of a node
          */
         TrieNode getChild(String childName) {
<span class="nc" id="L163">             return this.children.get(childName);</span>
         }

         /**
          * Get the list of children of this trienode.
          *
          * @return A collection containing the node's children
          */
         Collection&lt;String&gt; getChildren() {
<span class="nc" id="L172">             return children.keySet();</span>
         }

         /**
          * Determine if this node is a leaf (has no children).
          *
          * @return true if this node is a lead node; otherwise false
          */
         boolean isLeafNode() {
<span class="nc" id="L181">             return children.isEmpty();</span>
         }

         @Override
         public String toString() {
<span class="nc" id="L186">             return &quot;TrieNode [name=&quot; + value + &quot;, property=&quot; + property + &quot;, children=&quot; + children.keySet() + &quot;]&quot;;</span>
         }

     }

     /**
      * Construct a new PathTrie with a root node.
      */
<span class="nc" id="L194">     public PathTrie() {</span>
<span class="nc" id="L195">         this.rootNode = new TrieNode(null, &quot;/&quot;);</span>
<span class="nc" id="L196">     }</span>

     /**
      * Add a path to the path trie. All paths are relative to the root node.
      *
      * @param path the path to add to the trie
      */
     public void addPath(final String path) {
<span class="nc" id="L204">         Objects.requireNonNull(path, &quot;Path cannot be null&quot;);</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">         if (path.length() == 0) {</span>
<span class="nc" id="L207">             throw new IllegalArgumentException(&quot;Invalid path: &quot; + path);</span>
         }
<span class="nc" id="L209">         final String[] pathComponents = split(path);</span>

<span class="nc" id="L211">         writeLock.lock();</span>
         try {
<span class="nc" id="L213">             TrieNode parent = rootNode;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">             for (final String part : pathComponents) {</span>
<span class="nc" id="L215">                 TrieNode child = parent.getChild(part);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                 if (child == null) {</span>
<span class="nc" id="L217">                     child = new TrieNode(parent, part);</span>
<span class="nc" id="L218">                     parent.addChild(part, child);</span>
                 }
<span class="nc" id="L220">                 parent = child;</span>
             }
<span class="nc" id="L222">             parent.setProperty(true);</span>
         } finally {
<span class="nc" id="L224">             writeLock.unlock();</span>
         }
<span class="nc" id="L226">     }</span>

     /**
      * Delete a path from the trie. All paths are relative to the root node.
      *
      * @param path the path to be deleted
      */
     public void deletePath(final String path) {
<span class="nc" id="L234">         Objects.requireNonNull(path, &quot;Path cannot be null&quot;);</span>

<span class="nc bnc" id="L236" title="All 2 branches missed.">         if (path.length() == 0) {</span>
<span class="nc" id="L237">             throw new IllegalArgumentException(&quot;Invalid path: &quot; + path);</span>
         }
<span class="nc" id="L239">         final String[] pathComponents = split(path);</span>


<span class="nc" id="L242">         writeLock.lock();</span>
         try {
<span class="nc" id="L244">             TrieNode parent = rootNode;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">             for (final String part : pathComponents) {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                 if (parent.getChild(part) == null) {</span>
                     // the path does not exist
<span class="nc" id="L248">                     return;</span>
                 }
<span class="nc" id="L250">                 parent = parent.getChild(part);</span>
<span class="nc" id="L251">                 LOG.debug(&quot;{}&quot;, parent);</span>
             }

<span class="nc" id="L254">             final TrieNode realParent = parent.getParent();</span>
<span class="nc" id="L255">             realParent.deleteChild(parent.getValue());</span>
         } finally {
<span class="nc" id="L257">             writeLock.unlock();</span>
         }
<span class="nc" id="L259">     }</span>

     /**
      * Return true if the given path exists in the trie, otherwise return false;
      * All paths are relative to the root node.
      *
      * @param path the input path
      * @return the largest prefix for the
      */
     public boolean existsNode(final String path) {
<span class="nc" id="L269">         Objects.requireNonNull(path, &quot;Path cannot be null&quot;);</span>

<span class="nc bnc" id="L271" title="All 2 branches missed.">         if (path.length() == 0) {</span>
<span class="nc" id="L272">             throw new IllegalArgumentException(&quot;Invalid path: &quot; + path);</span>
         }
<span class="nc" id="L274">         final String[] pathComponents = split(path);</span>

<span class="nc" id="L276">         readLock.lock();</span>
         try {
<span class="nc" id="L278">             TrieNode parent = rootNode;</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">             for (final String part : pathComponents) {</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                 if (parent.getChild(part) == null) {</span>
                     // the path does not exist
<span class="nc" id="L282">                     return false;</span>
                 }
<span class="nc" id="L284">                 parent = parent.getChild(part);</span>
<span class="nc" id="L285">                 LOG.debug(&quot;{}&quot;, parent);</span>
             }
         } finally {
<span class="nc" id="L288">             readLock.unlock();</span>
         }
<span class="nc" id="L290">         return true;</span>
     }

     /**
      * Return the largest prefix for the input path. All paths are relative to the
      * root node.
      *
      * @param path the input path
      * @return the largest prefix for the input path
      */
     public String findMaxPrefix(final String path) {
<span class="nc" id="L301">         Objects.requireNonNull(path, &quot;Path cannot be null&quot;);</span>

<span class="nc" id="L303">         final String[] pathComponents = split(path);</span>

<span class="nc" id="L305">         readLock.lock();</span>
         try {
<span class="nc" id="L307">             TrieNode parent = rootNode;</span>
<span class="nc" id="L308">             TrieNode deepestPropertyNode = null;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">             for (final String element : pathComponents) {</span>
<span class="nc" id="L310">                 parent = parent.getChild(element);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                 if (parent == null) {</span>
<span class="nc" id="L312">                     LOG.debug(&quot;{}&quot;, element);</span>
<span class="nc" id="L313">                     break;</span>
                 }
<span class="nc bnc" id="L315" title="All 2 branches missed.">                 if (parent.hasProperty()) {</span>
<span class="nc" id="L316">                     deepestPropertyNode = parent;</span>
                 }
             }

<span class="nc bnc" id="L320" title="All 2 branches missed.">             if (deepestPropertyNode == null) {</span>
<span class="nc" id="L321">                 return &quot;/&quot;;</span>
             }

<span class="nc" id="L324">             final Deque&lt;String&gt; treePath = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L325">             TrieNode node = deepestPropertyNode;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">             while (node != this.rootNode) {</span>
<span class="nc" id="L327">                 treePath.offerFirst(node.getValue());</span>
<span class="nc" id="L328">                 node = node.parent;</span>
             }
<span class="nc" id="L330">             return &quot;/&quot; + String.join(&quot;/&quot;, treePath);</span>
         } finally {
<span class="nc" id="L332">             readLock.unlock();</span>
         }
     }

     /**
      * Clear all nodes in the trie.
      */
     public void clear() {
<span class="nc" id="L340">         writeLock.lock();</span>
         try {
<span class="nc" id="L342">             rootNode.getChildren().clear();</span>
         } finally {
<span class="nc" id="L344">             writeLock.unlock();</span>
         }
<span class="nc" id="L346">     }</span>

     private static String[] split(final String path){
<span class="nc" id="L349">         return Stream.of(path.split(&quot;/&quot;))</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                 .filter(t -&gt; !t.trim().isEmpty())</span>
<span class="nc" id="L351">                 .toArray(String[]::new);</span>
     }

 }
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>