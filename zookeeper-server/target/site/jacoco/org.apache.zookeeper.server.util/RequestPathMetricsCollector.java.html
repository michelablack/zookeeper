<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RequestPathMetricsCollector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server.util</a> &gt; <span class="el_source">RequestPathMetricsCollector.java</span></div><h1>RequestPathMetricsCollector.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * &lt;p&gt;
 * http://www.apache.org/licenses/LICENSE-2.0
 * &lt;p&gt;
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server.util;

import static org.apache.zookeeper.ZooDefs.OpCode.checkWatches;
import static org.apache.zookeeper.ZooDefs.OpCode.create;
import static org.apache.zookeeper.ZooDefs.OpCode.create2;
import static org.apache.zookeeper.ZooDefs.OpCode.createContainer;
import static org.apache.zookeeper.ZooDefs.OpCode.delete;
import static org.apache.zookeeper.ZooDefs.OpCode.deleteContainer;
import static org.apache.zookeeper.ZooDefs.OpCode.exists;
import static org.apache.zookeeper.ZooDefs.OpCode.getACL;
import static org.apache.zookeeper.ZooDefs.OpCode.getChildren;
import static org.apache.zookeeper.ZooDefs.OpCode.getChildren2;
import static org.apache.zookeeper.ZooDefs.OpCode.getData;
import static org.apache.zookeeper.ZooDefs.OpCode.removeWatches;
import static org.apache.zookeeper.ZooDefs.OpCode.setACL;
import static org.apache.zookeeper.ZooDefs.OpCode.setData;
import static org.apache.zookeeper.ZooDefs.OpCode.setWatches2;
import static org.apache.zookeeper.ZooDefs.OpCode.sync;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Predicate;
import org.apache.zookeeper.ZooDefs;
import org.apache.zookeeper.server.Request;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class holds the requests path ( up till a certain depth) stats per request type
 */
public class RequestPathMetricsCollector {

<span class="nc" id="L64">    private static final Logger LOG = LoggerFactory.getLogger(RequestPathMetricsCollector.class);</span>
    // How many seconds does each slot represent, default is 15 seconds.
    private final int REQUEST_STATS_SLOT_DURATION;
    // How many slots we keep, default is 60 so it's 15 minutes total history.
    private final int REQUEST_STATS_SLOT_CAPACITY;
    // How far down the path we keep, default is 6.
    private final int REQUEST_PREPROCESS_PATH_DEPTH;
    // Sample rate, default is 0.1 (10%).
    private final float REQUEST_PREPROCESS_SAMPLE_RATE;
    private final long COLLECTOR_INITIAL_DELAY;
    private final long COLLECTOR_DELAY;
    private final int REQUEST_PREPROCESS_TOPPATH_MAX;
    private final boolean enabled;

    public static final String PATH_STATS_SLOT_CAPACITY = &quot;zookeeper.pathStats.slotCapacity&quot;;
    public static final String PATH_STATS_SLOT_DURATION = &quot;zookeeper.pathStats.slotDuration&quot;;
    public static final String PATH_STATS_MAX_DEPTH = &quot;zookeeper.pathStats.maxDepth&quot;;
    public static final String PATH_STATS_SAMPLE_RATE = &quot;zookeeper.pathStats.sampleRate&quot;;
    public static final String PATH_STATS_COLLECTOR_INITIAL_DELAY = &quot;zookeeper.pathStats.initialDelay&quot;;
    public static final String PATH_STATS_COLLECTOR_DELAY = &quot;zookeeper.pathStats.delay&quot;;
    public static final String PATH_STATS_TOP_PATH_MAX = &quot;zookeeper.pathStats.topPathMax&quot;;
    public static final String PATH_STATS_ENABLED = &quot;zookeeper.pathStats.enabled&quot;;
    private static final String PATH_SEPERATOR = &quot;/&quot;;

    private final Map&lt;String, PathStatsQueue&gt; immutableRequestsMap;
    private final ScheduledThreadPoolExecutor scheduledExecutor;
    private final boolean accurateMode;

    public RequestPathMetricsCollector() {
<span class="nc" id="L93">        this(false);</span>
<span class="nc" id="L94">    }</span>

<span class="nc" id="L96">    public RequestPathMetricsCollector(boolean accurateMode) {</span>
<span class="nc" id="L97">        final Map&lt;String, PathStatsQueue&gt; requestsMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L98">        this.accurateMode = accurateMode;</span>

<span class="nc" id="L100">        REQUEST_PREPROCESS_TOPPATH_MAX = Integer.getInteger(PATH_STATS_TOP_PATH_MAX, 20);</span>
<span class="nc" id="L101">        REQUEST_STATS_SLOT_DURATION = Integer.getInteger(PATH_STATS_SLOT_DURATION, 15);</span>
<span class="nc" id="L102">        REQUEST_STATS_SLOT_CAPACITY = Integer.getInteger(PATH_STATS_SLOT_CAPACITY, 60);</span>
<span class="nc" id="L103">        REQUEST_PREPROCESS_PATH_DEPTH = Integer.getInteger(PATH_STATS_MAX_DEPTH, 6);</span>
<span class="nc" id="L104">        REQUEST_PREPROCESS_SAMPLE_RATE = Float.parseFloat(System.getProperty(PATH_STATS_SAMPLE_RATE, &quot;0.1&quot;));</span>
<span class="nc" id="L105">        COLLECTOR_INITIAL_DELAY = Long.getLong(PATH_STATS_COLLECTOR_INITIAL_DELAY, 5);</span>
<span class="nc" id="L106">        COLLECTOR_DELAY = Long.getLong(PATH_STATS_COLLECTOR_DELAY, 5);</span>
<span class="nc" id="L107">        enabled = Boolean.getBoolean(PATH_STATS_ENABLED);</span>

<span class="nc" id="L109">        LOG.info(&quot;{} = {}&quot;, PATH_STATS_SLOT_CAPACITY, REQUEST_STATS_SLOT_CAPACITY);</span>
<span class="nc" id="L110">        LOG.info(&quot;{} = {}&quot;, PATH_STATS_SLOT_DURATION, REQUEST_STATS_SLOT_DURATION);</span>
<span class="nc" id="L111">        LOG.info(&quot;{} = {}&quot;, PATH_STATS_MAX_DEPTH, REQUEST_PREPROCESS_PATH_DEPTH);</span>
<span class="nc" id="L112">        LOG.info(&quot;{} = {}&quot;, PATH_STATS_COLLECTOR_INITIAL_DELAY, COLLECTOR_INITIAL_DELAY);</span>
<span class="nc" id="L113">        LOG.info(&quot;{} = {}&quot;, PATH_STATS_COLLECTOR_DELAY, COLLECTOR_DELAY);</span>
<span class="nc" id="L114">        LOG.info(&quot;{} = {}&quot;, PATH_STATS_ENABLED, enabled);</span>

<span class="nc" id="L116">        this.scheduledExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());</span>
<span class="nc" id="L117">        scheduledExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);</span>
<span class="nc" id="L118">        scheduledExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);</span>
<span class="nc" id="L119">        requestsMap.put(Request.op2String(create), new PathStatsQueue(create));</span>
<span class="nc" id="L120">        requestsMap.put(Request.op2String(create2), new PathStatsQueue(create2));</span>
<span class="nc" id="L121">        requestsMap.put(Request.op2String(createContainer), new PathStatsQueue(createContainer));</span>
<span class="nc" id="L122">        requestsMap.put(Request.op2String(deleteContainer), new PathStatsQueue(deleteContainer));</span>
<span class="nc" id="L123">        requestsMap.put(Request.op2String(delete), new PathStatsQueue(delete));</span>
<span class="nc" id="L124">        requestsMap.put(Request.op2String(exists), new PathStatsQueue(exists));</span>
<span class="nc" id="L125">        requestsMap.put(Request.op2String(setData), new PathStatsQueue(setData));</span>
<span class="nc" id="L126">        requestsMap.put(Request.op2String(getData), new PathStatsQueue(getData));</span>
<span class="nc" id="L127">        requestsMap.put(Request.op2String(getACL), new PathStatsQueue(getACL));</span>
<span class="nc" id="L128">        requestsMap.put(Request.op2String(setACL), new PathStatsQueue(setACL));</span>
<span class="nc" id="L129">        requestsMap.put(Request.op2String(getChildren), new PathStatsQueue(getChildren));</span>
<span class="nc" id="L130">        requestsMap.put(Request.op2String(getChildren2), new PathStatsQueue(getChildren2));</span>
<span class="nc" id="L131">        requestsMap.put(Request.op2String(checkWatches), new PathStatsQueue(checkWatches));</span>
<span class="nc" id="L132">        requestsMap.put(Request.op2String(removeWatches), new PathStatsQueue(removeWatches));</span>
<span class="nc" id="L133">        requestsMap.put(Request.op2String(setWatches2), new PathStatsQueue(setWatches2));</span>
<span class="nc" id="L134">        requestsMap.put(Request.op2String(sync), new PathStatsQueue(sync));</span>
<span class="nc" id="L135">        this.immutableRequestsMap = java.util.Collections.unmodifiableMap(requestsMap);</span>
<span class="nc" id="L136">    }</span>

    static boolean isWriteOp(int requestType) {
<span class="nc bnc" id="L139" title="All 2 branches missed.">        switch (requestType) {</span>
        case ZooDefs.OpCode.sync:
        case ZooDefs.OpCode.create:
        case ZooDefs.OpCode.create2:
        case ZooDefs.OpCode.createContainer:
        case ZooDefs.OpCode.delete:
        case ZooDefs.OpCode.deleteContainer:
        case ZooDefs.OpCode.setData:
        case ZooDefs.OpCode.reconfig:
        case ZooDefs.OpCode.setACL:
        case ZooDefs.OpCode.multi:
        case ZooDefs.OpCode.check:
<span class="nc" id="L151">            return true;</span>
        }
<span class="nc" id="L153">        return false;</span>
    }

    static String trimPathDepth(String path, int maxDepth) {
<span class="nc" id="L157">        int count = 0;</span>
<span class="nc" id="L158">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L159">        StringTokenizer pathTokenizer = new StringTokenizer(path, PATH_SEPERATOR);</span>
<span class="nc bnc" id="L160" title="All 4 branches missed.">        while (pathTokenizer.hasMoreElements() &amp;&amp; count++ &lt; maxDepth) {</span>
<span class="nc" id="L161">            sb.append(PATH_SEPERATOR);</span>
<span class="nc" id="L162">            sb.append(pathTokenizer.nextToken());</span>
        }
<span class="nc" id="L164">        path = sb.toString();</span>
<span class="nc" id="L165">        return path;</span>
    }

    public void shutdown() {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L170">            return;</span>
        }

<span class="nc" id="L173">        LOG.info(&quot;shutdown scheduledExecutor&quot;);</span>
<span class="nc" id="L174">        scheduledExecutor.shutdownNow();</span>
<span class="nc" id="L175">    }</span>

    public void start() {
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L179">            return;</span>
        }

<span class="nc" id="L182">        LOG.info(&quot;Start the RequestPath collector&quot;);</span>
<span class="nc" id="L183">        immutableRequestsMap.forEach((opType, pathStatsQueue) -&gt; pathStatsQueue.start());</span>

        // Schedule to log the top used read/write paths every 5 mins
<span class="nc" id="L186">        scheduledExecutor.scheduleWithFixedDelay(() -&gt; {</span>
<span class="nc" id="L187">            LOG.info(&quot;%nHere are the top Read paths:&quot;);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            logTopPaths(aggregatePaths(4, queue -&gt; !queue.isWriteOperation()),</span>
<span class="nc" id="L189">                        entry -&gt; LOG.info(&quot;{} : {}&quot;, entry.getKey(), entry.getValue()));</span>
<span class="nc" id="L190">            LOG.info(&quot;%nHere are the top Write paths:&quot;);</span>
<span class="nc" id="L191">            logTopPaths(aggregatePaths(4, queue -&gt; queue.isWriteOperation()),</span>
<span class="nc" id="L192">                        entry -&gt; LOG.info(&quot;{} : {}&quot;, entry.getKey(), entry.getValue()));</span>
<span class="nc" id="L193">        }, COLLECTOR_INITIAL_DELAY, COLLECTOR_DELAY, TimeUnit.MINUTES);</span>
<span class="nc" id="L194">    }</span>

    /**
     * The public interface of the buffer. FinalRequestHandler will call into this for
     * each request that has a path and this needs to be fast. we sample the path so that
     * we don't have to store too many paths in memory
     */
    public void registerRequest(int type, String path) {
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L203">            return;</span>
        }
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (ThreadLocalRandom.current().nextFloat() &lt;= REQUEST_PREPROCESS_SAMPLE_RATE) {</span>
<span class="nc" id="L206">            PathStatsQueue pathStatsQueue = immutableRequestsMap.get(Request.op2String(type));</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (pathStatsQueue != null) {</span>
<span class="nc" id="L208">                pathStatsQueue.registerRequest(path);</span>
            } else {
<span class="nc" id="L210">                LOG.error(&quot;We should not handle {}&quot;, type);</span>
            }
        }
<span class="nc" id="L213">    }</span>

    public void dumpTopRequestPath(PrintWriter pwriter, String requestTypeName, int queryMaxDepth) {
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (queryMaxDepth &lt; 1) {</span>
<span class="nc" id="L217">            return;</span>
        }
<span class="nc" id="L219">        PathStatsQueue pathStatsQueue = immutableRequestsMap.get(requestTypeName);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (pathStatsQueue == null) {</span>
<span class="nc" id="L221">            pwriter.println(&quot;Can not find path stats for type: &quot; + requestTypeName);</span>
<span class="nc" id="L222">            return;</span>
        } else {
<span class="nc" id="L224">            pwriter.println(&quot;The top requests of type: &quot; + requestTypeName);</span>
        }
        Map&lt;String, Integer&gt; combinedMap;
<span class="nc" id="L227">        final int maxDepth = Math.min(queryMaxDepth, REQUEST_PREPROCESS_PATH_DEPTH);</span>
<span class="nc" id="L228">        combinedMap = pathStatsQueue.collectStats(maxDepth);</span>
<span class="nc" id="L229">        logTopPaths(combinedMap, entry -&gt; pwriter.println(entry.getKey() + &quot; : &quot; + entry.getValue()));</span>
<span class="nc" id="L230">    }</span>

    public void dumpTopReadPaths(PrintWriter pwriter, int queryMaxDepth) {
<span class="nc" id="L233">        pwriter.println(&quot;The top read requests are&quot;);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -&gt; !queue.isWriteOperation);</span>
<span class="nc" id="L235">    }</span>

    public void dumpTopWritePaths(PrintWriter pwriter, int queryMaxDepth) {
<span class="nc" id="L238">        pwriter.println(&quot;The top write requests are&quot;);</span>
<span class="nc" id="L239">        dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -&gt; queue.isWriteOperation);</span>
<span class="nc" id="L240">    }</span>

    public void dumpTopPaths(PrintWriter pwriter, int queryMaxDepth) {
<span class="nc" id="L243">        pwriter.println(&quot;The top requests are&quot;);</span>
<span class="nc" id="L244">        dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -&gt; true);</span>
<span class="nc" id="L245">    }</span>

    /**
     * Combine all the path Stats Queue that matches the predicate together
     * and then write to the pwriter
     */
    private void dumpTopAggregatedPaths(PrintWriter pwriter, int queryMaxDepth, final Predicate&lt;PathStatsQueue&gt; predicate) {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L253">            return;</span>
        }
<span class="nc" id="L255">        final Map&lt;String, Integer&gt; combinedMap = aggregatePaths(queryMaxDepth, predicate);</span>
<span class="nc" id="L256">        logTopPaths(combinedMap, entry -&gt; pwriter.println(entry.getKey() + &quot; : &quot; + entry.getValue()));</span>
<span class="nc" id="L257">    }</span>

    Map&lt;String, Integer&gt; aggregatePaths(int queryMaxDepth, Predicate&lt;PathStatsQueue&gt; predicate) {
<span class="nc" id="L260">        final Map&lt;String, Integer&gt; combinedMap = new HashMap&lt;&gt;(REQUEST_PREPROCESS_TOPPATH_MAX);</span>
<span class="nc" id="L261">        final int maxDepth = Math.min(queryMaxDepth, REQUEST_PREPROCESS_PATH_DEPTH);</span>
<span class="nc" id="L262">        immutableRequestsMap.values()</span>
<span class="nc" id="L263">                            .stream()</span>
<span class="nc" id="L264">                            .filter(predicate)</span>
<span class="nc" id="L265">                            .forEach(pathStatsQueue -&gt; pathStatsQueue.collectStats(maxDepth).forEach(</span>
<span class="nc" id="L266">                                (path, count) -&gt; combinedMap.put(path, combinedMap.getOrDefault(path, 0) + count)));</span>
<span class="nc" id="L267">        return combinedMap;</span>
    }

    void logTopPaths(Map&lt;String, Integer&gt; combinedMap, final Consumer&lt;Map.Entry&lt;String, Integer&gt;&gt; output) {
<span class="nc" id="L271">        combinedMap.entrySet()</span>
<span class="nc" id="L272">                   .stream()</span>
                   // sort by path count
<span class="nc" id="L274">                   .sorted(Comparator.comparing(Map.Entry&lt;String, Integer&gt;::getValue).reversed())</span>
<span class="nc" id="L275">                   .limit(REQUEST_PREPROCESS_TOPPATH_MAX).forEach(output);</span>
<span class="nc" id="L276">    }</span>

    class PathStatsQueue {

        private final String requestTypeName;
        private final AtomicReference&lt;ConcurrentLinkedQueue&lt;String&gt;&gt; currentSlot;
        private final LinkedBlockingQueue&lt;Map&lt;String, Integer&gt;&gt; requestPathStats;
        private final boolean isWriteOperation;

<span class="nc" id="L285">        public PathStatsQueue(int requestType) {</span>
<span class="nc" id="L286">            this.requestTypeName = Request.op2String(requestType);</span>
<span class="nc" id="L287">            this.isWriteOperation = isWriteOp(requestType);</span>
<span class="nc" id="L288">            requestPathStats = new LinkedBlockingQueue&lt;&gt;(REQUEST_STATS_SLOT_CAPACITY);</span>
<span class="nc" id="L289">            currentSlot = new AtomicReference&lt;&gt;(new ConcurrentLinkedQueue&lt;&gt;());</span>
<span class="nc" id="L290">        }</span>

        /*
         * The only write entry into this class, need to be fast.
         * Just queue up the path to the current slot queue locking free.
         */
        public void registerRequest(String path) {
<span class="nc bnc" id="L297" title="All 2 branches missed.">            if (!enabled) {</span>
<span class="nc" id="L298">                return;</span>
            }
<span class="nc" id="L300">            currentSlot.get().offer(path);</span>
<span class="nc" id="L301">        }</span>

        ConcurrentLinkedQueue&lt;String&gt; getCurrentSlot() {
<span class="nc" id="L304">            return currentSlot.get();</span>
        }

        /**
         * Helper function to MR the paths in the queue to map with count
         * 1. cut each path up to max depth
         * 2. aggregate the paths based on its count
         *
         * @param tobeProcessedSlot queue of paths called
         * @return a map containing aggregated path in the queue
         */
        Map&lt;String, Integer&gt; mapReducePaths(int maxDepth, Collection&lt;String&gt; tobeProcessedSlot) {
<span class="nc" id="L316">            Map&lt;String, Integer&gt; newSlot = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">            tobeProcessedSlot.stream().filter(path -&gt; path != null).forEach((path) -&gt; {</span>
<span class="nc" id="L318">                path = trimPathDepth(path, maxDepth);</span>
<span class="nc" id="L319">                newSlot.put(path, newSlot.getOrDefault(path, 0) + 1);</span>
<span class="nc" id="L320">            });</span>
<span class="nc" id="L321">            return newSlot;</span>
        }

        /**
         * The only read point of this class
         *
         * @return the aggregated path to count map
         */
        public Map&lt;String, Integer&gt; collectStats(int maxDepth) {
            Map&lt;String, Integer&gt; combinedMap;
            // Take a snapshot of the current slot and convert it to map.
            // Set the initial size as 0 since we don't want it to padding nulls in the end.
<span class="nc" id="L333">            Map&lt;String, Integer&gt; snapShot = mapReducePaths(</span>
                maxDepth,
<span class="nc" id="L335">                Arrays.asList(currentSlot.get().toArray(new String[0])));</span>
            // Starting from the snapshot and go through the queue to reduce them into one map
            // the iterator can run concurrently with write but we want to use a real lock in the test
<span class="nc bnc" id="L338" title="All 2 branches missed.">            synchronized (accurateMode ? requestPathStats : new Object()) {</span>
<span class="nc" id="L339">                combinedMap = requestPathStats.stream().reduce(snapShot, (firstMap, secondMap) -&gt; {</span>
<span class="nc" id="L340">                    secondMap.forEach((key, value) -&gt; {</span>
<span class="nc" id="L341">                        String trimmedPath = trimPathDepth(key, maxDepth);</span>
<span class="nc" id="L342">                        firstMap.put(trimmedPath, firstMap.getOrDefault(trimmedPath, 0) + value);</span>
<span class="nc" id="L343">                    });</span>
<span class="nc" id="L344">                    return firstMap;</span>
                });
<span class="nc" id="L346">            }</span>
<span class="nc" id="L347">            return combinedMap;</span>
        }

        /**
         * Start to schedule the pre-processing of the current slot
         */
        public void start() {
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (!enabled) {</span>
<span class="nc" id="L355">                return;</span>
            }
            // Staggered start and then run every 15 seconds no matter what
<span class="nc" id="L358">            int delay = ThreadLocalRandom.current().nextInt(REQUEST_STATS_SLOT_DURATION);</span>
            // We need to use fixed Delay as the fixed rate will start the next one right
            // after the previous one finishes if it runs overtime instead of overlapping it.
<span class="nc" id="L361">            scheduledExecutor.scheduleWithFixedDelay(() -&gt; {</span>
                // Generate new slot so new requests will go here.
<span class="nc" id="L363">                ConcurrentLinkedQueue&lt;String&gt; tobeProcessedSlot = currentSlot.getAndSet(new ConcurrentLinkedQueue&lt;&gt;());</span>
                try {
                    // pre process the last slot and queue it up, only one thread scheduled modified
                    // this but we can mess up the collect part so we put a lock in the test.
<span class="nc" id="L367">                    Map&lt;String, Integer&gt; latestSlot = mapReducePaths(REQUEST_PREPROCESS_PATH_DEPTH, tobeProcessedSlot);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                    synchronized (accurateMode ? requestPathStats : new Object()) {</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                        if (requestPathStats.remainingCapacity() &lt;= 0) {</span>
<span class="nc" id="L370">                            requestPathStats.poll();</span>
                        }
<span class="nc bnc" id="L372" title="All 2 branches missed.">                        if (!requestPathStats.offer(latestSlot)) {</span>
<span class="nc" id="L373">                            LOG.error(&quot;Failed to insert the new request path stats for {}&quot;, requestTypeName);</span>
                        }
<span class="nc" id="L375">                    }</span>
<span class="nc" id="L376">                } catch (Exception e) {</span>
<span class="nc" id="L377">                    LOG.error(&quot;Failed to insert the new request path stats for {} with exception {}&quot;, requestTypeName, e);</span>
<span class="nc" id="L378">                }</span>
<span class="nc" id="L379">            }, delay, REQUEST_STATS_SLOT_DURATION, TimeUnit.SECONDS);</span>
<span class="nc" id="L380">        }</span>

        boolean isWriteOperation() {
<span class="nc" id="L383">            return isWriteOperation;</span>
        }

    }

}


</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>