<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WatchManagerOptimized.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache ZooKeeper - Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server.watch</a> &gt; <span class="el_source">WatchManagerOptimized.java</span></div><h1>WatchManagerOptimized.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server.watch;

import java.io.PrintWriter;
import java.util.BitSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.Watcher.Event.EventType;
import org.apache.zookeeper.Watcher.Event.KeeperState;
import org.apache.zookeeper.server.ServerCnxn;
import org.apache.zookeeper.server.ServerMetrics;
import org.apache.zookeeper.server.util.BitHashSet;
import org.apache.zookeeper.server.util.BitMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Optimized in memory and time complexity, compared to WatchManager, both the
 * memory consumption and time complexity improved a lot, but it cannot
 * efficiently remove the watcher when the session or socket is closed, for
 * majority use case this is not a problem.
 *
 * Changed made compared to WatchManager:
 *
 * - Use HashSet and BitSet to store the watchers to find a balance between
 *   memory usage and time complexity
 * - Use ReadWriteLock instead of synchronized to reduce lock retention
 * - Lazily clean up the closed watchers
 */
public class WatchManagerOptimized implements IWatchManager, IDeadWatcherListener {

<span class="nc" id="L56">    private static final Logger LOG = LoggerFactory.getLogger(WatchManagerOptimized.class);</span>

<span class="nc" id="L58">    private final ConcurrentHashMap&lt;String, BitHashSet&gt; pathWatches = new ConcurrentHashMap&lt;String, BitHashSet&gt;();</span>

    // watcher to bit id mapping
<span class="nc" id="L61">    private final BitMap&lt;Watcher&gt; watcherBitIdMap = new BitMap&lt;Watcher&gt;();</span>

    // used to lazily remove the dead watchers
    private final WatcherCleaner watcherCleaner;

<span class="nc" id="L66">    private final ReentrantReadWriteLock addRemovePathRWLock = new ReentrantReadWriteLock();</span>

<span class="nc" id="L68">    public WatchManagerOptimized() {</span>
<span class="nc" id="L69">        watcherCleaner = new WatcherCleaner(this);</span>
<span class="nc" id="L70">        watcherCleaner.start();</span>
<span class="nc" id="L71">    }</span>

    @Override
    public boolean addWatch(String path, Watcher watcher) {
<span class="nc" id="L75">        boolean result = false;</span>
        // Need readLock to exclusively lock with removeWatcher, otherwise we
        // may add a dead watch whose connection was just closed.
        //
        // Creating new watcher bit and adding it to the BitHashSet has it's
        // own lock to minimize the write lock scope
<span class="nc" id="L81">        addRemovePathRWLock.readLock().lock();</span>
        try {
            // avoid race condition of adding a on flying dead watcher
<span class="nc bnc" id="L84" title="All 2 branches missed.">            if (isDeadWatcher(watcher)) {</span>
<span class="nc" id="L85">                LOG.debug(&quot;Ignoring addWatch with closed cnxn&quot;);</span>
            } else {
<span class="nc" id="L87">                Integer bit = watcherBitIdMap.add(watcher);</span>
<span class="nc" id="L88">                BitHashSet watchers = pathWatches.get(path);</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">                if (watchers == null) {</span>
<span class="nc" id="L90">                    watchers = new BitHashSet();</span>
<span class="nc" id="L91">                    BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);</span>
                    // it's possible multiple thread might add to pathWatches
                    // while we're holding read lock, so we need this check
                    // here
<span class="nc bnc" id="L95" title="All 2 branches missed.">                    if (existingWatchers != null) {</span>
<span class="nc" id="L96">                        watchers = existingWatchers;</span>
                    }
                }
<span class="nc" id="L99">                result = watchers.add(bit);</span>
            }
        } finally {
<span class="nc" id="L102">            addRemovePathRWLock.readLock().unlock();</span>
        }
<span class="nc" id="L104">        return result;</span>
    }

    /**
     * Used in the OpCode.checkWatches, which is a read operation, since read
     * and write requests are exclusively processed, we don't need to hold
     * lock here.
     *
     * Different from addWatch this method doesn't mutate any state, so we don't
     * need to hold read lock to avoid dead watcher (cnxn closed) being added
     * to the watcher manager.
     *
     * It's possible that before we lazily clean up the dead watcher, this will
     * return true, but since the cnxn is closed, the response will dropped as
     * well, so it doesn't matter.
     */
    @Override
    public boolean containsWatcher(String path, Watcher watcher) {
<span class="nc" id="L122">        BitHashSet watchers = pathWatches.get(path);</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">        return watchers != null &amp;&amp; watchers.contains(watcherBitIdMap.getBit(watcher));</span>
    }

    @Override
    public boolean removeWatcher(String path, Watcher watcher) {
        // Hold write lock directly because removeWatcher request is more
        // likely to be invoked when the watcher is actually exist and
        // haven't fired yet, so instead of having read lock to check existence
        // before switching to write one, it's actually cheaper to hold write
        // lock directly here.
<span class="nc" id="L133">        addRemovePathRWLock.writeLock().lock();</span>
        try {
<span class="nc" id="L135">            BitHashSet list = pathWatches.get(path);</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">            if (list == null || !list.remove(watcherBitIdMap.getBit(watcher))) {</span>
<span class="nc" id="L137">                return false;</span>
            }
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (list.isEmpty()) {</span>
<span class="nc" id="L140">                pathWatches.remove(path);</span>
            }
<span class="nc" id="L142">            return true;</span>
        } finally {
<span class="nc" id="L144">            addRemovePathRWLock.writeLock().unlock();</span>
        }
    }

    @Override
    public void removeWatcher(Watcher watcher) {
        Integer watcherBit;
        // Use exclusive lock with addWatcher to guarantee that we won't add
        // watch for a cnxn which is already closed.
<span class="nc" id="L153">        addRemovePathRWLock.writeLock().lock();</span>
        try {
            // do nothing if the watcher is not tracked
<span class="nc" id="L156">            watcherBit = watcherBitIdMap.getBit(watcher);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (watcherBit == null) {</span>
<span class="nc" id="L158">                return;</span>
            }
        } finally {
<span class="nc" id="L161">            addRemovePathRWLock.writeLock().unlock();</span>
        }

        // We can guarantee that when this line is executed, the cnxn of this
        // watcher has already been marked as stale (this method is only called
        // from ServerCnxn.close after we set stale), which means no watches
        // will be added to the watcher manager with this watcher, so that we
        // can safely clean up this dead watcher.
        //
        // So it's not necessary to have this line in the addRemovePathRWLock.
        // And moving the addDeadWatcher out of the locking block to avoid
        // holding the write lock while we're blocked on adding dead watchers
        // into the watcherCleaner.
<span class="nc" id="L174">        watcherCleaner.addDeadWatcher(watcherBit);</span>
<span class="nc" id="L175">    }</span>

    /**
     * Entry for WatcherCleaner to remove dead watchers
     *
     * @param deadWatchers the watchers need to be removed
     */
    @Override
    public void processDeadWatchers(Set&lt;Integer&gt; deadWatchers) {
        // All the watchers being processed here are guaranteed to be dead,
        // no watches will be added for those dead watchers, that's why I
        // don't need to have addRemovePathRWLock here.
<span class="nc" id="L187">        BitSet bits = new BitSet();</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        for (int dw : deadWatchers) {</span>
<span class="nc" id="L189">            bits.set(dw);</span>
<span class="nc" id="L190">        }</span>
        // The value iterator will reflect the state when it was
        // created, don't need to synchronize.
<span class="nc bnc" id="L193" title="All 2 branches missed.">        for (BitHashSet watchers : pathWatches.values()) {</span>
<span class="nc" id="L194">            watchers.remove(deadWatchers, bits);</span>
<span class="nc" id="L195">        }</span>
        // Better to remove the empty path from pathWatches, but it will add
        // lot of lock contention and affect the throughput of addWatch,
        // let's rely on the triggerWatch to delete it.
<span class="nc bnc" id="L199" title="All 2 branches missed.">        for (Integer wbit : deadWatchers) {</span>
<span class="nc" id="L200">            watcherBitIdMap.remove(wbit);</span>
<span class="nc" id="L201">        }</span>
<span class="nc" id="L202">    }</span>

    @Override
    public WatcherOrBitSet triggerWatch(String path, EventType type) {
<span class="nc" id="L206">        return triggerWatch(path, type, null);</span>
    }

    @Override
    public WatcherOrBitSet triggerWatch(String path, EventType type, WatcherOrBitSet suppress) {
<span class="nc" id="L211">        WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);</span>

<span class="nc" id="L213">        BitHashSet watchers = remove(path);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (watchers == null) {</span>
<span class="nc" id="L215">            return null;</span>
        }

<span class="nc" id="L218">        int triggeredWatches = 0;</span>

        // Avoid race condition between dead watcher cleaner in
        // WatcherCleaner and iterating here
<span class="nc" id="L222">        synchronized (watchers) {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            for (Integer wBit : watchers) {</span>
<span class="nc bnc" id="L224" title="All 4 branches missed.">                if (suppress != null &amp;&amp; suppress.contains(wBit)) {</span>
<span class="nc" id="L225">                    continue;</span>
                }

<span class="nc" id="L228">                Watcher w = watcherBitIdMap.get(wBit);</span>

                // skip dead watcher
<span class="nc bnc" id="L231" title="All 4 branches missed.">                if (w == null || isDeadWatcher(w)) {</span>
<span class="nc" id="L232">                    continue;</span>
                }

<span class="nc" id="L235">                w.process(e);</span>
<span class="nc" id="L236">                triggeredWatches++;</span>
<span class="nc" id="L237">            }</span>
<span class="nc" id="L238">        }</span>

<span class="nc" id="L240">        updateMetrics(type, triggeredWatches);</span>
<span class="nc" id="L241">        return new WatcherOrBitSet(watchers);</span>
    }

    @Override
    public int size() {
<span class="nc" id="L246">        int size = 0;</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        for (BitHashSet watches : pathWatches.values()) {</span>
<span class="nc" id="L248">            size += watches.size();</span>
<span class="nc" id="L249">        }</span>
<span class="nc" id="L250">        return size;</span>
    }

    @Override
    public void shutdown() {
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (watcherCleaner != null) {</span>
<span class="nc" id="L256">            watcherCleaner.shutdown();</span>
        }
<span class="nc" id="L258">    }</span>

    private BitHashSet remove(String path) {
<span class="nc" id="L261">        addRemovePathRWLock.writeLock().lock();</span>
        try {
<span class="nc" id="L263">            return pathWatches.remove(path);</span>
        } finally {
<span class="nc" id="L265">            addRemovePathRWLock.writeLock().unlock();</span>
        }
    }

    void updateMetrics(final EventType type, int size) {
<span class="nc bnc" id="L270" title="All 5 branches missed.">        switch (type) {</span>
        case NodeCreated:
<span class="nc" id="L272">            ServerMetrics.getMetrics().NODE_CREATED_WATCHER.add(size);</span>
<span class="nc" id="L273">            break;</span>

        case NodeDeleted:
<span class="nc" id="L276">            ServerMetrics.getMetrics().NODE_DELETED_WATCHER.add(size);</span>
<span class="nc" id="L277">            break;</span>

        case NodeDataChanged:
<span class="nc" id="L280">            ServerMetrics.getMetrics().NODE_CHANGED_WATCHER.add(size);</span>
<span class="nc" id="L281">            break;</span>

        case NodeChildrenChanged:
<span class="nc" id="L284">            ServerMetrics.getMetrics().NODE_CHILDREN_WATCHER.add(size);</span>
<span class="nc" id="L285">            break;</span>
        default:
            // Other types not logged.
            break;
        }
<span class="nc" id="L290">    }</span>

    boolean isDeadWatcher(Watcher watcher) {
<span class="nc bnc" id="L293" title="All 4 branches missed.">        return watcher instanceof ServerCnxn &amp;&amp; ((ServerCnxn) watcher).isStale();</span>
    }

    int pathSize() {
<span class="nc" id="L297">        return pathWatches.size();</span>
    }

    @Override
    public WatchesSummary getWatchesSummary() {
<span class="nc" id="L302">        return new WatchesSummary(watcherBitIdMap.size(), pathSize(), size());</span>
    }

    @Override
    public WatchesReport getWatches() {
<span class="nc" id="L307">        Map&lt;Long, Set&lt;String&gt;&gt; id2paths = new HashMap&lt;Long, Set&lt;String&gt;&gt;();</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">        for (Entry&lt;Watcher, Set&lt;String&gt;&gt; e : getWatcher2PathesMap().entrySet()) {</span>
<span class="nc" id="L309">            Long id = ((ServerCnxn) e.getKey()).getSessionId();</span>
<span class="nc" id="L310">            Set&lt;String&gt; paths = new HashSet&lt;String&gt;(e.getValue());</span>
<span class="nc" id="L311">            id2paths.put(id, paths);</span>
<span class="nc" id="L312">        }</span>
<span class="nc" id="L313">        return new WatchesReport(id2paths);</span>
    }

    /**
     * Iterate through ConcurrentHashMap is 'safe', it will reflect the state
     * of the map at the time iteration began, may miss update while iterating,
     * given this is used in the commands to get a general idea of the watches
     * state, we don't care about missing some update.
     */
    @Override
    public WatchesPathReport getWatchesByPath() {
<span class="nc" id="L324">        Map&lt;String, Set&lt;Long&gt;&gt; path2ids = new HashMap&lt;String, Set&lt;Long&gt;&gt;();</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">        for (Entry&lt;String, BitHashSet&gt; e : pathWatches.entrySet()) {</span>
<span class="nc" id="L326">            BitHashSet watchers = e.getValue();</span>
<span class="nc" id="L327">            synchronized (watchers) {</span>
<span class="nc" id="L328">                Set&lt;Long&gt; ids = new HashSet&lt;Long&gt;(watchers.size());</span>
<span class="nc" id="L329">                path2ids.put(e.getKey(), ids);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">                for (Integer wbit : watchers) {</span>
<span class="nc" id="L331">                    Watcher watcher = watcherBitIdMap.get(wbit);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                    if (watcher instanceof ServerCnxn) {</span>
<span class="nc" id="L333">                        ids.add(((ServerCnxn) watcher).getSessionId());</span>
                    }
<span class="nc" id="L335">                }</span>
<span class="nc" id="L336">            }</span>
<span class="nc" id="L337">        }</span>
<span class="nc" id="L338">        return new WatchesPathReport(path2ids);</span>
    }

    /**
     * May cause OOM if there are lots of watches, might better to forbid
     * it in this class.
     */
    public Map&lt;Watcher, Set&lt;String&gt;&gt; getWatcher2PathesMap() {
<span class="nc" id="L346">        Map&lt;Watcher, Set&lt;String&gt;&gt; watcher2paths = new HashMap&lt;Watcher, Set&lt;String&gt;&gt;();</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        for (Entry&lt;String, BitHashSet&gt; e : pathWatches.entrySet()) {</span>
<span class="nc" id="L348">            String path = e.getKey();</span>
<span class="nc" id="L349">            BitHashSet watchers = e.getValue();</span>
            // avoid race condition with add/remove
<span class="nc" id="L351">            synchronized (watchers) {</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                for (Integer wbit : watchers) {</span>
<span class="nc" id="L353">                    Watcher w = watcherBitIdMap.get(wbit);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">                    if (w == null) {</span>
<span class="nc" id="L355">                        continue;</span>
                    }
<span class="nc bnc" id="L357" title="All 2 branches missed.">                    if (!watcher2paths.containsKey(w)) {</span>
<span class="nc" id="L358">                        watcher2paths.put(w, new HashSet&lt;String&gt;());</span>
                    }
<span class="nc" id="L360">                    watcher2paths.get(w).add(path);</span>
<span class="nc" id="L361">                }</span>
<span class="nc" id="L362">            }</span>
<span class="nc" id="L363">        }</span>
<span class="nc" id="L364">        return watcher2paths;</span>
    }

    @Override
    public void dumpWatches(PrintWriter pwriter, boolean byPath) {
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (byPath) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            for (Entry&lt;String, BitHashSet&gt; e : pathWatches.entrySet()) {</span>
<span class="nc" id="L371">                pwriter.println(e.getKey());</span>
<span class="nc" id="L372">                BitHashSet watchers = e.getValue();</span>
<span class="nc" id="L373">                synchronized (watchers) {</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                    for (Integer wbit : watchers) {</span>
<span class="nc" id="L375">                        Watcher w = watcherBitIdMap.get(wbit);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                        if (!(w instanceof ServerCnxn)) {</span>
<span class="nc" id="L377">                            continue;</span>
                        }
<span class="nc" id="L379">                        pwriter.print(&quot;\t0x&quot;);</span>
<span class="nc" id="L380">                        pwriter.print(Long.toHexString(((ServerCnxn) w).getSessionId()));</span>
<span class="nc" id="L381">                        pwriter.print(&quot;\n&quot;);</span>
<span class="nc" id="L382">                    }</span>
<span class="nc" id="L383">                }</span>
<span class="nc" id="L384">            }</span>
        } else {
<span class="nc bnc" id="L386" title="All 2 branches missed.">            for (Entry&lt;Watcher, Set&lt;String&gt;&gt; e : getWatcher2PathesMap().entrySet()) {</span>
<span class="nc" id="L387">                pwriter.print(&quot;0x&quot;);</span>
<span class="nc" id="L388">                pwriter.println(Long.toHexString(((ServerCnxn) e.getKey()).getSessionId()));</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                for (String path : e.getValue()) {</span>
<span class="nc" id="L390">                    pwriter.print(&quot;\t&quot;);</span>
<span class="nc" id="L391">                    pwriter.println(path);</span>
<span class="nc" id="L392">                }</span>
<span class="nc" id="L393">            }</span>
        }
<span class="nc" id="L395">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L399">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L400">        sb.append(watcherBitIdMap.size()).append(&quot; connections watching &quot;).append(pathSize()).append(&quot; paths\n&quot;);</span>
<span class="nc" id="L401">        sb.append(&quot;Total watches:&quot;).append(size());</span>
<span class="nc" id="L402">        return sb.toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>